//!# near-openapi-client

//!

//!Progenitor-generated client of NEAR JSON RPC API

//!

//!Consists of two crates:

//! - near-openapi-client - client to connect to the API, generated by progenitor

//! - near-openapi-types - types used by client

//!

//!### Usage example:

//!

//!Add near-openapi-client to your project dependencies:

//!```

//!cargo add near-openapi-client

//!```

//!

//!Use the client to get latest block info:

//!```rust

//!use near_openapi_client as client;

//!

//!// Setup client

//!const NEAR_RPC_URL_REMOTE: &str = "https://archival-rpc.mainnet.near.org";

//!let client_remote = client::Client::new(NEAR_RPC_URL_LOCAL);

//!

//!// Construct request

//!let payload_block_final = client::types::JsonRpcRequestForBlock {

//!    id: String::from("dontcare"),

//!    jsonrpc: String::from("2.0"),

//!    method: client::types::JsonRpcRequestForBlockMethod::Block,

//!    params: client::types::RpcBlockRequest::Finality(client::types::Finality::Final),

//!};

//!

//!// Make the request, get the response

//!let block_final: client::types::JsonRpcResponseForRpcBlockResponseAndRpcError =

//!    client_local.block(&payload_block_final).await?.into_inner();

//!println!("block_final: {:#?}", block_final);

//!```

//!

//!<details>

//!

//!<summary>Example response</summary>

//!

//!```

//!response for block_final: Variant0 {

//!    id: "dontcare",

//!    jsonrpc: "2.0",

//!    result: RpcBlockResponse {

//!        author: AccountId(

//!            "test.near",

//!        ),

//!        chunks: [

//!            ChunkHeaderView {

//!                balance_burnt: "0",

//!                bandwidth_requests: Some(

//!                    V1(

//!                        BandwidthRequestsV1 {

//!                            requests: [],

//!                        },

//!                    ),

//!                ),

//!                chunk_hash: CryptoHash(

//!                    "59srn1AQyCxqhXuURBGomupX8tCEj25XXFW15YZDgnM6",

//!                ),

//!                congestion_info: Some(

//!                    CongestionInfoView {

//!                        allowed_shard: 0,

//!                        buffered_receipts_gas: "0",

//!                        delayed_receipts_gas: "0",

//!                        receipt_bytes: 0,

//!                    },

//!                ),

//!                encoded_length: 8,

//!                encoded_merkle_root: CryptoHash(

//!                    "79Bt7ivt9Qhp3c6dJYnueaTyPVweYxZRpQHASRRAiyuy",

//!                ),

//!                gas_limit: 1000000000000000,

//!                gas_used: 0,

//!                height_created: 6,

//!                height_included: 6,

//!                outcome_root: CryptoHash(

//!                    "11111111111111111111111111111111",

//!                ),

//!                outgoing_receipts_root: CryptoHash(

//!                    "H4Rd6SGeEBTbxkitsCdzfu9xL9HtZ2eHoPCQXUeZ6bW4",

//!                ),

//!                prev_block_hash: CryptoHash(

//!                    "DeJY83ZJbakCtkwe9J8RTE9TEAybp4E1GFCVrdki8Z6c",

//!                ),

//!                prev_state_root: CryptoHash(

//!                    "7t7WeJdAzh9qmKLHfVRboDZupfAjfy9FC3onAN1LRnyp",

//!                ),

//!                rent_paid: "0",

//!                shard_id: ShardId(

//!                    0,

//!                ),

//!                signature: Signature(

//!                    "ed25519:5G8UWLLuVk3WvQTnSHmT7EQoCz521EaaxQ8f5mgNVxJjFW7o9VFfxuG6D5bNfCjmoTVWbc9WrUbXg2L11iGWQw2g",

//!                ),

//!                tx_root: CryptoHash(

//!                    "11111111111111111111111111111111",

//!                ),

//!                validator_proposals: [],

//!                validator_reward: "0",

//!            },

//!        ],

//!        header: BlockHeaderView {

//!            approvals: [

//!                Some(

//!                    Signature(

//!                        "ed25519:4GobVKSiiRfwMBrukNeCLbiUQLAzVprFCSn5jDVqA8zm6oR9H8EudEogsBAedBqJKF8vXhohSC5Kfnsdw2XMXMw6",

//!                    ),

//!                ),

//!            ],

//!            block_body_hash: Some(

//!                CryptoHash(

//!                    "CjDTJC25qznGymgHiUrDwSgaqsme3deDNj3ftPWFfBew",

//!                ),

//!            ),

//!            block_merkle_root: CryptoHash(

//!                "EXTvaXuYTcvEd8KnWjhruX9NYNCTbXJrwfzEJAnELBds",

//!            ),

//!            block_ordinal: Some(

//!                7,

//!            ),

//!            challenges_result: [],

//!            challenges_root: CryptoHash(

//!                "11111111111111111111111111111111",

//!            ),

//!            chunk_endorsements: Some(

//!                [

//!                    [

//!                        1,

//!                    ],

//!                ],

//!            ),

//!            chunk_headers_root: CryptoHash(

//!                "6fPXKHJce8krAwsXfdMgsSgmUd5CgcJBpBFKBhb7QT2j",

//!            ),

//!            chunk_mask: [

//!                true,

//!            ],

//!            chunk_receipts_root: CryptoHash(

//!                "9ETNjrt6MkwTgSVMMbpukfxRshSD1avBUUa4R4NuqwHv",

//!            ),

//!            chunk_tx_root: CryptoHash(

//!                "7tkzFg8RHBmMw1ncRJZCCZAizgq4rwCftTKYLce8RU8t",

//!            ),

//!            chunks_included: 1,

//!            epoch_id: CryptoHash(

//!                "11111111111111111111111111111111",

//!            ),

//!            epoch_sync_data_hash: None,

//!            gas_price: "100000000",

//!            hash: CryptoHash(

//!                "8UgWEvtdVcEu6uYBFboZKDoLsWk5DC5tz656fW3BA4ZL",

//!            ),

//!            height: 6,

//!            last_ds_final_block: CryptoHash(

//!                "DeJY83ZJbakCtkwe9J8RTE9TEAybp4E1GFCVrdki8Z6c",

//!            ),

//!            last_final_block: CryptoHash(

//!                "AMu9bpsii9wjFukjFc5cMaBNCNDvmiz4Z7AmwBAMcDLh",

//!            ),

//!            latest_protocol_version: 78,

//!            next_bp_hash: CryptoHash(

//!                "ChxUrwNyJDYA9PbecbLq1KBvkj2mEW3nvzXHC244X2rT",

//!            ),

//!            next_epoch_id: CryptoHash(

//!                "GsJ8x5msDUv7Zz4LgCxoqzeyWKvNT2sHdFyEdR3vZrCZ",

//!            ),

//!            outcome_root: CryptoHash(

//!                "7tkzFg8RHBmMw1ncRJZCCZAizgq4rwCftTKYLce8RU8t",

//!            ),

//!            prev_hash: CryptoHash(

//!                "DeJY83ZJbakCtkwe9J8RTE9TEAybp4E1GFCVrdki8Z6c",

//!            ),

//!            prev_height: Some(

//!                5,

//!            ),

//!            prev_state_root: CryptoHash(

//!                "9wppbHBR63GhoJWW3ti6qhD5AAEmiNr1DKWQq9kLwrHM",

//!            ),

//!            random_value: CryptoHash(

//!                "6MypYizcvSPkaxgd7cXAgGfHo8TsnmouzLtCHnGASbKe",

//!            ),

//!            rent_paid: "0",

//!            signature: Signature(

//!                "ed25519:3jHUhecrkNYoTDrQ8jARWco8vCNCdrwPewZrv1HQeTE5tQj78fjAYkJbgeFo8wcyi6maTFFYRNdHQ8nrmFa1Pjc",

//!            ),

//!            timestamp: 1750759979825366257,

//!            timestamp_nanosec: "1750759979825366257",

//!            total_supply: "2050000000000000000000000000000000",

//!            validator_proposals: [],

//!            validator_reward: "0",

//!        },

//!    },

//!}

//!```

//!

//!</details>

//!
pub use near_openapi_types as types;
#[allow(unused_imports)]
use progenitor_client::{encode_path, ClientHooks, OperationInfo, RequestBuilderExt};
#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, ClientInfo, Error, ResponseValue};
#[derive(Clone, Debug)]
#[doc = "Client for NEAR Protocol JSON RPC API\n\nVersion: 1.0.0"]
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}
impl Client {
    #[doc = r" Create a new client."]
    #[doc = r""]
    #[doc = r" `baseurl` is the base URL provided to the internal"]
    #[doc = r" `reqwest::Client`, and should include a scheme and hostname,"]
    #[doc = r" as well as port and a path stem if applicable."]
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }
    #[doc = r" Construct a new client with an existing `reqwest::Client`,"]
    #[doc = r" allowing more control over its configuration."]
    #[doc = r""]
    #[doc = r" `baseurl` is the base URL provided to the internal"]
    #[doc = r" `reqwest::Client`, and should include a scheme and hostname,"]
    #[doc = r" as well as port and a path stem if applicable."]
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
}
impl ClientInfo<()> for Client {
    fn api_version() -> &'static str {
        "1.0.0"
    }
    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }
    fn client(&self) -> &reqwest::Client {
        &self.client
    }
    fn inner(&self) -> &() {
        &()
    }
}
impl ClientHooks<()> for &Client {}
#[allow(clippy::all)]
#[allow(elided_named_lifetimes)]
impl Client {
    #[doc = "Sends a `POST` request to `/EXPERIMENTAL_changes`\n\n"]
    pub async fn experimental_changes<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalChanges,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_changes",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/EXPERIMENTAL_changes_in_block`\n\n"]
    pub async fn experimental_changes_in_block<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalChangesInBlock,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_changes_in_block",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/EXPERIMENTAL_congestion_level`\n\n"]
    pub async fn experimental_congestion_level<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalCongestionLevel,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcCongestionLevelResponseAndRpcError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_congestion_level",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/EXPERIMENTAL_genesis_config`\n\n"]
    pub async fn experimental_genesis_config<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalGenesisConfig,
    ) -> Result<ResponseValue<types::JsonRpcResponseForGenesisConfigAndRpcError>, Error<()>> {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_genesis_config",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/EXPERIMENTAL_light_client_block_proof`\n\n"]
    pub async fn experimental_light_client_block_proof<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalLightClientBlockProof,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_light_client_block_proof",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/EXPERIMENTAL_light_client_proof`\n\n"]
    pub async fn experimental_light_client_proof<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalLightClientProof,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_light_client_proof",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/EXPERIMENTAL_maintenance_windows`\n\n"]
    pub async fn experimental_maintenance_windows<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalMaintenanceWindows,
    ) -> Result<ResponseValue<types::JsonRpcResponseForArrayOfRangeOfUint64AndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_maintenance_windows",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/EXPERIMENTAL_protocol_config`\n\n"]
    pub async fn experimental_protocol_config<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalProtocolConfig,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcProtocolConfigResponseAndRpcError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_protocol_config",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/EXPERIMENTAL_receipt`\n\n"]
    pub async fn experimental_receipt<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalReceipt,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcReceiptResponseAndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_receipt",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/EXPERIMENTAL_split_storage_info`\n\n"]
    pub async fn experimental_split_storage_info<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalSplitStorageInfo,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_split_storage_info",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/EXPERIMENTAL_tx_status`\n\n"]
    pub async fn experimental_tx_status<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalTxStatus,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcTransactionResponseAndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_tx_status",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/EXPERIMENTAL_validators_ordered`\n\n"]
    pub async fn experimental_validators_ordered<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForExperimentalValidatorsOrdered,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "experimental_validators_ordered",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/block`\n\n"]
    pub async fn block<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForBlock,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcBlockResponseAndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "block",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/broadcast_tx_async`\n\n"]
    pub async fn broadcast_tx_async<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForBroadcastTxAsync,
    ) -> Result<ResponseValue<types::JsonRpcResponseForCryptoHashAndRpcError>, Error<()>> {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "broadcast_tx_async",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/broadcast_tx_commit`\n\n"]
    pub async fn broadcast_tx_commit<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForBroadcastTxCommit,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcTransactionResponseAndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "broadcast_tx_commit",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/changes`\n\n"]
    pub async fn changes<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForChanges,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "changes",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/chunk`\n\n"]
    pub async fn chunk<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForChunk,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcChunkResponseAndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "chunk",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/client_config`\n\n"]
    pub async fn client_config<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForClientConfig,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcClientConfigResponseAndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "client_config",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/gas_price`\n\n"]
    pub async fn gas_price<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForGasPrice,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcGasPriceResponseAndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "gas_price",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/health`\n\n"]
    pub async fn health<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForHealth,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForNullableRpcHealthResponseAndRpcError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "health",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/light_client_proof`\n\n"]
    pub async fn light_client_proof<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForLightClientProof,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "light_client_proof",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/network_info`\n\n"]
    pub async fn network_info<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForNetworkInfo,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcNetworkInfoResponseAndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "network_info",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/next_light_client_block`\n\n"]
    pub async fn next_light_client_block<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForNextLightClientBlock,
    ) -> Result<
        ResponseValue<types::JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError>,
        Error<()>,
    > {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "next_light_client_block",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/query`\n\n"]
    pub async fn query<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForQuery,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcQueryResponseAndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "query",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/send_tx`\n\n"]
    pub async fn send_tx<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForSendTx,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcTransactionResponseAndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "send_tx",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/status`\n\n"]
    pub async fn status<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForStatus,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcStatusResponseAndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "status",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/tx`\n\n"]
    pub async fn tx<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForTx,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcTransactionResponseAndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo { operation_id: "tx" };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
    #[doc = "Sends a `POST` request to `/validators`\n\n"]
    pub async fn validators<'a>(
        &'a self,
        body: &'a types::JsonRpcRequestForValidators,
    ) -> Result<ResponseValue<types::JsonRpcResponseForRpcValidatorResponseAndRpcError>, Error<()>>
    {
        let url = format!("{}/", self.baseurl,);
        let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
        header_map.append(
            ::reqwest::header::HeaderName::from_static("api-version"),
            ::reqwest::header::HeaderValue::from_static(Self::api_version()),
        );
        #[allow(unused_mut)]
        let mut request = self
            .client
            .post(url)
            .header(
                ::reqwest::header::ACCEPT,
                ::reqwest::header::HeaderValue::from_static("application/json"),
            )
            .json(&body)
            .headers(header_map)
            .build()?;
        let info = OperationInfo {
            operation_id: "validators",
        };
        self.pre(&mut request, &info).await?;
        let result = self.exec(request, &info).await;
        self.post(&result, &info).await?;
        let response = result?;
        match response.status().as_u16() {
            200u16 => ResponseValue::from_response(response).await,
            _ => Err(Error::UnexpectedResponse(response)),
        }
    }
}
#[doc = r" Items consumers will typically use such as the Client."]
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
}
