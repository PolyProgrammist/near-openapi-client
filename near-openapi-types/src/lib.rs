//! This crate provides types for the Near OpenAPI specification.
//!
//! Used in [near-openapi-client](https://docs.rs/near-openapi-client/latest/near_openapi_client/)
pub use near_account_id::AccountId;
#[allow(unused_imports)]
use progenitor_client::{encode_path, ClientHooks, OperationInfo, RequestBuilderExt};
#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, ClientInfo, Error, ResponseValue};
#[doc = r" Error types."]
pub mod error {
    #[doc = r" Error from a `TryFrom` or `FromStr` implementation."]
    pub struct ConversionError(::std::borrow::Cow<'static, str>);
    impl ::std::error::Error for ConversionError {}
    impl ::std::fmt::Display for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl ::std::fmt::Debug for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
#[doc = "Access key provides limited access to an account. Each access key belongs to some account and\nis identified by a unique (within the account) public key. One account may have large number of\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\nthat can be issued.\n`account_id,public_key` is a key in the state"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Access key provides limited access to an account. Each access key belongs to some account and\\nis identified by a unique (within the account) public key. One account may have large number of\\naccess keys. Access keys allow to act on behalf of the account by restricting transactions\\nthat can be issued.\\n`account_id,public_key` is a key in the state\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"nonce\","]
#[doc = "    \"permission\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"nonce\": {"]
#[doc = "      \"description\": \"Nonce for this access key, used for tx nonce generation. When access key is created, nonce\\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\\nSee <https://github.com/near/nearcore/issues/3779> for more details.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"permission\": {"]
#[doc = "      \"description\": \"Defines permissions for this access key.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccessKeyPermission\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AccessKey {
    #[doc = "Nonce for this access key, used for tx nonce generation. When access key is created, nonce\nis set to `(block_height - 1) * 1e6` to avoid tx hash collision on access key re-creation.\nSee <https://github.com/near/nearcore/issues/3779> for more details."]
    pub nonce: u64,
    #[doc = "Defines permissions for this access key."]
    pub permission: AccessKeyPermission,
}
impl ::std::convert::From<&AccessKey> for AccessKey {
    fn from(value: &AccessKey) -> Self {
        value.clone()
    }
}
#[doc = "Describes the cost of creating an access key."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes the cost of creating an access key.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"full_access_cost\","]
#[doc = "    \"function_call_cost\","]
#[doc = "    \"function_call_cost_per_byte\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"full_access_cost\": {"]
#[doc = "      \"description\": \"Base cost of creating a full access access-key.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"function_call_cost\": {"]
#[doc = "      \"description\": \"Base cost of creating an access-key restricted to specific functions.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"function_call_cost_per_byte\": {"]
#[doc = "      \"description\": \"Cost per byte of method_names of creating a restricted access-key.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AccessKeyCreationConfigView {
    #[doc = "Base cost of creating a full access access-key."]
    pub full_access_cost: Fee,
    #[doc = "Base cost of creating an access-key restricted to specific functions."]
    pub function_call_cost: Fee,
    #[doc = "Cost per byte of method_names of creating a restricted access-key."]
    pub function_call_cost_per_byte: Fee,
}
impl ::std::convert::From<&AccessKeyCreationConfigView> for AccessKeyCreationConfigView {
    fn from(value: &AccessKeyCreationConfigView) -> Self {
        value.clone()
    }
}
#[doc = "Describes information about an access key including the public key."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes information about an access key including the public key.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"access_key\","]
#[doc = "    \"public_key\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccessKeyView\""]
#[doc = "    },"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AccessKeyInfoView {
    pub access_key: AccessKeyView,
    pub public_key: PublicKey,
}
impl ::std::convert::From<&AccessKeyInfoView> for AccessKeyInfoView {
    fn from(value: &AccessKeyInfoView) -> Self {
        value.clone()
    }
}
#[doc = "Lists access keys"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Lists access keys\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"keys\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"keys\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/AccessKeyInfoView\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AccessKeyList {
    pub keys: ::std::vec::Vec<AccessKeyInfoView>,
}
impl ::std::convert::From<&AccessKeyList> for AccessKeyList {
    fn from(value: &AccessKeyList) -> Self {
        value.clone()
    }
}
#[doc = "Defines permissions for AccessKey"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Defines permissions for AccessKey\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"FunctionCall\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"FunctionCall\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/FunctionCallPermission\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Grants full access to the account.\\nNOTE: It's used to replace account-level public keys.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"FullAccess\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum AccessKeyPermission {
    FunctionCall(FunctionCallPermission),
    #[doc = "Grants full access to the account.\nNOTE: It's used to replace account-level public keys."]
    FullAccess,
}
impl ::std::convert::From<&Self> for AccessKeyPermission {
    fn from(value: &AccessKeyPermission) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<FunctionCallPermission> for AccessKeyPermission {
    fn from(value: FunctionCallPermission) -> Self {
        Self::FunctionCall(value)
    }
}
#[doc = "Describes the permission scope for an access key. Whether it is a function call or a full access key."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes the permission scope for an access key. Whether it is a function call or a full access key.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"FullAccess\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"FunctionCall\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"FunctionCall\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"method_names\","]
#[doc = "            \"receiver_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"allowance\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"method_names\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"type\": \"string\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"receiver_id\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum AccessKeyPermissionView {
    FullAccess,
    FunctionCall {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        allowance: ::std::option::Option<::std::string::String>,
        method_names: ::std::vec::Vec<::std::string::String>,
        receiver_id: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for AccessKeyPermissionView {
    fn from(value: &AccessKeyPermissionView) -> Self {
        value.clone()
    }
}
#[doc = "Describes access key permission scope and nonce."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes access key permission scope and nonce.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"nonce\","]
#[doc = "    \"permission\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"nonce\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"permission\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccessKeyPermissionView\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AccessKeyView {
    pub nonce: u64,
    pub permission: AccessKeyPermissionView,
}
impl ::std::convert::From<&AccessKeyView> for AccessKeyView {
    fn from(value: &AccessKeyView) -> Self {
        value.clone()
    }
}
#[doc = "`AccountChangesByBlockIdChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"account_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AccountChangesByBlockIdChangesType {
    #[serde(rename = "account_changes")]
    AccountChanges,
}
impl ::std::convert::From<&Self> for AccountChangesByBlockIdChangesType {
    fn from(value: &AccountChangesByBlockIdChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AccountChangesByBlockIdChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AccountChanges => write!(f, "account_changes"),
        }
    }
}
impl ::std::str::FromStr for AccountChangesByBlockIdChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "account_changes" => Ok(Self::AccountChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AccountChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AccountChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AccountChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AccountChangesByFinalityChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"account_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AccountChangesByFinalityChangesType {
    #[serde(rename = "account_changes")]
    AccountChanges,
}
impl ::std::convert::From<&Self> for AccountChangesByFinalityChangesType {
    fn from(value: &AccountChangesByFinalityChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AccountChangesByFinalityChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AccountChanges => write!(f, "account_changes"),
        }
    }
}
impl ::std::str::FromStr for AccountChangesByFinalityChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "account_changes" => Ok(Self::AccountChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AccountChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AccountChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AccountChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AccountChangesBySyncCheckpointChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"account_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AccountChangesBySyncCheckpointChangesType {
    #[serde(rename = "account_changes")]
    AccountChanges,
}
impl ::std::convert::From<&Self> for AccountChangesBySyncCheckpointChangesType {
    fn from(value: &AccountChangesBySyncCheckpointChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AccountChangesBySyncCheckpointChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AccountChanges => write!(f, "account_changes"),
        }
    }
}
impl ::std::str::FromStr for AccountChangesBySyncCheckpointChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "account_changes" => Ok(Self::AccountChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AccountChangesBySyncCheckpointChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AccountChangesBySyncCheckpointChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AccountChangesBySyncCheckpointChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The structure describes configuration for creation of new accounts."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The structure describes configuration for creation of new accounts.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"min_allowed_top_level_account_length\","]
#[doc = "    \"registrar_account_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"min_allowed_top_level_account_length\": {"]
#[doc = "      \"description\": \"The minimum length of the top-level account ID that is allowed to be created by any account.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint8\","]
#[doc = "      \"maximum\": 255.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"registrar_account_id\": {"]
#[doc = "      \"description\": \"The account ID of the account registrar. This account ID allowed to create top-level\\naccounts of any valid length.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AccountCreationConfigView {
    #[doc = "The minimum length of the top-level account ID that is allowed to be created by any account."]
    pub min_allowed_top_level_account_length: u8,
    #[doc = "The account ID of the account registrar. This account ID allowed to create top-level\naccounts of any valid length."]
    pub registrar_account_id: AccountId,
}
impl ::std::convert::From<&AccountCreationConfigView> for AccountCreationConfigView {
    fn from(value: &AccountCreationConfigView) -> Self {
        value.clone()
    }
}
#[doc = "AccountData is a piece of global state that a validator\nsigns and broadcasts to the network. It is essentially\nthe data that a validator wants to share with the network.\nAll the nodes in the network are collecting the account data\nbroadcasted by the validators.\nSince the number of the validators is bounded and their\nidentity is known (and the maximal size of allowed AccountData is bounded)\nthe global state that is distributed in the form of AccountData is bounded\nas well.\nFind more information in the docs [here](https://github.com/near/nearcore/blob/560f7fc8f4b3106e0d5d46050688610b1f104ac6/chain/client/src/client.rs#L2232)"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"AccountData is a piece of global state that a validator\\nsigns and broadcasts to the network. It is essentially\\nthe data that a validator wants to share with the network.\\nAll the nodes in the network are collecting the account data\\nbroadcasted by the validators.\\nSince the number of the validators is bounded and their\\nidentity is known (and the maximal size of allowed AccountData is bounded)\\nthe global state that is distributed in the form of AccountData is bounded\\nas well.\\nFind more information in the docs [here](https://github.com/near/nearcore/blob/560f7fc8f4b3106e0d5d46050688610b1f104ac6/chain/client/src/client.rs#L2232)\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_key\","]
#[doc = "    \"peer_id\","]
#[doc = "    \"proxies\","]
#[doc = "    \"timestamp\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_key\": {"]
#[doc = "      \"description\": \"Account key of the validator signing this AccountData.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"peer_id\": {"]
#[doc = "      \"description\": \"ID of the node that handles the account key (aka validator key).\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"proxies\": {"]
#[doc = "      \"description\": \"Proxy nodes that are directly connected to the validator node\\n(this list may include the validator node itself).\\nTIER1 nodes should connect to one of the proxies to sent TIER1\\nmessages to the validator.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/Tier1ProxyView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"timestamp\": {"]
#[doc = "      \"description\": \"UTC timestamp of when the AccountData has been signed.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AccountDataView {
    #[doc = "Account key of the validator signing this AccountData."]
    pub account_key: PublicKey,
    #[doc = "ID of the node that handles the account key (aka validator key)."]
    pub peer_id: PublicKey,
    #[doc = "Proxy nodes that are directly connected to the validator node\n(this list may include the validator node itself).\nTIER1 nodes should connect to one of the proxies to sent TIER1\nmessages to the validator."]
    pub proxies: ::std::vec::Vec<Tier1ProxyView>,
    #[doc = "UTC timestamp of when the AccountData has been signed."]
    pub timestamp: ::std::string::String,
}
impl ::std::convert::From<&AccountDataView> for AccountDataView {
    fn from(value: &AccountDataView) -> Self {
        value.clone()
    }
}
#[doc = "`AccountIdValidityRulesVersion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"format\": \"uint8\","]
#[doc = "  \"maximum\": 255.0,"]
#[doc = "  \"minimum\": 0.0"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct AccountIdValidityRulesVersion(pub u8);
impl ::std::ops::Deref for AccountIdValidityRulesVersion {
    type Target = u8;
    fn deref(&self) -> &u8 {
        &self.0
    }
}
impl ::std::convert::From<AccountIdValidityRulesVersion> for u8 {
    fn from(value: AccountIdValidityRulesVersion) -> Self {
        value.0
    }
}
impl ::std::convert::From<&AccountIdValidityRulesVersion> for AccountIdValidityRulesVersion {
    fn from(value: &AccountIdValidityRulesVersion) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<u8> for AccountIdValidityRulesVersion {
    fn from(value: u8) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for AccountIdValidityRulesVersion {
    type Err = <u8 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for AccountIdValidityRulesVersion {
    type Error = <u8 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for AccountIdValidityRulesVersion {
    type Error = <u8 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for AccountIdValidityRulesVersion {
    type Error = <u8 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for AccountIdValidityRulesVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "Account info for validators"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Account info for validators\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"amount\","]
#[doc = "    \"public_key\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"amount\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AccountInfo {
    pub account_id: AccountId,
    pub amount: ::std::string::String,
    pub public_key: PublicKey,
}
impl ::std::convert::From<&AccountInfo> for AccountInfo {
    fn from(value: &AccountInfo) -> Self {
        value.clone()
    }
}
#[doc = "A view of the account"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A view of the account\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"amount\","]
#[doc = "    \"code_hash\","]
#[doc = "    \"locked\","]
#[doc = "    \"storage_usage\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"amount\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"code_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"global_contract_account_id\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"global_contract_hash\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"locked\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"storage_paid_at\": {"]
#[doc = "      \"description\": \"TODO(2271): deprecated.\","]
#[doc = "      \"default\": 0,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_usage\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AccountView {
    pub amount: ::std::string::String,
    pub code_hash: CryptoHash,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub global_contract_account_id: ::std::option::Option<AccountId>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub global_contract_hash: ::std::option::Option<CryptoHash>,
    pub locked: ::std::string::String,
    #[doc = "TODO(2271): deprecated."]
    #[serde(default)]
    pub storage_paid_at: u64,
    pub storage_usage: u64,
}
impl ::std::convert::From<&AccountView> for AccountView {
    fn from(value: &AccountView) -> Self {
        value.clone()
    }
}
#[doc = "Account ID with its public key."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Account ID with its public key.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"public_key\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AccountWithPublicKey {
    pub account_id: AccountId,
    pub public_key: PublicKey,
}
impl ::std::convert::From<&AccountWithPublicKey> for AccountWithPublicKey {
    fn from(value: &AccountWithPublicKey) -> Self {
        value.clone()
    }
}
#[doc = "`Action`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"Create an (sub)account using a transaction `receiver_id` as an ID for\\na new account ID must pass validation rules described here\\n<http://nomicon.io/Primitives/Account.html>.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"CreateAccount\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"CreateAccount\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CreateAccountAction\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Sets a Wasm code to a receiver_id\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DeployContract\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DeployContract\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/DeployContractAction\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"FunctionCall\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"FunctionCall\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/FunctionCallAction\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Transfer\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Transfer\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/TransferAction\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Stake\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Stake\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/StakeAction\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"AddKey\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"AddKey\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/AddKeyAction\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DeleteKey\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DeleteKey\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/DeleteKeyAction\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DeleteAccount\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DeleteAccount\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/DeleteAccountAction\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Delegate\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Delegate\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/SignedDelegateAction\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DeployGlobalContract\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DeployGlobalContract\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/DeployGlobalContractAction\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"UseGlobalContract\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"UseGlobalContract\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/UseGlobalContractAction\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum Action {
    #[doc = "Create an (sub)account using a transaction `receiver_id` as an ID for\na new account ID must pass validation rules described here\n<http://nomicon.io/Primitives/Account.html>."]
    CreateAccount(CreateAccountAction),
    #[doc = "Sets a Wasm code to a receiver_id"]
    DeployContract(DeployContractAction),
    FunctionCall(FunctionCallAction),
    Transfer(TransferAction),
    Stake(StakeAction),
    AddKey(AddKeyAction),
    DeleteKey(DeleteKeyAction),
    DeleteAccount(DeleteAccountAction),
    Delegate(SignedDelegateAction),
    DeployGlobalContract(DeployGlobalContractAction),
    UseGlobalContract(UseGlobalContractAction),
}
impl ::std::convert::From<&Self> for Action {
    fn from(value: &Action) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<CreateAccountAction> for Action {
    fn from(value: CreateAccountAction) -> Self {
        Self::CreateAccount(value)
    }
}
impl ::std::convert::From<DeployContractAction> for Action {
    fn from(value: DeployContractAction) -> Self {
        Self::DeployContract(value)
    }
}
impl ::std::convert::From<FunctionCallAction> for Action {
    fn from(value: FunctionCallAction) -> Self {
        Self::FunctionCall(value)
    }
}
impl ::std::convert::From<TransferAction> for Action {
    fn from(value: TransferAction) -> Self {
        Self::Transfer(value)
    }
}
impl ::std::convert::From<StakeAction> for Action {
    fn from(value: StakeAction) -> Self {
        Self::Stake(value)
    }
}
impl ::std::convert::From<AddKeyAction> for Action {
    fn from(value: AddKeyAction) -> Self {
        Self::AddKey(value)
    }
}
impl ::std::convert::From<DeleteKeyAction> for Action {
    fn from(value: DeleteKeyAction) -> Self {
        Self::DeleteKey(value)
    }
}
impl ::std::convert::From<DeleteAccountAction> for Action {
    fn from(value: DeleteAccountAction) -> Self {
        Self::DeleteAccount(value)
    }
}
impl ::std::convert::From<SignedDelegateAction> for Action {
    fn from(value: SignedDelegateAction) -> Self {
        Self::Delegate(value)
    }
}
impl ::std::convert::From<DeployGlobalContractAction> for Action {
    fn from(value: DeployGlobalContractAction) -> Self {
        Self::DeployGlobalContract(value)
    }
}
impl ::std::convert::From<UseGlobalContractAction> for Action {
    fn from(value: UseGlobalContractAction) -> Self {
        Self::UseGlobalContract(value)
    }
}
#[doc = "Describes the cost of creating a specific action, `Action`. Includes all variants."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes the cost of creating a specific action, `Action`. Includes all variants.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"add_key_cost\","]
#[doc = "    \"create_account_cost\","]
#[doc = "    \"delegate_cost\","]
#[doc = "    \"delete_account_cost\","]
#[doc = "    \"delete_key_cost\","]
#[doc = "    \"deploy_contract_cost\","]
#[doc = "    \"deploy_contract_cost_per_byte\","]
#[doc = "    \"function_call_cost\","]
#[doc = "    \"function_call_cost_per_byte\","]
#[doc = "    \"stake_cost\","]
#[doc = "    \"transfer_cost\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"add_key_cost\": {"]
#[doc = "      \"description\": \"Base cost of adding a key.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccessKeyCreationConfigView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"create_account_cost\": {"]
#[doc = "      \"description\": \"Base cost of creating an account.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"delegate_cost\": {"]
#[doc = "      \"description\": \"Base cost for processing a delegate action.\\n\\nThis is on top of the costs for the actions inside the delegate action.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"delete_account_cost\": {"]
#[doc = "      \"description\": \"Base cost of deleting an account.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"delete_key_cost\": {"]
#[doc = "      \"description\": \"Base cost of deleting a key.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"deploy_contract_cost\": {"]
#[doc = "      \"description\": \"Base cost of deploying a contract.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"deploy_contract_cost_per_byte\": {"]
#[doc = "      \"description\": \"Cost per byte of deploying a contract.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"function_call_cost\": {"]
#[doc = "      \"description\": \"Base cost of calling a function.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"function_call_cost_per_byte\": {"]
#[doc = "      \"description\": \"Cost per byte of method name and arguments of calling a function.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"stake_cost\": {"]
#[doc = "      \"description\": \"Base cost of staking.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"transfer_cost\": {"]
#[doc = "      \"description\": \"Base cost of making a transfer.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ActionCreationConfigView {
    #[doc = "Base cost of adding a key."]
    pub add_key_cost: AccessKeyCreationConfigView,
    #[doc = "Base cost of creating an account."]
    pub create_account_cost: Fee,
    #[doc = "Base cost for processing a delegate action.\n\nThis is on top of the costs for the actions inside the delegate action."]
    pub delegate_cost: Fee,
    #[doc = "Base cost of deleting an account."]
    pub delete_account_cost: Fee,
    #[doc = "Base cost of deleting a key."]
    pub delete_key_cost: Fee,
    #[doc = "Base cost of deploying a contract."]
    pub deploy_contract_cost: Fee,
    #[doc = "Cost per byte of deploying a contract."]
    pub deploy_contract_cost_per_byte: Fee,
    #[doc = "Base cost of calling a function."]
    pub function_call_cost: Fee,
    #[doc = "Cost per byte of method name and arguments of calling a function."]
    pub function_call_cost_per_byte: Fee,
    #[doc = "Base cost of staking."]
    pub stake_cost: Fee,
    #[doc = "Base cost of making a transfer."]
    pub transfer_cost: Fee,
}
impl ::std::convert::From<&ActionCreationConfigView> for ActionCreationConfigView {
    fn from(value: &ActionCreationConfigView) -> Self {
        value.clone()
    }
}
#[doc = "An error happened during Action execution"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An error happened during Action execution\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"kind\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"index\": {"]
#[doc = "      \"description\": \"Index of the failed action in the transaction.\\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"kind\": {"]
#[doc = "      \"description\": \"The kind of ActionError happened\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/ActionErrorKind\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ActionError {
    #[doc = "Index of the failed action in the transaction.\nAction index is not defined if ActionError.kind is `ActionErrorKind::LackBalanceForState`"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub index: ::std::option::Option<u64>,
    #[doc = "The kind of ActionError happened"]
    pub kind: ActionErrorKind,
}
impl ::std::convert::From<&ActionError> for ActionError {
    fn from(value: &ActionError) -> Self {
        value.clone()
    }
}
#[doc = "`ActionErrorKind`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"AccountAlreadyExists\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"AccountAlreadyExists\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"AccountDoesNotExist\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"AccountDoesNotExist\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"A top-level account ID can only be created by registrar.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"CreateAccountOnlyByRegistrar\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"CreateAccountOnlyByRegistrar\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"predecessor_id\","]
#[doc = "            \"registrar_account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"predecessor_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"registrar_account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"A newly created account must be under a namespace of the creator account\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"CreateAccountNotAllowed\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"CreateAccountNotAllowed\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"predecessor_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"predecessor_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\\nor the first TX action is a `CreateAccount` action\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ActorNoPermission\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ActorNoPermission\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"actor_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"actor_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Account tries to remove an access key that doesn't exist\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DeleteKeyDoesNotExist\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DeleteKeyDoesNotExist\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"public_key\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The public key is already used for an existing access key\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"AddKeyAlreadyExists\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"AddKeyAlreadyExists\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"public_key\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Account is staking and can not be deleted\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DeleteAccountStaking\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DeleteAccountStaking\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"LackBalanceForState\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"LackBalanceForState\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"amount\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"description\": \"An account which needs balance\","]
#[doc = "              \"allOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"amount\": {"]
#[doc = "              \"description\": \"Balance required to complete an action.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Account is not yet staked, but tries to unstake\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"TriesToUnstake\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"TriesToUnstake\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The account doesn't have enough balance to increase the stake.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"TriesToStake\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"TriesToStake\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"balance\","]
#[doc = "            \"locked\","]
#[doc = "            \"stake\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"balance\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"locked\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"stake\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InsufficientStake\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InsufficientStake\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"minimum_stake\","]
#[doc = "            \"stake\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"minimum_stake\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"stake\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"An error occurred during a `FunctionCall` Action, parameter is debug message.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"FunctionCallError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"FunctionCallError\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/FunctionCallError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\\nreceipt validation.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"NewReceiptValidationError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"NewReceiptValidationError\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/ReceiptValidationError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\\n\\nTODO(#8598): This error is named very poorly. A better name would be\\n`OnlyNamedAccountCreationAllowed`.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"OnlyImplicitAccountCreationAllowed\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"OnlyImplicitAccountCreationAllowed\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Delete account whose state is large is temporarily banned.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DeleteAccountWithLargeState\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DeleteAccountWithLargeState\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Signature does not match the provided actions and given signer public key.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"DelegateActionInvalidSignature\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Receiver of the transaction doesn't match Sender of the delegate action\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DelegateActionSenderDoesNotMatchTxReceiver\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DelegateActionSenderDoesNotMatchTxReceiver\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"receiver_id\","]
#[doc = "            \"sender_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"receiver_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"sender_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Delegate action has expired. `max_block_height` is less than actual block height.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"DelegateActionExpired\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The given public key doesn't exist for Sender account\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DelegateActionAccessKeyError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DelegateActionAccessKeyError\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/InvalidAccessKeyError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"DelegateAction nonce must be greater sender[public_key].nonce\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DelegateActionInvalidNonce\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DelegateActionInvalidNonce\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"ak_nonce\","]
#[doc = "            \"delegate_nonce\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"ak_nonce\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"delegate_nonce\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"DelegateAction nonce is larger than the upper bound given by the block height\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DelegateActionNonceTooLarge\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DelegateActionNonceTooLarge\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"delegate_nonce\","]
#[doc = "            \"upper_bound\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"delegate_nonce\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"upper_bound\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"GlobalContractDoesNotExist\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"GlobalContractDoesNotExist\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"identifier\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"identifier\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/GlobalContractIdentifier\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum ActionErrorKind {
    #[doc = "Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage"]
    AccountAlreadyExists { account_id: AccountId },
    #[doc = "Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)"]
    AccountDoesNotExist { account_id: AccountId },
    #[doc = "A top-level account ID can only be created by registrar."]
    CreateAccountOnlyByRegistrar {
        account_id: AccountId,
        predecessor_id: AccountId,
        registrar_account_id: AccountId,
    },
    #[doc = "A newly created account must be under a namespace of the creator account"]
    CreateAccountNotAllowed {
        account_id: AccountId,
        predecessor_id: AccountId,
    },
    #[doc = "Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver\nor the first TX action is a `CreateAccount` action"]
    ActorNoPermission {
        account_id: AccountId,
        actor_id: AccountId,
    },
    #[doc = "Account tries to remove an access key that doesn't exist"]
    DeleteKeyDoesNotExist {
        account_id: AccountId,
        public_key: PublicKey,
    },
    #[doc = "The public key is already used for an existing access key"]
    AddKeyAlreadyExists {
        account_id: AccountId,
        public_key: PublicKey,
    },
    #[doc = "Account is staking and can not be deleted"]
    DeleteAccountStaking { account_id: AccountId },
    #[doc = "ActionReceipt can't be completed, because the remaining balance will not be enough to cover storage."]
    LackBalanceForState {
        #[doc = "An account which needs balance"]
        account_id: AccountId,
        #[doc = "Balance required to complete an action."]
        amount: ::std::string::String,
    },
    #[doc = "Account is not yet staked, but tries to unstake"]
    TriesToUnstake { account_id: AccountId },
    #[doc = "The account doesn't have enough balance to increase the stake."]
    TriesToStake {
        account_id: AccountId,
        balance: ::std::string::String,
        locked: ::std::string::String,
        stake: ::std::string::String,
    },
    InsufficientStake {
        account_id: AccountId,
        minimum_stake: ::std::string::String,
        stake: ::std::string::String,
    },
    #[doc = "An error occurred during a `FunctionCall` Action, parameter is debug message."]
    FunctionCallError(FunctionCallError),
    #[doc = "Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails\nreceipt validation."]
    NewReceiptValidationError(ReceiptValidationError),
    #[doc = "Error occurs when a `CreateAccount` action is called on a NEAR-implicit or ETH-implicit account.\nSee NEAR-implicit account creation NEP: <https://github.com/nearprotocol/NEPs/pull/71>.\nAlso, see ETH-implicit account creation NEP: <https://github.com/near/NEPs/issues/518>.\n\nTODO(#8598): This error is named very poorly. A better name would be\n`OnlyNamedAccountCreationAllowed`."]
    OnlyImplicitAccountCreationAllowed { account_id: AccountId },
    #[doc = "Delete account whose state is large is temporarily banned."]
    DeleteAccountWithLargeState { account_id: AccountId },
    #[doc = "Signature does not match the provided actions and given signer public key."]
    DelegateActionInvalidSignature,
    #[doc = "Receiver of the transaction doesn't match Sender of the delegate action"]
    DelegateActionSenderDoesNotMatchTxReceiver {
        receiver_id: AccountId,
        sender_id: AccountId,
    },
    #[doc = "Delegate action has expired. `max_block_height` is less than actual block height."]
    DelegateActionExpired,
    #[doc = "The given public key doesn't exist for Sender account"]
    DelegateActionAccessKeyError(InvalidAccessKeyError),
    #[doc = "DelegateAction nonce must be greater sender[public_key].nonce"]
    DelegateActionInvalidNonce { ak_nonce: u64, delegate_nonce: u64 },
    #[doc = "DelegateAction nonce is larger than the upper bound given by the block height"]
    DelegateActionNonceTooLarge {
        delegate_nonce: u64,
        upper_bound: u64,
    },
    GlobalContractDoesNotExist {
        identifier: GlobalContractIdentifier,
    },
}
impl ::std::convert::From<&Self> for ActionErrorKind {
    fn from(value: &ActionErrorKind) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<FunctionCallError> for ActionErrorKind {
    fn from(value: FunctionCallError) -> Self {
        Self::FunctionCallError(value)
    }
}
impl ::std::convert::From<ReceiptValidationError> for ActionErrorKind {
    fn from(value: ReceiptValidationError) -> Self {
        Self::NewReceiptValidationError(value)
    }
}
impl ::std::convert::From<InvalidAccessKeyError> for ActionErrorKind {
    fn from(value: InvalidAccessKeyError) -> Self {
        Self::DelegateActionAccessKeyError(value)
    }
}
#[doc = "`ActionView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"CreateAccount\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DeployContract\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DeployContract\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"code\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"code\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"bytes\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"FunctionCall\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"FunctionCall\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"args\","]
#[doc = "            \"deposit\","]
#[doc = "            \"gas\","]
#[doc = "            \"method_name\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"args\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/FunctionArgs\""]
#[doc = "            },"]
#[doc = "            \"deposit\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"gas\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"method_name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Transfer\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Transfer\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"deposit\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"deposit\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Stake\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Stake\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"public_key\","]
#[doc = "            \"stake\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            },"]
#[doc = "            \"stake\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"AddKey\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"AddKey\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"access_key\","]
#[doc = "            \"public_key\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"access_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccessKeyView\""]
#[doc = "            },"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DeleteKey\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DeleteKey\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"public_key\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DeleteAccount\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DeleteAccount\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"beneficiary_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"beneficiary_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Delegate\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Delegate\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"delegate_action\","]
#[doc = "            \"signature\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"delegate_action\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/DelegateAction\""]
#[doc = "            },"]
#[doc = "            \"signature\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Signature\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DeployGlobalContract\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DeployGlobalContract\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"code\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"code\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"bytes\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"DeployGlobalContractByAccountId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"DeployGlobalContractByAccountId\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"code\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"code\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"format\": \"bytes\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"UseGlobalContract\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"UseGlobalContract\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"code_hash\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"code_hash\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"UseGlobalContractByAccountId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"UseGlobalContractByAccountId\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum ActionView {
    CreateAccount,
    DeployContract {
        code: ::std::string::String,
    },
    FunctionCall {
        args: FunctionArgs,
        deposit: ::std::string::String,
        gas: u64,
        method_name: ::std::string::String,
    },
    Transfer {
        deposit: ::std::string::String,
    },
    Stake {
        public_key: PublicKey,
        stake: ::std::string::String,
    },
    AddKey {
        access_key: AccessKeyView,
        public_key: PublicKey,
    },
    DeleteKey {
        public_key: PublicKey,
    },
    DeleteAccount {
        beneficiary_id: AccountId,
    },
    Delegate {
        delegate_action: DelegateAction,
        signature: Signature,
    },
    DeployGlobalContract {
        code: ::std::string::String,
    },
    DeployGlobalContractByAccountId {
        code: ::std::string::String,
    },
    UseGlobalContract {
        code_hash: CryptoHash,
    },
    UseGlobalContractByAccountId {
        account_id: AccountId,
    },
}
impl ::std::convert::From<&Self> for ActionView {
    fn from(value: &ActionView) -> Self {
        value.clone()
    }
}
#[doc = "Describes the error for validating a list of actions."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes the error for validating a list of actions.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"The delete action must be a final action in transaction\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"DeleteActionMustBeFinal\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The total prepaid gas (for all given actions) exceeded the limit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"TotalPrepaidGasExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"TotalPrepaidGasExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"limit\","]
#[doc = "            \"total_prepaid_gas\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"total_prepaid_gas\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The number of actions exceeded the given limit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"TotalNumberOfActionsExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"TotalNumberOfActionsExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"limit\","]
#[doc = "            \"total_number_of_actions\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"total_number_of_actions\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The total number of bytes of the method names exceeded the limit in a Add Key action.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"AddKeyMethodNamesNumberOfBytesExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"AddKeyMethodNamesNumberOfBytesExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"limit\","]
#[doc = "            \"total_number_of_bytes\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"total_number_of_bytes\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The length of some method name exceeded the limit in a Add Key action.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"AddKeyMethodNameLengthExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"AddKeyMethodNameLengthExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"length\","]
#[doc = "            \"limit\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"length\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Integer overflow during a compute.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"IntegerOverflow\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Invalid account ID.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidAccountId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidAccountId\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The size of the contract code exceeded the limit in a DeployContract action.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ContractSizeExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ContractSizeExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"limit\","]
#[doc = "            \"size\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"size\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The length of the method name exceeded the limit in a Function Call action.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"FunctionCallMethodNameLengthExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"FunctionCallMethodNameLengthExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"length\","]
#[doc = "            \"limit\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"length\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The length of the arguments exceeded the limit in a Function Call action.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"FunctionCallArgumentsLengthExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"FunctionCallArgumentsLengthExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"length\","]
#[doc = "            \"limit\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"length\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"An attempt to stake with a public key that is not convertible to ristretto.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"UnsuitableStakingKey\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"UnsuitableStakingKey\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"public_key\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The attached amount of gas in a FunctionCall action has to be a positive number.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"FunctionCallZeroAttachedGas\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"There should be the only one DelegateAction\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"DelegateActionMustBeOnlyOne\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The transaction includes a feature that the current protocol version\\ndoes not support.\\n\\nNote: we stringify the protocol feature name instead of using\\n`ProtocolFeature` here because we don't want to leak the internals of\\nthat type into observable borsh serialization.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"UnsupportedProtocolFeature\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"UnsupportedProtocolFeature\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"protocol_feature\","]
#[doc = "            \"version\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"protocol_feature\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"version\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint32\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum ActionsValidationError {
    #[doc = "The delete action must be a final action in transaction"]
    DeleteActionMustBeFinal,
    #[doc = "The total prepaid gas (for all given actions) exceeded the limit."]
    TotalPrepaidGasExceeded { limit: u64, total_prepaid_gas: u64 },
    #[doc = "The number of actions exceeded the given limit."]
    TotalNumberOfActionsExceeded {
        limit: u64,
        total_number_of_actions: u64,
    },
    #[doc = "The total number of bytes of the method names exceeded the limit in a Add Key action."]
    AddKeyMethodNamesNumberOfBytesExceeded {
        limit: u64,
        total_number_of_bytes: u64,
    },
    #[doc = "The length of some method name exceeded the limit in a Add Key action."]
    AddKeyMethodNameLengthExceeded { length: u64, limit: u64 },
    #[doc = "Integer overflow during a compute."]
    IntegerOverflow,
    #[doc = "Invalid account ID."]
    InvalidAccountId { account_id: ::std::string::String },
    #[doc = "The size of the contract code exceeded the limit in a DeployContract action."]
    ContractSizeExceeded { limit: u64, size: u64 },
    #[doc = "The length of the method name exceeded the limit in a Function Call action."]
    FunctionCallMethodNameLengthExceeded { length: u64, limit: u64 },
    #[doc = "The length of the arguments exceeded the limit in a Function Call action."]
    FunctionCallArgumentsLengthExceeded { length: u64, limit: u64 },
    #[doc = "An attempt to stake with a public key that is not convertible to ristretto."]
    UnsuitableStakingKey { public_key: PublicKey },
    #[doc = "The attached amount of gas in a FunctionCall action has to be a positive number."]
    FunctionCallZeroAttachedGas,
    #[doc = "There should be the only one DelegateAction"]
    DelegateActionMustBeOnlyOne,
    #[doc = "The transaction includes a feature that the current protocol version\ndoes not support.\n\nNote: we stringify the protocol feature name instead of using\n`ProtocolFeature` here because we don't want to leak the internals of\nthat type into observable borsh serialization."]
    UnsupportedProtocolFeature {
        protocol_feature: ::std::string::String,
        version: u32,
    },
}
impl ::std::convert::From<&Self> for ActionsValidationError {
    fn from(value: &ActionsValidationError) -> Self {
        value.clone()
    }
}
#[doc = "An action that adds key with public key associated"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An action that adds key with public key associated\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"access_key\","]
#[doc = "    \"public_key\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_key\": {"]
#[doc = "      \"description\": \"An access key with the permission\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccessKey\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"description\": \"A public key which will be associated with an access_key\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AddKeyAction {
    #[doc = "An access key with the permission"]
    pub access_key: AccessKey,
    #[doc = "A public key which will be associated with an access_key"]
    pub public_key: PublicKey,
}
impl ::std::convert::From<&AddKeyAction> for AddKeyAction {
    fn from(value: &AddKeyAction) -> Self {
        value.clone()
    }
}
#[doc = "`AllAccessKeyChangesByBlockIdChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"all_access_key_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AllAccessKeyChangesByBlockIdChangesType {
    #[serde(rename = "all_access_key_changes")]
    AllAccessKeyChanges,
}
impl ::std::convert::From<&Self> for AllAccessKeyChangesByBlockIdChangesType {
    fn from(value: &AllAccessKeyChangesByBlockIdChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AllAccessKeyChangesByBlockIdChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AllAccessKeyChanges => write!(f, "all_access_key_changes"),
        }
    }
}
impl ::std::str::FromStr for AllAccessKeyChangesByBlockIdChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all_access_key_changes" => Ok(Self::AllAccessKeyChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AllAccessKeyChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AllAccessKeyChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AllAccessKeyChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AllAccessKeyChangesByFinalityChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"all_access_key_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AllAccessKeyChangesByFinalityChangesType {
    #[serde(rename = "all_access_key_changes")]
    AllAccessKeyChanges,
}
impl ::std::convert::From<&Self> for AllAccessKeyChangesByFinalityChangesType {
    fn from(value: &AllAccessKeyChangesByFinalityChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AllAccessKeyChangesByFinalityChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AllAccessKeyChanges => write!(f, "all_access_key_changes"),
        }
    }
}
impl ::std::str::FromStr for AllAccessKeyChangesByFinalityChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all_access_key_changes" => Ok(Self::AllAccessKeyChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AllAccessKeyChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AllAccessKeyChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AllAccessKeyChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AllAccessKeyChangesBySyncCheckpointChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"all_access_key_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AllAccessKeyChangesBySyncCheckpointChangesType {
    #[serde(rename = "all_access_key_changes")]
    AllAccessKeyChanges,
}
impl ::std::convert::From<&Self> for AllAccessKeyChangesBySyncCheckpointChangesType {
    fn from(value: &AllAccessKeyChangesBySyncCheckpointChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AllAccessKeyChangesBySyncCheckpointChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AllAccessKeyChanges => write!(f, "all_access_key_changes"),
        }
    }
}
impl ::std::str::FromStr for AllAccessKeyChangesBySyncCheckpointChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all_access_key_changes" => Ok(Self::AllAccessKeyChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AllAccessKeyChangesBySyncCheckpointChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for AllAccessKeyChangesBySyncCheckpointChangesType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for AllAccessKeyChangesBySyncCheckpointChangesType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AllGasKeyChangesByBlockIdChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"all_gas_key_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AllGasKeyChangesByBlockIdChangesType {
    #[serde(rename = "all_gas_key_changes")]
    AllGasKeyChanges,
}
impl ::std::convert::From<&Self> for AllGasKeyChangesByBlockIdChangesType {
    fn from(value: &AllGasKeyChangesByBlockIdChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AllGasKeyChangesByBlockIdChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AllGasKeyChanges => write!(f, "all_gas_key_changes"),
        }
    }
}
impl ::std::str::FromStr for AllGasKeyChangesByBlockIdChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all_gas_key_changes" => Ok(Self::AllGasKeyChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AllGasKeyChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AllGasKeyChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AllGasKeyChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AllGasKeyChangesByFinalityChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"all_gas_key_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AllGasKeyChangesByFinalityChangesType {
    #[serde(rename = "all_gas_key_changes")]
    AllGasKeyChanges,
}
impl ::std::convert::From<&Self> for AllGasKeyChangesByFinalityChangesType {
    fn from(value: &AllGasKeyChangesByFinalityChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AllGasKeyChangesByFinalityChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AllGasKeyChanges => write!(f, "all_gas_key_changes"),
        }
    }
}
impl ::std::str::FromStr for AllGasKeyChangesByFinalityChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all_gas_key_changes" => Ok(Self::AllGasKeyChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AllGasKeyChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for AllGasKeyChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for AllGasKeyChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`AllGasKeyChangesBySyncCheckpointChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"all_gas_key_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum AllGasKeyChangesBySyncCheckpointChangesType {
    #[serde(rename = "all_gas_key_changes")]
    AllGasKeyChanges,
}
impl ::std::convert::From<&Self> for AllGasKeyChangesBySyncCheckpointChangesType {
    fn from(value: &AllGasKeyChangesBySyncCheckpointChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for AllGasKeyChangesBySyncCheckpointChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AllGasKeyChanges => write!(f, "all_gas_key_changes"),
        }
    }
}
impl ::std::str::FromStr for AllGasKeyChangesBySyncCheckpointChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "all_gas_key_changes" => Ok(Self::AllGasKeyChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for AllGasKeyChangesBySyncCheckpointChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for AllGasKeyChangesBySyncCheckpointChangesType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for AllGasKeyChangesBySyncCheckpointChangesType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`BandwidthRequest` describes the size of receipts that a shard would like to send to another shard.\nWhen a shard wants to send a lot of receipts to another shard, it needs to create a request and wait\nfor a bandwidth grant from the bandwidth scheduler."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"`BandwidthRequest` describes the size of receipts that a shard would like to send to another shard.\\nWhen a shard wants to send a lot of receipts to another shard, it needs to create a request and wait\\nfor a bandwidth grant from the bandwidth scheduler.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"requested_values_bitmap\","]
#[doc = "    \"to_shard\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"requested_values_bitmap\": {"]
#[doc = "      \"description\": \"Bitmap which describes what values of bandwidth are requested.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/BandwidthRequestBitmap\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"to_shard\": {"]
#[doc = "      \"description\": \"Requesting bandwidth to this shard.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint16\","]
#[doc = "      \"maximum\": 65535.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BandwidthRequest {
    #[doc = "Bitmap which describes what values of bandwidth are requested."]
    pub requested_values_bitmap: BandwidthRequestBitmap,
    #[doc = "Requesting bandwidth to this shard."]
    pub to_shard: u16,
}
impl ::std::convert::From<&BandwidthRequest> for BandwidthRequest {
    fn from(value: &BandwidthRequest) -> Self {
        value.clone()
    }
}
#[doc = "Bitmap which describes which values from the predefined list are being requested.\nThe nth bit is set to 1 when the nth value from the list is being requested."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Bitmap which describes which values from the predefined list are being requested.\\nThe nth bit is set to 1 when the nth value from the list is being requested.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"data\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"data\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint8\","]
#[doc = "        \"maximum\": 255.0,"]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 5,"]
#[doc = "      \"minItems\": 5"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BandwidthRequestBitmap {
    pub data: [u8; 5usize],
}
impl ::std::convert::From<&BandwidthRequestBitmap> for BandwidthRequestBitmap {
    fn from(value: &BandwidthRequestBitmap) -> Self {
        value.clone()
    }
}
#[doc = "A list of shard's bandwidth requests.\nDescribes how much the shard would like to send to other shards."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A list of shard's bandwidth requests.\\nDescribes how much the shard would like to send to other shards.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"V1\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"V1\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/BandwidthRequestsV1\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum BandwidthRequests {
    V1(BandwidthRequestsV1),
}
impl ::std::convert::From<&Self> for BandwidthRequests {
    fn from(value: &BandwidthRequests) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BandwidthRequestsV1> for BandwidthRequests {
    fn from(value: BandwidthRequestsV1) -> Self {
        Self::V1(value)
    }
}
#[doc = "Version 1 for list of [`BandwidthRequest`]s."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Version 1 for list of [`BandwidthRequest`]s.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"requests\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"requests\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/BandwidthRequest\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BandwidthRequestsV1 {
    pub requests: ::std::vec::Vec<BandwidthRequest>,
}
impl ::std::convert::From<&BandwidthRequestsV1> for BandwidthRequestsV1 {
    fn from(value: &BandwidthRequestsV1) -> Self {
        value.clone()
    }
}
#[doc = "A part of a state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A part of a state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"block_merkle_root\","]
#[doc = "    \"epoch_id\","]
#[doc = "    \"height\","]
#[doc = "    \"next_bp_hash\","]
#[doc = "    \"next_epoch_id\","]
#[doc = "    \"outcome_root\","]
#[doc = "    \"prev_state_root\","]
#[doc = "    \"timestamp\","]
#[doc = "    \"timestamp_nanosec\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"block_merkle_root\": {"]
#[doc = "      \"description\": \"The merkle root of all the block hashes\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"epoch_id\": {"]
#[doc = "      \"description\": \"The epoch to which the block that is the current known head belongs\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"height\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"next_bp_hash\": {"]
#[doc = "      \"description\": \"The hash of the block producers set for the next epoch\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"next_epoch_id\": {"]
#[doc = "      \"description\": \"The epoch that will follow the current epoch\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"outcome_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"prev_state_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"timestamp\": {"]
#[doc = "      \"description\": \"Legacy json number. Should not be used.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"timestamp_nanosec\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BlockHeaderInnerLiteView {
    #[doc = "The merkle root of all the block hashes"]
    pub block_merkle_root: CryptoHash,
    #[doc = "The epoch to which the block that is the current known head belongs"]
    pub epoch_id: CryptoHash,
    pub height: u64,
    #[doc = "The hash of the block producers set for the next epoch"]
    pub next_bp_hash: CryptoHash,
    #[doc = "The epoch that will follow the current epoch"]
    pub next_epoch_id: CryptoHash,
    pub outcome_root: CryptoHash,
    pub prev_state_root: CryptoHash,
    #[doc = "Legacy json number. Should not be used."]
    pub timestamp: u64,
    pub timestamp_nanosec: ::std::string::String,
}
impl ::std::convert::From<&BlockHeaderInnerLiteView> for BlockHeaderInnerLiteView {
    fn from(value: &BlockHeaderInnerLiteView) -> Self {
        value.clone()
    }
}
#[doc = "Contains main info about the block."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Contains main info about the block.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"approvals\","]
#[doc = "    \"block_merkle_root\","]
#[doc = "    \"challenges_result\","]
#[doc = "    \"challenges_root\","]
#[doc = "    \"chunk_headers_root\","]
#[doc = "    \"chunk_mask\","]
#[doc = "    \"chunk_receipts_root\","]
#[doc = "    \"chunk_tx_root\","]
#[doc = "    \"chunks_included\","]
#[doc = "    \"epoch_id\","]
#[doc = "    \"gas_price\","]
#[doc = "    \"hash\","]
#[doc = "    \"height\","]
#[doc = "    \"last_ds_final_block\","]
#[doc = "    \"last_final_block\","]
#[doc = "    \"latest_protocol_version\","]
#[doc = "    \"next_bp_hash\","]
#[doc = "    \"next_epoch_id\","]
#[doc = "    \"outcome_root\","]
#[doc = "    \"prev_hash\","]
#[doc = "    \"prev_state_root\","]
#[doc = "    \"random_value\","]
#[doc = "    \"rent_paid\","]
#[doc = "    \"signature\","]
#[doc = "    \"timestamp\","]
#[doc = "    \"timestamp_nanosec\","]
#[doc = "    \"total_supply\","]
#[doc = "    \"validator_proposals\","]
#[doc = "    \"validator_reward\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"approvals\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/components/schemas/Signature\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"block_body_hash\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"block_merkle_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"block_ordinal\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"challenges_result\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/SlashedValidator\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"challenges_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"chunk_endorsements\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"array\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"array\","]
#[doc = "        \"items\": {"]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"format\": \"uint8\","]
#[doc = "          \"maximum\": 255.0,"]
#[doc = "          \"minimum\": 0.0"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"chunk_headers_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"chunk_mask\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"boolean\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"chunk_receipts_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"chunk_tx_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"chunks_included\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"epoch_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"epoch_sync_data_hash\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"gas_price\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"height\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"last_ds_final_block\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"last_final_block\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"latest_protocol_version\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"next_bp_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"next_epoch_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"outcome_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"prev_hash\": {"]
#[doc = "      \"description\": \"The hash of the previous Block\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"prev_height\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"prev_state_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"random_value\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"rent_paid\": {"]
#[doc = "      \"description\": \"TODO(2271): deprecated.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"signature\": {"]
#[doc = "      \"description\": \"Signature of the block producer.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Signature\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"timestamp\": {"]
#[doc = "      \"description\": \"Legacy json number. Should not be used.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"timestamp_nanosec\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"total_supply\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"validator_proposals\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ValidatorStakeView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"validator_reward\": {"]
#[doc = "      \"description\": \"TODO(2271): deprecated.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BlockHeaderView {
    pub approvals: ::std::vec::Vec<::std::option::Option<Signature>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub block_body_hash: ::std::option::Option<CryptoHash>,
    pub block_merkle_root: CryptoHash,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub block_ordinal: ::std::option::Option<u64>,
    pub challenges_result: ::std::vec::Vec<SlashedValidator>,
    pub challenges_root: CryptoHash,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub chunk_endorsements: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<u8>>>,
    pub chunk_headers_root: CryptoHash,
    pub chunk_mask: ::std::vec::Vec<bool>,
    pub chunk_receipts_root: CryptoHash,
    pub chunk_tx_root: CryptoHash,
    pub chunks_included: u64,
    pub epoch_id: CryptoHash,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub epoch_sync_data_hash: ::std::option::Option<CryptoHash>,
    pub gas_price: ::std::string::String,
    pub hash: CryptoHash,
    pub height: u64,
    pub last_ds_final_block: CryptoHash,
    pub last_final_block: CryptoHash,
    pub latest_protocol_version: u32,
    pub next_bp_hash: CryptoHash,
    pub next_epoch_id: CryptoHash,
    pub outcome_root: CryptoHash,
    #[doc = "The hash of the previous Block"]
    pub prev_hash: CryptoHash,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub prev_height: ::std::option::Option<u64>,
    pub prev_state_root: CryptoHash,
    pub random_value: CryptoHash,
    #[doc = "TODO(2271): deprecated."]
    pub rent_paid: ::std::string::String,
    #[doc = "Signature of the block producer."]
    pub signature: Signature,
    #[doc = "Legacy json number. Should not be used."]
    pub timestamp: u64,
    pub timestamp_nanosec: ::std::string::String,
    pub total_supply: ::std::string::String,
    pub validator_proposals: ::std::vec::Vec<ValidatorStakeView>,
    #[doc = "TODO(2271): deprecated."]
    pub validator_reward: ::std::string::String,
}
impl ::std::convert::From<&BlockHeaderView> for BlockHeaderView {
    fn from(value: &BlockHeaderView) -> Self {
        value.clone()
    }
}
#[doc = "`BlockId`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"block_height\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BlockId {
    BlockHeight(u64),
    CryptoHash(CryptoHash),
}
impl ::std::convert::From<&Self> for BlockId {
    fn from(value: &BlockId) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for BlockId {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::BlockHeight(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::CryptoHash(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for BlockId {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for BlockId {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for BlockId {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for BlockId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::BlockHeight(x) => x.fmt(f),
            Self::CryptoHash(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<u64> for BlockId {
    fn from(value: u64) -> Self {
        Self::BlockHeight(value)
    }
}
impl ::std::convert::From<CryptoHash> for BlockId {
    fn from(value: CryptoHash) -> Self {
        Self::CryptoHash(value)
    }
}
#[doc = "Height and hash of a block"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Height and hash of a block\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"hash\","]
#[doc = "    \"height\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"height\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct BlockStatusView {
    pub hash: CryptoHash,
    pub height: u64,
}
impl ::std::convert::From<&BlockStatusView> for BlockStatusView {
    fn from(value: &BlockStatusView) -> Self {
        value.clone()
    }
}
#[doc = "`CallFunctionByBlockIdRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"call_function\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CallFunctionByBlockIdRequestType {
    #[serde(rename = "call_function")]
    CallFunction,
}
impl ::std::convert::From<&Self> for CallFunctionByBlockIdRequestType {
    fn from(value: &CallFunctionByBlockIdRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CallFunctionByBlockIdRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::CallFunction => write!(f, "call_function"),
        }
    }
}
impl ::std::str::FromStr for CallFunctionByBlockIdRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "call_function" => Ok(Self::CallFunction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CallFunctionByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CallFunctionByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CallFunctionByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CallFunctionByFinalityRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"call_function\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CallFunctionByFinalityRequestType {
    #[serde(rename = "call_function")]
    CallFunction,
}
impl ::std::convert::From<&Self> for CallFunctionByFinalityRequestType {
    fn from(value: &CallFunctionByFinalityRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CallFunctionByFinalityRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::CallFunction => write!(f, "call_function"),
        }
    }
}
impl ::std::str::FromStr for CallFunctionByFinalityRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "call_function" => Ok(Self::CallFunction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CallFunctionByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CallFunctionByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CallFunctionByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CallFunctionBySyncCheckpointRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"call_function\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum CallFunctionBySyncCheckpointRequestType {
    #[serde(rename = "call_function")]
    CallFunction,
}
impl ::std::convert::From<&Self> for CallFunctionBySyncCheckpointRequestType {
    fn from(value: &CallFunctionBySyncCheckpointRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for CallFunctionBySyncCheckpointRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::CallFunction => write!(f, "call_function"),
        }
    }
}
impl ::std::str::FromStr for CallFunctionBySyncCheckpointRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "call_function" => Ok(Self::CallFunction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for CallFunctionBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for CallFunctionBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CallFunctionBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`CallResult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"logs\","]
#[doc = "    \"result\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"logs\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"result\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint8\","]
#[doc = "        \"maximum\": 255.0,"]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CallResult {
    pub logs: ::std::vec::Vec<::std::string::String>,
    pub result: ::std::vec::Vec<u8>,
}
impl ::std::convert::From<&CallResult> for CallResult {
    fn from(value: &CallResult) -> Self {
        value.clone()
    }
}
#[doc = "`CatchupStatusView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"blocks_to_catchup\","]
#[doc = "    \"shard_sync_status\","]
#[doc = "    \"sync_block_hash\","]
#[doc = "    \"sync_block_height\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"blocks_to_catchup\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/BlockStatusView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"shard_sync_status\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    \"sync_block_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"sync_block_height\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CatchupStatusView {
    pub blocks_to_catchup: ::std::vec::Vec<BlockStatusView>,
    pub shard_sync_status: CatchupStatusViewShardSyncStatus,
    pub sync_block_hash: CryptoHash,
    pub sync_block_height: u64,
}
impl ::std::convert::From<&CatchupStatusView> for CatchupStatusView {
    fn from(value: &CatchupStatusView) -> Self {
        value.clone()
    }
}
#[doc = "`CatchupStatusViewShardSyncStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(deny_unknown_fields)]
pub struct CatchupStatusViewShardSyncStatus {}
impl ::std::convert::From<&CatchupStatusViewShardSyncStatus> for CatchupStatusViewShardSyncStatus {
    fn from(value: &CatchupStatusViewShardSyncStatus) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for CatchupStatusViewShardSyncStatus {
    fn default() -> Self {
        Self {}
    }
}
#[doc = "Config for the Chunk Distribution Network feature.\nThis allows nodes to push and pull chunks from a central stream.\nThe two benefits of this approach are: (1) less request/response traffic\non the peer-to-peer network and (2) lower latency for RPC nodes indexing the chain."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Config for the Chunk Distribution Network feature.\\nThis allows nodes to push and pull chunks from a central stream.\\nThe two benefits of this approach are: (1) less request/response traffic\\non the peer-to-peer network and (2) lower latency for RPC nodes indexing the chain.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"enabled\","]
#[doc = "    \"uris\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"enabled\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"uris\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/ChunkDistributionUris\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ChunkDistributionNetworkConfig {
    pub enabled: bool,
    pub uris: ChunkDistributionUris,
}
impl ::std::convert::From<&ChunkDistributionNetworkConfig> for ChunkDistributionNetworkConfig {
    fn from(value: &ChunkDistributionNetworkConfig) -> Self {
        value.clone()
    }
}
#[doc = "URIs for the Chunk Distribution Network feature."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"URIs for the Chunk Distribution Network feature.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"get\","]
#[doc = "    \"set\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"get\": {"]
#[doc = "      \"description\": \"URI for pulling chunks from the stream.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"set\": {"]
#[doc = "      \"description\": \"URI for publishing chunks to the stream.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ChunkDistributionUris {
    #[doc = "URI for pulling chunks from the stream."]
    pub get: ::std::string::String,
    #[doc = "URI for publishing chunks to the stream."]
    pub set: ::std::string::String,
}
impl ::std::convert::From<&ChunkDistributionUris> for ChunkDistributionUris {
    fn from(value: &ChunkDistributionUris) -> Self {
        value.clone()
    }
}
#[doc = "`ChunkHeaderView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"balance_burnt\","]
#[doc = "    \"chunk_hash\","]
#[doc = "    \"encoded_length\","]
#[doc = "    \"encoded_merkle_root\","]
#[doc = "    \"gas_limit\","]
#[doc = "    \"gas_used\","]
#[doc = "    \"height_created\","]
#[doc = "    \"height_included\","]
#[doc = "    \"outcome_root\","]
#[doc = "    \"outgoing_receipts_root\","]
#[doc = "    \"prev_block_hash\","]
#[doc = "    \"prev_state_root\","]
#[doc = "    \"rent_paid\","]
#[doc = "    \"shard_id\","]
#[doc = "    \"signature\","]
#[doc = "    \"tx_root\","]
#[doc = "    \"validator_proposals\","]
#[doc = "    \"validator_reward\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"balance_burnt\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"bandwidth_requests\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/BandwidthRequests\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"chunk_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"congestion_info\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CongestionInfoView\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"encoded_length\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"encoded_merkle_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"gas_limit\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"gas_used\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"height_created\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"height_included\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"outcome_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"outgoing_receipts_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"prev_block_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"prev_state_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"rent_paid\": {"]
#[doc = "      \"description\": \"TODO(2271): deprecated.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"shard_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "    },"]
#[doc = "    \"signature\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/Signature\""]
#[doc = "    },"]
#[doc = "    \"tx_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"validator_proposals\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ValidatorStakeView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"validator_reward\": {"]
#[doc = "      \"description\": \"TODO(2271): deprecated.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ChunkHeaderView {
    pub balance_burnt: ::std::string::String,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub bandwidth_requests: ::std::option::Option<BandwidthRequests>,
    pub chunk_hash: CryptoHash,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub congestion_info: ::std::option::Option<CongestionInfoView>,
    pub encoded_length: u64,
    pub encoded_merkle_root: CryptoHash,
    pub gas_limit: u64,
    pub gas_used: u64,
    pub height_created: u64,
    pub height_included: u64,
    pub outcome_root: CryptoHash,
    pub outgoing_receipts_root: CryptoHash,
    pub prev_block_hash: CryptoHash,
    pub prev_state_root: CryptoHash,
    #[doc = "TODO(2271): deprecated."]
    pub rent_paid: ::std::string::String,
    pub shard_id: ShardId,
    pub signature: Signature,
    pub tx_root: CryptoHash,
    pub validator_proposals: ::std::vec::Vec<ValidatorStakeView>,
    #[doc = "TODO(2271): deprecated."]
    pub validator_reward: ::std::string::String,
}
impl ::std::convert::From<&ChunkHeaderView> for ChunkHeaderView {
    fn from(value: &ChunkHeaderView) -> Self {
        value.clone()
    }
}
#[doc = "`CompilationError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"CodeDoesNotExist\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"CodeDoesNotExist\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"PrepareError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"PrepareError\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/PrepareError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"This is for defense in depth.\\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\\nbut, if it ever misses something we’ll emit this error\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"WasmerCompileError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"WasmerCompileError\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"msg\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"msg\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum CompilationError {
    CodeDoesNotExist {
        account_id: AccountId,
    },
    PrepareError(PrepareError),
    #[doc = "This is for defense in depth.\nWe expect our runtime-independent preparation code to fully catch all invalid wasms,\nbut, if it ever misses something we’ll emit this error"]
    WasmerCompileError {
        msg: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for CompilationError {
    fn from(value: &CompilationError) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<PrepareError> for CompilationError {
    fn from(value: PrepareError) -> Self {
        Self::PrepareError(value)
    }
}
#[doc = "`CongestionControlConfigView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"allowed_shard_outgoing_gas\","]
#[doc = "    \"max_congestion_incoming_gas\","]
#[doc = "    \"max_congestion_memory_consumption\","]
#[doc = "    \"max_congestion_missed_chunks\","]
#[doc = "    \"max_congestion_outgoing_gas\","]
#[doc = "    \"max_outgoing_gas\","]
#[doc = "    \"max_tx_gas\","]
#[doc = "    \"min_outgoing_gas\","]
#[doc = "    \"min_tx_gas\","]
#[doc = "    \"outgoing_receipts_big_size_limit\","]
#[doc = "    \"outgoing_receipts_usual_size_limit\","]
#[doc = "    \"reject_tx_congestion_threshold\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"allowed_shard_outgoing_gas\": {"]
#[doc = "      \"description\": \"How much gas the chosen allowed shard can send to a 100% congested shard.\\n\\nSee [`CongestionControlConfig`] for more details.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_congestion_incoming_gas\": {"]
#[doc = "      \"description\": \"How much gas in delayed receipts of a shard is 100% incoming congestion.\\n\\nSee [`CongestionControlConfig`] for more details.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_congestion_memory_consumption\": {"]
#[doc = "      \"description\": \"How much memory space of all delayed and buffered receipts in a shard is\\nconsidered 100% congested.\\n\\nSee [`CongestionControlConfig`] for more details.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_congestion_missed_chunks\": {"]
#[doc = "      \"description\": \"How many missed chunks in a row in a shard is considered 100% congested.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_congestion_outgoing_gas\": {"]
#[doc = "      \"description\": \"How much gas in outgoing buffered receipts of a shard is 100% congested.\\n\\nOutgoing congestion contributes to overall congestion, which reduces how\\nmuch other shards are allowed to forward to this shard.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_outgoing_gas\": {"]
#[doc = "      \"description\": \"The maximum amount of gas attached to receipts a shard can forward to\\nanother shard per chunk.\\n\\nSee [`CongestionControlConfig`] for more details.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_tx_gas\": {"]
#[doc = "      \"description\": \"The maximum amount of gas in a chunk spent on converting new transactions to\\nreceipts.\\n\\nSee [`CongestionControlConfig`] for more details.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"min_outgoing_gas\": {"]
#[doc = "      \"description\": \"The minimum gas each shard can send to a shard that is not fully congested.\\n\\nSee [`CongestionControlConfig`] for more details.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"min_tx_gas\": {"]
#[doc = "      \"description\": \"The minimum amount of gas in a chunk spent on converting new transactions\\nto receipts, as long as the receiving shard is not congested.\\n\\nSee [`CongestionControlConfig`] for more details.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"outgoing_receipts_big_size_limit\": {"]
#[doc = "      \"description\": \"Large size limit for outgoing receipts to a shard, used when it's safe\\nto send a lot of receipts without making the state witness too large.\\nIt limits the total sum of outgoing receipts, not individual receipts.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"outgoing_receipts_usual_size_limit\": {"]
#[doc = "      \"description\": \"The standard size limit for outgoing receipts aimed at a single shard.\\nThis limit is pretty small to keep the size of source_receipt_proofs under control.\\nIt limits the total sum of outgoing receipts, not individual receipts.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"reject_tx_congestion_threshold\": {"]
#[doc = "      \"description\": \"How much congestion a shard can tolerate before it stops all shards from\\naccepting new transactions with the receiver set to the congested shard.\","]
#[doc = "      \"type\": \"number\","]
#[doc = "      \"format\": \"double\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CongestionControlConfigView {
    #[doc = "How much gas the chosen allowed shard can send to a 100% congested shard.\n\nSee [`CongestionControlConfig`] for more details."]
    pub allowed_shard_outgoing_gas: u64,
    #[doc = "How much gas in delayed receipts of a shard is 100% incoming congestion.\n\nSee [`CongestionControlConfig`] for more details."]
    pub max_congestion_incoming_gas: u64,
    #[doc = "How much memory space of all delayed and buffered receipts in a shard is\nconsidered 100% congested.\n\nSee [`CongestionControlConfig`] for more details."]
    pub max_congestion_memory_consumption: u64,
    #[doc = "How many missed chunks in a row in a shard is considered 100% congested."]
    pub max_congestion_missed_chunks: u64,
    #[doc = "How much gas in outgoing buffered receipts of a shard is 100% congested.\n\nOutgoing congestion contributes to overall congestion, which reduces how\nmuch other shards are allowed to forward to this shard."]
    pub max_congestion_outgoing_gas: u64,
    #[doc = "The maximum amount of gas attached to receipts a shard can forward to\nanother shard per chunk.\n\nSee [`CongestionControlConfig`] for more details."]
    pub max_outgoing_gas: u64,
    #[doc = "The maximum amount of gas in a chunk spent on converting new transactions to\nreceipts.\n\nSee [`CongestionControlConfig`] for more details."]
    pub max_tx_gas: u64,
    #[doc = "The minimum gas each shard can send to a shard that is not fully congested.\n\nSee [`CongestionControlConfig`] for more details."]
    pub min_outgoing_gas: u64,
    #[doc = "The minimum amount of gas in a chunk spent on converting new transactions\nto receipts, as long as the receiving shard is not congested.\n\nSee [`CongestionControlConfig`] for more details."]
    pub min_tx_gas: u64,
    #[doc = "Large size limit for outgoing receipts to a shard, used when it's safe\nto send a lot of receipts without making the state witness too large.\nIt limits the total sum of outgoing receipts, not individual receipts."]
    pub outgoing_receipts_big_size_limit: u64,
    #[doc = "The standard size limit for outgoing receipts aimed at a single shard.\nThis limit is pretty small to keep the size of source_receipt_proofs under control.\nIt limits the total sum of outgoing receipts, not individual receipts."]
    pub outgoing_receipts_usual_size_limit: u64,
    pub reject_tx_congestion_threshold: f64,
}
impl ::std::convert::From<&CongestionControlConfigView> for CongestionControlConfigView {
    fn from(value: &CongestionControlConfigView) -> Self {
        value.clone()
    }
}
#[doc = "`CongestionInfoView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"allowed_shard\","]
#[doc = "    \"buffered_receipts_gas\","]
#[doc = "    \"delayed_receipts_gas\","]
#[doc = "    \"receipt_bytes\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"allowed_shard\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint16\","]
#[doc = "      \"maximum\": 65535.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"buffered_receipts_gas\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"delayed_receipts_gas\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"receipt_bytes\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CongestionInfoView {
    pub allowed_shard: u16,
    pub buffered_receipts_gas: ::std::string::String,
    pub delayed_receipts_gas: ::std::string::String,
    pub receipt_bytes: u64,
}
impl ::std::convert::From<&CongestionInfoView> for CongestionInfoView {
    fn from(value: &CongestionInfoView) -> Self {
        value.clone()
    }
}
#[doc = "`ContractCodeChangesByBlockIdChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"contract_code_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ContractCodeChangesByBlockIdChangesType {
    #[serde(rename = "contract_code_changes")]
    ContractCodeChanges,
}
impl ::std::convert::From<&Self> for ContractCodeChangesByBlockIdChangesType {
    fn from(value: &ContractCodeChangesByBlockIdChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ContractCodeChangesByBlockIdChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ContractCodeChanges => write!(f, "contract_code_changes"),
        }
    }
}
impl ::std::str::FromStr for ContractCodeChangesByBlockIdChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "contract_code_changes" => Ok(Self::ContractCodeChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ContractCodeChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ContractCodeChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ContractCodeChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ContractCodeChangesByFinalityChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"contract_code_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ContractCodeChangesByFinalityChangesType {
    #[serde(rename = "contract_code_changes")]
    ContractCodeChanges,
}
impl ::std::convert::From<&Self> for ContractCodeChangesByFinalityChangesType {
    fn from(value: &ContractCodeChangesByFinalityChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ContractCodeChangesByFinalityChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ContractCodeChanges => write!(f, "contract_code_changes"),
        }
    }
}
impl ::std::str::FromStr for ContractCodeChangesByFinalityChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "contract_code_changes" => Ok(Self::ContractCodeChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ContractCodeChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ContractCodeChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ContractCodeChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ContractCodeChangesBySyncCheckpointChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"contract_code_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ContractCodeChangesBySyncCheckpointChangesType {
    #[serde(rename = "contract_code_changes")]
    ContractCodeChanges,
}
impl ::std::convert::From<&Self> for ContractCodeChangesBySyncCheckpointChangesType {
    fn from(value: &ContractCodeChangesBySyncCheckpointChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ContractCodeChangesBySyncCheckpointChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ContractCodeChanges => write!(f, "contract_code_changes"),
        }
    }
}
impl ::std::str::FromStr for ContractCodeChangesBySyncCheckpointChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "contract_code_changes" => Ok(Self::ContractCodeChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ContractCodeChangesBySyncCheckpointChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ContractCodeChangesBySyncCheckpointChangesType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ContractCodeChangesBySyncCheckpointChangesType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A view of the contract code."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A view of the contract code.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code_base64\","]
#[doc = "    \"hash\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code_base64\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ContractCodeView {
    pub code_base64: ::std::string::String,
    pub hash: CryptoHash,
}
impl ::std::convert::From<&ContractCodeView> for ContractCodeView {
    fn from(value: &ContractCodeView) -> Self {
        value.clone()
    }
}
#[doc = "`CostGasUsed`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"cost\","]
#[doc = "    \"cost_category\","]
#[doc = "    \"gas_used\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cost\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"cost_category\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"gas_used\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CostGasUsed {
    pub cost: ::std::string::String,
    pub cost_category: ::std::string::String,
    pub gas_used: ::std::string::String,
}
impl ::std::convert::From<&CostGasUsed> for CostGasUsed {
    fn from(value: &CostGasUsed) -> Self {
        value.clone()
    }
}
#[doc = "Create account action"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Create account action\","]
#[doc = "  \"type\": \"object\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct CreateAccountAction(pub ::serde_json::Map<::std::string::String, ::serde_json::Value>);
impl ::std::ops::Deref for CreateAccountAction {
    type Target = ::serde_json::Map<::std::string::String, ::serde_json::Value>;
    fn deref(&self) -> &::serde_json::Map<::std::string::String, ::serde_json::Value> {
        &self.0
    }
}
impl ::std::convert::From<CreateAccountAction>
    for ::serde_json::Map<::std::string::String, ::serde_json::Value>
{
    fn from(value: CreateAccountAction) -> Self {
        value.0
    }
}
impl ::std::convert::From<&CreateAccountAction> for CreateAccountAction {
    fn from(value: &CreateAccountAction) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>>
    for CreateAccountAction
{
    fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
        Self(value)
    }
}
#[doc = "`CryptoHash`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct CryptoHash(pub ::std::string::String);
impl ::std::ops::Deref for CryptoHash {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<CryptoHash> for ::std::string::String {
    fn from(value: CryptoHash) -> Self {
        value.0
    }
}
impl ::std::convert::From<&CryptoHash> for CryptoHash {
    fn from(value: &CryptoHash) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for CryptoHash {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for CryptoHash {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for CryptoHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`CurrentEpochValidatorInfo`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"is_slashed\","]
#[doc = "    \"num_expected_blocks\","]
#[doc = "    \"num_produced_blocks\","]
#[doc = "    \"public_key\","]
#[doc = "    \"shards\","]
#[doc = "    \"stake\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"is_slashed\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"num_expected_blocks\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_expected_chunks\": {"]
#[doc = "      \"default\": 0,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_expected_chunks_per_shard\": {"]
#[doc = "      \"description\": \"Number of chunks this validator was expected to produce in each shard.\\nEach entry in the array corresponds to the shard in the `shards_produced` array.\","]
#[doc = "      \"default\": [],"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"num_expected_endorsements\": {"]
#[doc = "      \"default\": 0,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_expected_endorsements_per_shard\": {"]
#[doc = "      \"description\": \"Number of chunks this validator was expected to validate and endorse in each shard.\\nEach entry in the array corresponds to the shard in the `shards_endorsed` array.\","]
#[doc = "      \"default\": [],"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"num_produced_blocks\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_produced_chunks\": {"]
#[doc = "      \"default\": 0,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_produced_chunks_per_shard\": {"]
#[doc = "      \"default\": [],"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"num_produced_endorsements\": {"]
#[doc = "      \"default\": 0,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_produced_endorsements_per_shard\": {"]
#[doc = "      \"default\": [],"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    },"]
#[doc = "    \"shards\": {"]
#[doc = "      \"description\": \"Shards this validator is assigned to as chunk producer in the current epoch.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"shards_endorsed\": {"]
#[doc = "      \"description\": \"Shards this validator is assigned to as chunk validator in the current epoch.\","]
#[doc = "      \"default\": [],"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"stake\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct CurrentEpochValidatorInfo {
    pub account_id: AccountId,
    pub is_slashed: bool,
    pub num_expected_blocks: u64,
    #[serde(default)]
    pub num_expected_chunks: u64,
    #[doc = "Number of chunks this validator was expected to produce in each shard.\nEach entry in the array corresponds to the shard in the `shards_produced` array."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub num_expected_chunks_per_shard: ::std::vec::Vec<u64>,
    #[serde(default)]
    pub num_expected_endorsements: u64,
    #[doc = "Number of chunks this validator was expected to validate and endorse in each shard.\nEach entry in the array corresponds to the shard in the `shards_endorsed` array."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub num_expected_endorsements_per_shard: ::std::vec::Vec<u64>,
    pub num_produced_blocks: u64,
    #[serde(default)]
    pub num_produced_chunks: u64,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub num_produced_chunks_per_shard: ::std::vec::Vec<u64>,
    #[serde(default)]
    pub num_produced_endorsements: u64,
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub num_produced_endorsements_per_shard: ::std::vec::Vec<u64>,
    pub public_key: PublicKey,
    #[doc = "Shards this validator is assigned to as chunk producer in the current epoch."]
    pub shards: ::std::vec::Vec<ShardId>,
    #[doc = "Shards this validator is assigned to as chunk validator in the current epoch."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub shards_endorsed: ::std::vec::Vec<ShardId>,
    pub stake: ::std::string::String,
}
impl ::std::convert::From<&CurrentEpochValidatorInfo> for CurrentEpochValidatorInfo {
    fn from(value: &CurrentEpochValidatorInfo) -> Self {
        value.clone()
    }
}
#[doc = "`DataChangesByBlockIdChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"data_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataChangesByBlockIdChangesType {
    #[serde(rename = "data_changes")]
    DataChanges,
}
impl ::std::convert::From<&Self> for DataChangesByBlockIdChangesType {
    fn from(value: &DataChangesByBlockIdChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataChangesByBlockIdChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::DataChanges => write!(f, "data_changes"),
        }
    }
}
impl ::std::str::FromStr for DataChangesByBlockIdChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "data_changes" => Ok(Self::DataChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataChangesByFinalityChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"data_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataChangesByFinalityChangesType {
    #[serde(rename = "data_changes")]
    DataChanges,
}
impl ::std::convert::From<&Self> for DataChangesByFinalityChangesType {
    fn from(value: &DataChangesByFinalityChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataChangesByFinalityChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::DataChanges => write!(f, "data_changes"),
        }
    }
}
impl ::std::str::FromStr for DataChangesByFinalityChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "data_changes" => Ok(Self::DataChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataChangesBySyncCheckpointChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"data_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum DataChangesBySyncCheckpointChangesType {
    #[serde(rename = "data_changes")]
    DataChanges,
}
impl ::std::convert::From<&Self> for DataChangesBySyncCheckpointChangesType {
    fn from(value: &DataChangesBySyncCheckpointChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for DataChangesBySyncCheckpointChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::DataChanges => write!(f, "data_changes"),
        }
    }
}
impl ::std::str::FromStr for DataChangesBySyncCheckpointChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "data_changes" => Ok(Self::DataChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for DataChangesBySyncCheckpointChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DataChangesBySyncCheckpointChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DataChangesBySyncCheckpointChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`DataReceiptCreationConfigView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"base_cost\","]
#[doc = "    \"cost_per_byte\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"base_cost\": {"]
#[doc = "      \"description\": \"Base cost of creating a data receipt.\\nBoth `send` and `exec` costs are burned when a new receipt has input dependencies. The gas\\nis charged for each input dependency. The dependencies are specified when a receipt is\\ncreated using `promise_then` and `promise_batch_then`.\\nNOTE: Any receipt with output dependencies will produce data receipts. Even if it fails.\\nEven if the last action is not a function call (in case of success it will return empty\\nvalue).\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"cost_per_byte\": {"]
#[doc = "      \"description\": \"Additional cost per byte sent.\\nBoth `send` and `exec` costs are burned when a function call finishes execution and returns\\n`N` bytes of data to every output dependency. For each output dependency the cost is\\n`(send(sir) + exec()) * N`.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DataReceiptCreationConfigView {
    #[doc = "Base cost of creating a data receipt.\nBoth `send` and `exec` costs are burned when a new receipt has input dependencies. The gas\nis charged for each input dependency. The dependencies are specified when a receipt is\ncreated using `promise_then` and `promise_batch_then`.\nNOTE: Any receipt with output dependencies will produce data receipts. Even if it fails.\nEven if the last action is not a function call (in case of success it will return empty\nvalue)."]
    pub base_cost: Fee,
    #[doc = "Additional cost per byte sent.\nBoth `send` and `exec` costs are burned when a function call finishes execution and returns\n`N` bytes of data to every output dependency. For each output dependency the cost is\n`(send(sir) + exec()) * N`."]
    pub cost_per_byte: Fee,
}
impl ::std::convert::From<&DataReceiptCreationConfigView> for DataReceiptCreationConfigView {
    fn from(value: &DataReceiptCreationConfigView) -> Self {
        value.clone()
    }
}
#[doc = "`DataReceiverView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"data_id\","]
#[doc = "    \"receiver_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"data_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"receiver_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DataReceiverView {
    pub data_id: CryptoHash,
    pub receiver_id: AccountId,
}
impl ::std::convert::From<&DataReceiverView> for DataReceiverView {
    fn from(value: &DataReceiverView) -> Self {
        value.clone()
    }
}
#[doc = "This action allows to execute the inner actions behalf of the defined sender."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"This action allows to execute the inner actions behalf of the defined sender.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"actions\","]
#[doc = "    \"max_block_height\","]
#[doc = "    \"nonce\","]
#[doc = "    \"public_key\","]
#[doc = "    \"receiver_id\","]
#[doc = "    \"sender_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"actions\": {"]
#[doc = "      \"description\": \"List of actions to be executed.\\n\\nWith the meta transactions MVP defined in NEP-366, nested\\nDelegateActions are not allowed. A separate type is used to enforce it.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/NonDelegateAction\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"max_block_height\": {"]
#[doc = "      \"description\": \"The maximal height of the block in the blockchain below which the given DelegateAction is valid.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"nonce\": {"]
#[doc = "      \"description\": \"Nonce to ensure that the same delegate action is not sent twice by a\\nrelayer and should match for given account's `public_key`.\\nAfter this action is processed it will increment.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"description\": \"Public key used to sign this delegated action.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"receiver_id\": {"]
#[doc = "      \"description\": \"Receiver of the delegated actions.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sender_id\": {"]
#[doc = "      \"description\": \"Signer of the delegated actions\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DelegateAction {
    #[doc = "List of actions to be executed.\n\nWith the meta transactions MVP defined in NEP-366, nested\nDelegateActions are not allowed. A separate type is used to enforce it."]
    pub actions: ::std::vec::Vec<NonDelegateAction>,
    #[doc = "The maximal height of the block in the blockchain below which the given DelegateAction is valid."]
    pub max_block_height: u64,
    #[doc = "Nonce to ensure that the same delegate action is not sent twice by a\nrelayer and should match for given account's `public_key`.\nAfter this action is processed it will increment."]
    pub nonce: u64,
    #[doc = "Public key used to sign this delegated action."]
    pub public_key: PublicKey,
    #[doc = "Receiver of the delegated actions."]
    pub receiver_id: AccountId,
    #[doc = "Signer of the delegated actions"]
    pub sender_id: AccountId,
}
impl ::std::convert::From<&DelegateAction> for DelegateAction {
    fn from(value: &DelegateAction) -> Self {
        value.clone()
    }
}
#[doc = "`DeleteAccountAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"beneficiary_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"beneficiary_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DeleteAccountAction {
    pub beneficiary_id: AccountId,
}
impl ::std::convert::From<&DeleteAccountAction> for DeleteAccountAction {
    fn from(value: &DeleteAccountAction) -> Self {
        value.clone()
    }
}
#[doc = "`DeleteKeyAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"public_key\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"description\": \"A public key associated with the access_key to be deleted.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DeleteKeyAction {
    #[doc = "A public key associated with the access_key to be deleted."]
    pub public_key: PublicKey,
}
impl ::std::convert::From<&DeleteKeyAction> for DeleteKeyAction {
    fn from(value: &DeleteKeyAction) -> Self {
        value.clone()
    }
}
#[doc = "Deploy contract action"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Deploy contract action\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"description\": \"WebAssembly binary\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DeployContractAction {
    #[doc = "WebAssembly binary"]
    pub code: ::std::string::String,
}
impl ::std::convert::From<&DeployContractAction> for DeployContractAction {
    fn from(value: &DeployContractAction) -> Self {
        value.clone()
    }
}
#[doc = "Deploy global contract action"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Deploy global contract action\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"deploy_mode\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"code\": {"]
#[doc = "      \"description\": \"WebAssembly binary\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"deploy_mode\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/GlobalContractDeployMode\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DeployGlobalContractAction {
    #[doc = "WebAssembly binary"]
    pub code: ::std::string::String,
    pub deploy_mode: GlobalContractDeployMode,
}
impl ::std::convert::From<&DeployGlobalContractAction> for DeployGlobalContractAction {
    fn from(value: &DeployGlobalContractAction) -> Self {
        value.clone()
    }
}
#[doc = "`DetailedDebugStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"block_production_delay_millis\","]
#[doc = "    \"catchup_status\","]
#[doc = "    \"current_head_status\","]
#[doc = "    \"current_header_head_status\","]
#[doc = "    \"network_info\","]
#[doc = "    \"sync_status\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"block_production_delay_millis\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"catchup_status\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/CatchupStatusView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"current_head_status\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/BlockStatusView\""]
#[doc = "    },"]
#[doc = "    \"current_header_head_status\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/BlockStatusView\""]
#[doc = "    },"]
#[doc = "    \"network_info\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/NetworkInfoView\""]
#[doc = "    },"]
#[doc = "    \"sync_status\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DetailedDebugStatus {
    pub block_production_delay_millis: u64,
    pub catchup_status: ::std::vec::Vec<CatchupStatusView>,
    pub current_head_status: BlockStatusView,
    pub current_header_head_status: BlockStatusView,
    pub network_info: NetworkInfoView,
    pub sync_status: ::std::string::String,
}
impl ::std::convert::From<&DetailedDebugStatus> for DetailedDebugStatus {
    fn from(value: &DetailedDebugStatus) -> Self {
        value.clone()
    }
}
#[doc = "`Direction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"Left\","]
#[doc = "    \"Right\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum Direction {
    Left,
    Right,
}
impl ::std::convert::From<&Self> for Direction {
    fn from(value: &Direction) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for Direction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Left => write!(f, "Left"),
            Self::Right => write!(f, "Right"),
        }
    }
}
impl ::std::str::FromStr for Direction {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Left" => Ok(Self::Left),
            "Right" => Ok(Self::Right),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for Direction {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Direction {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Configures how to dump state to external storage."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Configures how to dump state to external storage.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"location\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"credentials_file\": {"]
#[doc = "      \"description\": \"Location of a json file with credentials allowing write access to the bucket.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"iteration_delay\": {"]
#[doc = "      \"description\": \"How often to check if a new epoch has started.\\nFeel free to set to `None`, defaults are sensible.\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/DurationAsStdSchemaProvider\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"location\": {"]
#[doc = "      \"description\": \"Specifies where to write the obtained state parts.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/ExternalStorageLocation\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"restart_dump_for_shards\": {"]
#[doc = "      \"description\": \"Use in case a node that dumps state to the external storage\\ngets in trouble.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"array\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DumpConfig {
    #[doc = "Location of a json file with credentials allowing write access to the bucket."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub credentials_file: ::std::option::Option<::std::string::String>,
    #[doc = "How often to check if a new epoch has started.\nFeel free to set to `None`, defaults are sensible."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub iteration_delay: ::std::option::Option<DurationAsStdSchemaProvider>,
    #[doc = "Specifies where to write the obtained state parts."]
    pub location: ExternalStorageLocation,
    #[doc = "Use in case a node that dumps state to the external storage\ngets in trouble."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub restart_dump_for_shards: ::std::option::Option<::std::vec::Vec<ShardId>>,
}
impl ::std::convert::From<&DumpConfig> for DumpConfig {
    fn from(value: &DumpConfig) -> Self {
        value.clone()
    }
}
#[doc = "`DurationAsStdSchemaProvider`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"nanos\","]
#[doc = "    \"secs\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"nanos\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"int32\""]
#[doc = "    },"]
#[doc = "    \"secs\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"int64\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DurationAsStdSchemaProvider {
    pub nanos: i32,
    pub secs: i64,
}
impl ::std::convert::From<&DurationAsStdSchemaProvider> for DurationAsStdSchemaProvider {
    fn from(value: &DurationAsStdSchemaProvider) -> Self {
        value.clone()
    }
}
#[doc = "Epoch identifier -- wrapped hash, to make it easier to distinguish.\nEpochId of epoch T is the hash of last block in T-2\nEpochId of first two epochs is 0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Epoch identifier -- wrapped hash, to make it easier to distinguish.\\nEpochId of epoch T is the hash of last block in T-2\\nEpochId of first two epochs is 0\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct EpochId(pub CryptoHash);
impl ::std::ops::Deref for EpochId {
    type Target = CryptoHash;
    fn deref(&self) -> &CryptoHash {
        &self.0
    }
}
impl ::std::convert::From<EpochId> for CryptoHash {
    fn from(value: EpochId) -> Self {
        value.0
    }
}
impl ::std::convert::From<&EpochId> for EpochId {
    fn from(value: &EpochId) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<CryptoHash> for EpochId {
    fn from(value: CryptoHash) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for EpochId {
    type Err = <CryptoHash as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for EpochId {
    type Error = <CryptoHash as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for EpochId {
    type Error = <CryptoHash as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for EpochId {
    type Error = <CryptoHash as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for EpochId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`EpochSyncConfig`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"epoch_sync_horizon\","]
#[doc = "    \"timeout_for_epoch_sync\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"disable_epoch_sync_for_bootstrapping\": {"]
#[doc = "      \"description\": \"If true, even if the node started from genesis, it will not perform epoch sync.\\nThere should be no reason to set this flag in production, because on both mainnet\\nand testnet it would be infeasible to catch up from genesis without epoch sync.\","]
#[doc = "      \"default\": false,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"epoch_sync_horizon\": {"]
#[doc = "      \"description\": \"This serves as two purposes: (1) the node will not epoch sync and instead resort to\\nheader sync, if the genesis block is within this many blocks from the current block;\\n(2) the node will reject an epoch sync proof if the provided proof is for an epoch\\nthat is more than this many blocks behind the current block.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"ignore_epoch_sync_network_requests\": {"]
#[doc = "      \"description\": \"If true, the node will ignore epoch sync requests from the network. It is strongly\\nrecommended not to set this flag, because it will prevent other nodes from\\nbootstrapping. This flag is only included as a kill-switch and may be removed in a\\nfuture release. Please note that epoch sync requests are heavily rate limited and\\ncached, and therefore should not affect the performance of the node or introduce\\nany non-negligible increase in network traffic.\","]
#[doc = "      \"default\": false,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"timeout_for_epoch_sync\": {"]
#[doc = "      \"description\": \"Timeout for epoch sync requests. The node will continue retrying indefinitely even\\nif this timeout is exceeded.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/DurationAsStdSchemaProvider\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EpochSyncConfig {
    #[doc = "If true, even if the node started from genesis, it will not perform epoch sync.\nThere should be no reason to set this flag in production, because on both mainnet\nand testnet it would be infeasible to catch up from genesis without epoch sync."]
    #[serde(default)]
    pub disable_epoch_sync_for_bootstrapping: bool,
    #[doc = "This serves as two purposes: (1) the node will not epoch sync and instead resort to\nheader sync, if the genesis block is within this many blocks from the current block;\n(2) the node will reject an epoch sync proof if the provided proof is for an epoch\nthat is more than this many blocks behind the current block."]
    pub epoch_sync_horizon: u64,
    #[doc = "If true, the node will ignore epoch sync requests from the network. It is strongly\nrecommended not to set this flag, because it will prevent other nodes from\nbootstrapping. This flag is only included as a kill-switch and may be removed in a\nfuture release. Please note that epoch sync requests are heavily rate limited and\ncached, and therefore should not affect the performance of the node or introduce\nany non-negligible increase in network traffic."]
    #[serde(default)]
    pub ignore_epoch_sync_network_requests: bool,
    #[doc = "Timeout for epoch sync requests. The node will continue retrying indefinitely even\nif this timeout is exceeded."]
    pub timeout_for_epoch_sync: DurationAsStdSchemaProvider,
}
impl ::std::convert::From<&EpochSyncConfig> for EpochSyncConfig {
    fn from(value: &EpochSyncConfig) -> Self {
        value.clone()
    }
}
#[doc = "`ExecutionMetadataView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"gas_profile\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"array\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/CostGasUsed\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExecutionMetadataView {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub gas_profile: ::std::option::Option<::std::vec::Vec<CostGasUsed>>,
    pub version: u32,
}
impl ::std::convert::From<&ExecutionMetadataView> for ExecutionMetadataView {
    fn from(value: &ExecutionMetadataView) -> Self {
        value.clone()
    }
}
#[doc = "`ExecutionOutcomeView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"executor_id\","]
#[doc = "    \"gas_burnt\","]
#[doc = "    \"logs\","]
#[doc = "    \"receipt_ids\","]
#[doc = "    \"status\","]
#[doc = "    \"tokens_burnt\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"executor_id\": {"]
#[doc = "      \"description\": \"The id of the account on which the execution happens. For transaction this is signer_id,\\nfor receipt this is receiver_id.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"gas_burnt\": {"]
#[doc = "      \"description\": \"The amount of the gas burnt by the given transaction or receipt.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"logs\": {"]
#[doc = "      \"description\": \"Logs from this transaction or receipt.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"description\": \"Execution metadata, versioned\","]
#[doc = "      \"default\": {"]
#[doc = "        \"version\": 1"]
#[doc = "      },"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/ExecutionMetadataView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"receipt_ids\": {"]
#[doc = "      \"description\": \"Receipt IDs generated by this transaction or receipt.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"description\": \"Execution status. Contains the result in case of successful execution.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/ExecutionStatusView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"tokens_burnt\": {"]
#[doc = "      \"description\": \"The amount of tokens burnt corresponding to the burnt gas amount.\\nThis value doesn't always equal to the `gas_burnt` multiplied by the gas price, because\\nthe prepaid gas price might be lower than the actual gas price and it creates a deficit.\\n`tokens_burnt` also contains the penalty subtracted from refunds, while\\n`gas_burnt` only contains the gas that we actually burn for the execution.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExecutionOutcomeView {
    #[doc = "The id of the account on which the execution happens. For transaction this is signer_id,\nfor receipt this is receiver_id."]
    pub executor_id: AccountId,
    #[doc = "The amount of the gas burnt by the given transaction or receipt."]
    pub gas_burnt: u64,
    #[doc = "Logs from this transaction or receipt."]
    pub logs: ::std::vec::Vec<::std::string::String>,
    #[doc = "Execution metadata, versioned"]
    #[serde(default = "defaults::execution_outcome_view_metadata")]
    pub metadata: ExecutionMetadataView,
    #[doc = "Receipt IDs generated by this transaction or receipt."]
    pub receipt_ids: ::std::vec::Vec<CryptoHash>,
    #[doc = "Execution status. Contains the result in case of successful execution."]
    pub status: ExecutionStatusView,
    #[doc = "The amount of tokens burnt corresponding to the burnt gas amount.\nThis value doesn't always equal to the `gas_burnt` multiplied by the gas price, because\nthe prepaid gas price might be lower than the actual gas price and it creates a deficit.\n`tokens_burnt` also contains the penalty subtracted from refunds, while\n`gas_burnt` only contains the gas that we actually burn for the execution."]
    pub tokens_burnt: ::std::string::String,
}
impl ::std::convert::From<&ExecutionOutcomeView> for ExecutionOutcomeView {
    fn from(value: &ExecutionOutcomeView) -> Self {
        value.clone()
    }
}
#[doc = "`ExecutionOutcomeWithIdView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"block_hash\","]
#[doc = "    \"id\","]
#[doc = "    \"outcome\","]
#[doc = "    \"proof\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"block_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"outcome\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/ExecutionOutcomeView\""]
#[doc = "    },"]
#[doc = "    \"proof\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/MerklePathItem\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExecutionOutcomeWithIdView {
    pub block_hash: CryptoHash,
    pub id: CryptoHash,
    pub outcome: ExecutionOutcomeView,
    pub proof: ::std::vec::Vec<MerklePathItem>,
}
impl ::std::convert::From<&ExecutionOutcomeWithIdView> for ExecutionOutcomeWithIdView {
    fn from(value: &ExecutionOutcomeWithIdView) -> Self {
        value.clone()
    }
}
#[doc = "`ExecutionStatusView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"The execution is pending or unknown.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Unknown\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The execution has failed.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Failure\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Failure\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/TxExecutionError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The final action succeeded and returned some value or an empty vec encoded in base64.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"SuccessValue\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"SuccessValue\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The final action of the receipt returned a promise or the signed transaction was converted\\nto a receipt. Contains the receipt_id of the generated receipt.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"SuccessReceiptId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"SuccessReceiptId\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum ExecutionStatusView {
    #[doc = "The execution is pending or unknown."]
    Unknown,
    #[doc = "The execution has failed."]
    Failure(TxExecutionError),
    #[doc = "The final action succeeded and returned some value or an empty vec encoded in base64."]
    SuccessValue(::std::string::String),
    #[doc = "The final action of the receipt returned a promise or the signed transaction was converted\nto a receipt. Contains the receipt_id of the generated receipt."]
    SuccessReceiptId(CryptoHash),
}
impl ::std::convert::From<&Self> for ExecutionStatusView {
    fn from(value: &ExecutionStatusView) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TxExecutionError> for ExecutionStatusView {
    fn from(value: TxExecutionError) -> Self {
        Self::Failure(value)
    }
}
impl ::std::convert::From<CryptoHash> for ExecutionStatusView {
    fn from(value: CryptoHash) -> Self {
        Self::SuccessReceiptId(value)
    }
}
#[doc = "Typed view of ExtCostsConfig to preserve JSON output field names in protocol\nconfig RPC output."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Typed view of ExtCostsConfig to preserve JSON output field names in protocol\\nconfig RPC output.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"alt_bn128_g1_multiexp_base\","]
#[doc = "    \"alt_bn128_g1_multiexp_element\","]
#[doc = "    \"alt_bn128_g1_sum_base\","]
#[doc = "    \"alt_bn128_g1_sum_element\","]
#[doc = "    \"alt_bn128_pairing_check_base\","]
#[doc = "    \"alt_bn128_pairing_check_element\","]
#[doc = "    \"base\","]
#[doc = "    \"bls12381_g1_multiexp_base\","]
#[doc = "    \"bls12381_g1_multiexp_element\","]
#[doc = "    \"bls12381_g2_multiexp_base\","]
#[doc = "    \"bls12381_g2_multiexp_element\","]
#[doc = "    \"bls12381_map_fp2_to_g2_base\","]
#[doc = "    \"bls12381_map_fp2_to_g2_element\","]
#[doc = "    \"bls12381_map_fp_to_g1_base\","]
#[doc = "    \"bls12381_map_fp_to_g1_element\","]
#[doc = "    \"bls12381_p1_decompress_base\","]
#[doc = "    \"bls12381_p1_decompress_element\","]
#[doc = "    \"bls12381_p1_sum_base\","]
#[doc = "    \"bls12381_p1_sum_element\","]
#[doc = "    \"bls12381_p2_decompress_base\","]
#[doc = "    \"bls12381_p2_decompress_element\","]
#[doc = "    \"bls12381_p2_sum_base\","]
#[doc = "    \"bls12381_p2_sum_element\","]
#[doc = "    \"bls12381_pairing_base\","]
#[doc = "    \"bls12381_pairing_element\","]
#[doc = "    \"contract_compile_base\","]
#[doc = "    \"contract_compile_bytes\","]
#[doc = "    \"contract_loading_base\","]
#[doc = "    \"contract_loading_bytes\","]
#[doc = "    \"ecrecover_base\","]
#[doc = "    \"ed25519_verify_base\","]
#[doc = "    \"ed25519_verify_byte\","]
#[doc = "    \"keccak256_base\","]
#[doc = "    \"keccak256_byte\","]
#[doc = "    \"keccak512_base\","]
#[doc = "    \"keccak512_byte\","]
#[doc = "    \"log_base\","]
#[doc = "    \"log_byte\","]
#[doc = "    \"promise_and_base\","]
#[doc = "    \"promise_and_per_promise\","]
#[doc = "    \"promise_return\","]
#[doc = "    \"read_cached_trie_node\","]
#[doc = "    \"read_memory_base\","]
#[doc = "    \"read_memory_byte\","]
#[doc = "    \"read_register_base\","]
#[doc = "    \"read_register_byte\","]
#[doc = "    \"ripemd160_base\","]
#[doc = "    \"ripemd160_block\","]
#[doc = "    \"sha256_base\","]
#[doc = "    \"sha256_byte\","]
#[doc = "    \"storage_has_key_base\","]
#[doc = "    \"storage_has_key_byte\","]
#[doc = "    \"storage_iter_create_from_byte\","]
#[doc = "    \"storage_iter_create_prefix_base\","]
#[doc = "    \"storage_iter_create_prefix_byte\","]
#[doc = "    \"storage_iter_create_range_base\","]
#[doc = "    \"storage_iter_create_to_byte\","]
#[doc = "    \"storage_iter_next_base\","]
#[doc = "    \"storage_iter_next_key_byte\","]
#[doc = "    \"storage_iter_next_value_byte\","]
#[doc = "    \"storage_large_read_overhead_base\","]
#[doc = "    \"storage_large_read_overhead_byte\","]
#[doc = "    \"storage_read_base\","]
#[doc = "    \"storage_read_key_byte\","]
#[doc = "    \"storage_read_value_byte\","]
#[doc = "    \"storage_remove_base\","]
#[doc = "    \"storage_remove_key_byte\","]
#[doc = "    \"storage_remove_ret_value_byte\","]
#[doc = "    \"storage_write_base\","]
#[doc = "    \"storage_write_evicted_byte\","]
#[doc = "    \"storage_write_key_byte\","]
#[doc = "    \"storage_write_value_byte\","]
#[doc = "    \"touching_trie_node\","]
#[doc = "    \"utf16_decoding_base\","]
#[doc = "    \"utf16_decoding_byte\","]
#[doc = "    \"utf8_decoding_base\","]
#[doc = "    \"utf8_decoding_byte\","]
#[doc = "    \"validator_stake_base\","]
#[doc = "    \"validator_total_stake_base\","]
#[doc = "    \"write_memory_base\","]
#[doc = "    \"write_memory_byte\","]
#[doc = "    \"write_register_base\","]
#[doc = "    \"write_register_byte\","]
#[doc = "    \"yield_create_base\","]
#[doc = "    \"yield_create_byte\","]
#[doc = "    \"yield_resume_base\","]
#[doc = "    \"yield_resume_byte\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"alt_bn128_g1_multiexp_base\": {"]
#[doc = "      \"description\": \"Base cost for multiexp\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"alt_bn128_g1_multiexp_element\": {"]
#[doc = "      \"description\": \"Per element cost for multiexp\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"alt_bn128_g1_sum_base\": {"]
#[doc = "      \"description\": \"Base cost for sum\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"alt_bn128_g1_sum_element\": {"]
#[doc = "      \"description\": \"Per element cost for sum\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"alt_bn128_pairing_check_base\": {"]
#[doc = "      \"description\": \"Base cost for pairing check\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"alt_bn128_pairing_check_element\": {"]
#[doc = "      \"description\": \"Per element cost for pairing check\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"base\": {"]
#[doc = "      \"description\": \"Base cost for calling a host function.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_g1_multiexp_base\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_g1_multiexp_element\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_g2_multiexp_base\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_g2_multiexp_element\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_map_fp2_to_g2_base\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_map_fp2_to_g2_element\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_map_fp_to_g1_base\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_map_fp_to_g1_element\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_p1_decompress_base\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_p1_decompress_element\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_p1_sum_base\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_p1_sum_element\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_p2_decompress_base\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_p2_decompress_element\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_p2_sum_base\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_p2_sum_element\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_pairing_base\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"bls12381_pairing_element\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"contract_compile_base\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"contract_compile_bytes\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"contract_loading_base\": {"]
#[doc = "      \"description\": \"Base cost of loading a pre-compiled contract\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"contract_loading_bytes\": {"]
#[doc = "      \"description\": \"Cost per byte of loading a pre-compiled contract\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"ecrecover_base\": {"]
#[doc = "      \"description\": \"Cost of calling ecrecover\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"ed25519_verify_base\": {"]
#[doc = "      \"description\": \"Cost of getting ed25519 base\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"ed25519_verify_byte\": {"]
#[doc = "      \"description\": \"Cost of getting ed25519 per byte\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"keccak256_base\": {"]
#[doc = "      \"description\": \"Cost of getting sha256 base\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"keccak256_byte\": {"]
#[doc = "      \"description\": \"Cost of getting sha256 per byte\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"keccak512_base\": {"]
#[doc = "      \"description\": \"Cost of getting sha256 base\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"keccak512_byte\": {"]
#[doc = "      \"description\": \"Cost of getting sha256 per byte\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"log_base\": {"]
#[doc = "      \"description\": \"Cost for calling logging.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"log_byte\": {"]
#[doc = "      \"description\": \"Cost for logging per byte\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"promise_and_base\": {"]
#[doc = "      \"description\": \"Cost for calling `promise_and`\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"promise_and_per_promise\": {"]
#[doc = "      \"description\": \"Cost for calling `promise_and` for each promise\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"promise_return\": {"]
#[doc = "      \"description\": \"Cost for calling `promise_return`\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"read_cached_trie_node\": {"]
#[doc = "      \"description\": \"Cost for reading trie node from memory\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"read_memory_base\": {"]
#[doc = "      \"description\": \"Base cost for guest memory read\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"read_memory_byte\": {"]
#[doc = "      \"description\": \"Cost for guest memory read\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"read_register_base\": {"]
#[doc = "      \"description\": \"Base cost for reading from register\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"read_register_byte\": {"]
#[doc = "      \"description\": \"Cost for reading byte from register\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"ripemd160_base\": {"]
#[doc = "      \"description\": \"Cost of getting ripemd160 base\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"ripemd160_block\": {"]
#[doc = "      \"description\": \"Cost of getting ripemd160 per message block\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"sha256_base\": {"]
#[doc = "      \"description\": \"Cost of getting sha256 base\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"sha256_byte\": {"]
#[doc = "      \"description\": \"Cost of getting sha256 per byte\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_has_key_base\": {"]
#[doc = "      \"description\": \"Storage trie check for key existence cost base\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_has_key_byte\": {"]
#[doc = "      \"description\": \"Storage trie check for key existence per key byte\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_iter_create_from_byte\": {"]
#[doc = "      \"description\": \"Create trie range iterator cost per byte of from key.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_iter_create_prefix_base\": {"]
#[doc = "      \"description\": \"Create trie prefix iterator cost base\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_iter_create_prefix_byte\": {"]
#[doc = "      \"description\": \"Create trie prefix iterator cost per byte.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_iter_create_range_base\": {"]
#[doc = "      \"description\": \"Create trie range iterator cost base\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_iter_create_to_byte\": {"]
#[doc = "      \"description\": \"Create trie range iterator cost per byte of to key.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_iter_next_base\": {"]
#[doc = "      \"description\": \"Trie iterator per key base cost\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_iter_next_key_byte\": {"]
#[doc = "      \"description\": \"Trie iterator next key byte cost\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_iter_next_value_byte\": {"]
#[doc = "      \"description\": \"Trie iterator next key byte cost\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_large_read_overhead_base\": {"]
#[doc = "      \"description\": \"Storage trie read key overhead base cost, when doing large reads\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_large_read_overhead_byte\": {"]
#[doc = "      \"description\": \"Storage trie read key overhead  per-byte cost, when doing large reads\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_read_base\": {"]
#[doc = "      \"description\": \"Storage trie read key base cost\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_read_key_byte\": {"]
#[doc = "      \"description\": \"Storage trie read key per byte cost\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_read_value_byte\": {"]
#[doc = "      \"description\": \"Storage trie read value cost per byte cost\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_remove_base\": {"]
#[doc = "      \"description\": \"Remove key from trie base cost\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_remove_key_byte\": {"]
#[doc = "      \"description\": \"Remove key from trie per byte cost\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_remove_ret_value_byte\": {"]
#[doc = "      \"description\": \"Remove key from trie ret value byte cost\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_write_base\": {"]
#[doc = "      \"description\": \"Storage trie write key base cost\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_write_evicted_byte\": {"]
#[doc = "      \"description\": \"Storage trie write cost per byte of evicted value.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_write_key_byte\": {"]
#[doc = "      \"description\": \"Storage trie write key per byte cost\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_write_value_byte\": {"]
#[doc = "      \"description\": \"Storage trie write value per byte cost\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"touching_trie_node\": {"]
#[doc = "      \"description\": \"Cost per reading trie node from DB\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"utf16_decoding_base\": {"]
#[doc = "      \"description\": \"Base cost of decoding utf16. It's used for `log_utf16`.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"utf16_decoding_byte\": {"]
#[doc = "      \"description\": \"Cost per byte of decoding utf16. It's used for `log_utf16`.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"utf8_decoding_base\": {"]
#[doc = "      \"description\": \"Base cost of decoding utf8. It's used for `log_utf8` and `panic_utf8`.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"utf8_decoding_byte\": {"]
#[doc = "      \"description\": \"Cost per byte of decoding utf8. It's used for `log_utf8` and `panic_utf8`.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"validator_stake_base\": {"]
#[doc = "      \"description\": \"Cost of calling `validator_stake`.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"validator_total_stake_base\": {"]
#[doc = "      \"description\": \"Cost of calling `validator_total_stake`.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"write_memory_base\": {"]
#[doc = "      \"description\": \"Base cost for guest memory write\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"write_memory_byte\": {"]
#[doc = "      \"description\": \"Cost for guest memory write per byte\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"write_register_base\": {"]
#[doc = "      \"description\": \"Base cost for writing into register\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"write_register_byte\": {"]
#[doc = "      \"description\": \"Cost for writing byte into register\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"yield_create_base\": {"]
#[doc = "      \"description\": \"Base cost for creating a yield promise.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"yield_create_byte\": {"]
#[doc = "      \"description\": \"Per byte cost of arguments and method name.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"yield_resume_base\": {"]
#[doc = "      \"description\": \"Base cost for resuming a yield receipt.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"yield_resume_byte\": {"]
#[doc = "      \"description\": \"Per byte cost of resume payload.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExtCostsConfigView {
    #[doc = "Base cost for multiexp"]
    pub alt_bn128_g1_multiexp_base: u64,
    #[doc = "Per element cost for multiexp"]
    pub alt_bn128_g1_multiexp_element: u64,
    #[doc = "Base cost for sum"]
    pub alt_bn128_g1_sum_base: u64,
    #[doc = "Per element cost for sum"]
    pub alt_bn128_g1_sum_element: u64,
    #[doc = "Base cost for pairing check"]
    pub alt_bn128_pairing_check_base: u64,
    #[doc = "Per element cost for pairing check"]
    pub alt_bn128_pairing_check_element: u64,
    #[doc = "Base cost for calling a host function."]
    pub base: u64,
    pub bls12381_g1_multiexp_base: u64,
    pub bls12381_g1_multiexp_element: u64,
    pub bls12381_g2_multiexp_base: u64,
    pub bls12381_g2_multiexp_element: u64,
    pub bls12381_map_fp2_to_g2_base: u64,
    pub bls12381_map_fp2_to_g2_element: u64,
    pub bls12381_map_fp_to_g1_base: u64,
    pub bls12381_map_fp_to_g1_element: u64,
    pub bls12381_p1_decompress_base: u64,
    pub bls12381_p1_decompress_element: u64,
    pub bls12381_p1_sum_base: u64,
    pub bls12381_p1_sum_element: u64,
    pub bls12381_p2_decompress_base: u64,
    pub bls12381_p2_decompress_element: u64,
    pub bls12381_p2_sum_base: u64,
    pub bls12381_p2_sum_element: u64,
    pub bls12381_pairing_base: u64,
    pub bls12381_pairing_element: u64,
    pub contract_compile_base: u64,
    pub contract_compile_bytes: u64,
    #[doc = "Base cost of loading a pre-compiled contract"]
    pub contract_loading_base: u64,
    #[doc = "Cost per byte of loading a pre-compiled contract"]
    pub contract_loading_bytes: u64,
    #[doc = "Cost of calling ecrecover"]
    pub ecrecover_base: u64,
    #[doc = "Cost of getting ed25519 base"]
    pub ed25519_verify_base: u64,
    #[doc = "Cost of getting ed25519 per byte"]
    pub ed25519_verify_byte: u64,
    #[doc = "Cost of getting sha256 base"]
    pub keccak256_base: u64,
    #[doc = "Cost of getting sha256 per byte"]
    pub keccak256_byte: u64,
    #[doc = "Cost of getting sha256 base"]
    pub keccak512_base: u64,
    #[doc = "Cost of getting sha256 per byte"]
    pub keccak512_byte: u64,
    #[doc = "Cost for calling logging."]
    pub log_base: u64,
    #[doc = "Cost for logging per byte"]
    pub log_byte: u64,
    #[doc = "Cost for calling `promise_and`"]
    pub promise_and_base: u64,
    #[doc = "Cost for calling `promise_and` for each promise"]
    pub promise_and_per_promise: u64,
    #[doc = "Cost for calling `promise_return`"]
    pub promise_return: u64,
    #[doc = "Cost for reading trie node from memory"]
    pub read_cached_trie_node: u64,
    #[doc = "Base cost for guest memory read"]
    pub read_memory_base: u64,
    #[doc = "Cost for guest memory read"]
    pub read_memory_byte: u64,
    #[doc = "Base cost for reading from register"]
    pub read_register_base: u64,
    #[doc = "Cost for reading byte from register"]
    pub read_register_byte: u64,
    #[doc = "Cost of getting ripemd160 base"]
    pub ripemd160_base: u64,
    #[doc = "Cost of getting ripemd160 per message block"]
    pub ripemd160_block: u64,
    #[doc = "Cost of getting sha256 base"]
    pub sha256_base: u64,
    #[doc = "Cost of getting sha256 per byte"]
    pub sha256_byte: u64,
    #[doc = "Storage trie check for key existence cost base"]
    pub storage_has_key_base: u64,
    #[doc = "Storage trie check for key existence per key byte"]
    pub storage_has_key_byte: u64,
    #[doc = "Create trie range iterator cost per byte of from key."]
    pub storage_iter_create_from_byte: u64,
    #[doc = "Create trie prefix iterator cost base"]
    pub storage_iter_create_prefix_base: u64,
    #[doc = "Create trie prefix iterator cost per byte."]
    pub storage_iter_create_prefix_byte: u64,
    #[doc = "Create trie range iterator cost base"]
    pub storage_iter_create_range_base: u64,
    #[doc = "Create trie range iterator cost per byte of to key."]
    pub storage_iter_create_to_byte: u64,
    #[doc = "Trie iterator per key base cost"]
    pub storage_iter_next_base: u64,
    #[doc = "Trie iterator next key byte cost"]
    pub storage_iter_next_key_byte: u64,
    #[doc = "Trie iterator next key byte cost"]
    pub storage_iter_next_value_byte: u64,
    #[doc = "Storage trie read key overhead base cost, when doing large reads"]
    pub storage_large_read_overhead_base: u64,
    #[doc = "Storage trie read key overhead  per-byte cost, when doing large reads"]
    pub storage_large_read_overhead_byte: u64,
    #[doc = "Storage trie read key base cost"]
    pub storage_read_base: u64,
    #[doc = "Storage trie read key per byte cost"]
    pub storage_read_key_byte: u64,
    #[doc = "Storage trie read value cost per byte cost"]
    pub storage_read_value_byte: u64,
    #[doc = "Remove key from trie base cost"]
    pub storage_remove_base: u64,
    #[doc = "Remove key from trie per byte cost"]
    pub storage_remove_key_byte: u64,
    #[doc = "Remove key from trie ret value byte cost"]
    pub storage_remove_ret_value_byte: u64,
    #[doc = "Storage trie write key base cost"]
    pub storage_write_base: u64,
    #[doc = "Storage trie write cost per byte of evicted value."]
    pub storage_write_evicted_byte: u64,
    #[doc = "Storage trie write key per byte cost"]
    pub storage_write_key_byte: u64,
    #[doc = "Storage trie write value per byte cost"]
    pub storage_write_value_byte: u64,
    #[doc = "Cost per reading trie node from DB"]
    pub touching_trie_node: u64,
    #[doc = "Base cost of decoding utf16. It's used for `log_utf16`."]
    pub utf16_decoding_base: u64,
    #[doc = "Cost per byte of decoding utf16. It's used for `log_utf16`."]
    pub utf16_decoding_byte: u64,
    #[doc = "Base cost of decoding utf8. It's used for `log_utf8` and `panic_utf8`."]
    pub utf8_decoding_base: u64,
    #[doc = "Cost per byte of decoding utf8. It's used for `log_utf8` and `panic_utf8`."]
    pub utf8_decoding_byte: u64,
    #[doc = "Cost of calling `validator_stake`."]
    pub validator_stake_base: u64,
    #[doc = "Cost of calling `validator_total_stake`."]
    pub validator_total_stake_base: u64,
    #[doc = "Base cost for guest memory write"]
    pub write_memory_base: u64,
    #[doc = "Cost for guest memory write per byte"]
    pub write_memory_byte: u64,
    #[doc = "Base cost for writing into register"]
    pub write_register_base: u64,
    #[doc = "Cost for writing byte into register"]
    pub write_register_byte: u64,
    #[doc = "Base cost for creating a yield promise."]
    pub yield_create_base: u64,
    #[doc = "Per byte cost of arguments and method name."]
    pub yield_create_byte: u64,
    #[doc = "Base cost for resuming a yield receipt."]
    pub yield_resume_base: u64,
    #[doc = "Per byte cost of resume payload."]
    pub yield_resume_byte: u64,
}
impl ::std::convert::From<&ExtCostsConfigView> for ExtCostsConfigView {
    fn from(value: &ExtCostsConfigView) -> Self {
        value.clone()
    }
}
#[doc = "`ExternalStorageConfig`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"location\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"external_storage_fallback_threshold\": {"]
#[doc = "      \"description\": \"The number of attempts the node will make to obtain a part from peers in\\nthe network before it fetches from external storage.\","]
#[doc = "      \"default\": 3,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"location\": {"]
#[doc = "      \"description\": \"Location of state parts.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/ExternalStorageLocation\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"num_concurrent_requests\": {"]
#[doc = "      \"description\": \"When fetching state parts from external storage, throttle fetch requests\\nto this many concurrent requests.\","]
#[doc = "      \"default\": 25,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_concurrent_requests_during_catchup\": {"]
#[doc = "      \"description\": \"During catchup, the node will use a different number of concurrent requests\\nto reduce the performance impact of state sync.\","]
#[doc = "      \"default\": 5,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExternalStorageConfig {
    #[doc = "The number of attempts the node will make to obtain a part from peers in\nthe network before it fetches from external storage."]
    #[serde(default = "defaults::default_u64::<u64, 3>")]
    pub external_storage_fallback_threshold: u64,
    #[doc = "Location of state parts."]
    pub location: ExternalStorageLocation,
    #[doc = "When fetching state parts from external storage, throttle fetch requests\nto this many concurrent requests."]
    #[serde(default = "defaults::default_u64::<u32, 25>")]
    pub num_concurrent_requests: u32,
    #[doc = "During catchup, the node will use a different number of concurrent requests\nto reduce the performance impact of state sync."]
    #[serde(default = "defaults::default_u64::<u32, 5>")]
    pub num_concurrent_requests_during_catchup: u32,
}
impl ::std::convert::From<&ExternalStorageConfig> for ExternalStorageConfig {
    fn from(value: &ExternalStorageConfig) -> Self {
        value.clone()
    }
}
#[doc = "`ExternalStorageLocation`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"S3\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"S3\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"bucket\","]
#[doc = "            \"region\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"bucket\": {"]
#[doc = "              \"description\": \"Location of state dumps on S3.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"region\": {"]
#[doc = "              \"description\": \"Data may only be available in certain locations.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Filesystem\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Filesystem\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"root_dir\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"root_dir\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"GCS\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"GCS\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"bucket\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"bucket\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum ExternalStorageLocation {
    S3 {
        #[doc = "Location of state dumps on S3."]
        bucket: ::std::string::String,
        #[doc = "Data may only be available in certain locations."]
        region: ::std::string::String,
    },
    Filesystem {
        root_dir: ::std::string::String,
    },
    #[serde(rename = "GCS")]
    Gcs {
        bucket: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for ExternalStorageLocation {
    fn from(value: &ExternalStorageLocation) -> Self {
        value.clone()
    }
}
#[doc = "Costs associated with an object that can only be sent over the network (and executed\nby the receiver).\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\nAnd `execution` fee is burned when the item is being executed."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Costs associated with an object that can only be sent over the network (and executed\\nby the receiver).\\nNOTE: `send_sir` or `send_not_sir` fees are usually burned when the item is being created.\\nAnd `execution` fee is burned when the item is being executed.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"execution\","]
#[doc = "    \"send_not_sir\","]
#[doc = "    \"send_sir\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"execution\": {"]
#[doc = "      \"description\": \"Fee for executing the object.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"send_not_sir\": {"]
#[doc = "      \"description\": \"Fee for sending an object potentially across the shards.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"send_sir\": {"]
#[doc = "      \"description\": \"Fee for sending an object from the sender to itself, guaranteeing that it does not leave\\nthe shard.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Fee {
    #[doc = "Fee for executing the object."]
    pub execution: u64,
    #[doc = "Fee for sending an object potentially across the shards."]
    pub send_not_sir: u64,
    #[doc = "Fee for sending an object from the sender to itself, guaranteeing that it does not leave\nthe shard."]
    pub send_sir: u64,
}
impl ::std::convert::From<&Fee> for Fee {
    fn from(value: &Fee) -> Self {
        value.clone()
    }
}
#[doc = "Execution outcome of the transaction and all the subsequent receipts.\nCould be not finalized yet"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Execution outcome of the transaction and all the subsequent receipts.\\nCould be not finalized yet\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"receipts_outcome\","]
#[doc = "    \"status\","]
#[doc = "    \"transaction\","]
#[doc = "    \"transaction_outcome\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"receipts_outcome\": {"]
#[doc = "      \"description\": \"The execution outcome of receipts.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ExecutionOutcomeWithIdView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"description\": \"Execution status defined by chain.rs:get_final_transaction_result\\nFinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\\nFinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution\\nFinalExecutionStatus::Failure - the result of the first leaf receipt_id\\nFinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/FinalExecutionStatus\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"transaction\": {"]
#[doc = "      \"description\": \"Signed Transaction\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/SignedTransactionView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"transaction_outcome\": {"]
#[doc = "      \"description\": \"The execution outcome of the signed transaction.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/ExecutionOutcomeWithIdView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct FinalExecutionOutcomeView {
    #[doc = "The execution outcome of receipts."]
    pub receipts_outcome: ::std::vec::Vec<ExecutionOutcomeWithIdView>,
    #[doc = "Execution status defined by chain.rs:get_final_transaction_result\nFinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\nFinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution\nFinalExecutionStatus::Failure - the result of the first leaf receipt_id\nFinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id"]
    pub status: FinalExecutionStatus,
    #[doc = "Signed Transaction"]
    pub transaction: SignedTransactionView,
    #[doc = "The execution outcome of the signed transaction."]
    pub transaction_outcome: ExecutionOutcomeWithIdView,
}
impl ::std::convert::From<&FinalExecutionOutcomeView> for FinalExecutionOutcomeView {
    fn from(value: &FinalExecutionOutcomeView) -> Self {
        value.clone()
    }
}
#[doc = "Final execution outcome of the transaction and all of subsequent the receipts. Also includes\nthe generated receipt."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Final execution outcome of the transaction and all of subsequent the receipts. Also includes\\nthe generated receipt.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"receipts\","]
#[doc = "    \"receipts_outcome\","]
#[doc = "    \"status\","]
#[doc = "    \"transaction\","]
#[doc = "    \"transaction_outcome\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"receipts\": {"]
#[doc = "      \"description\": \"Receipts generated from the transaction\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ReceiptView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"receipts_outcome\": {"]
#[doc = "      \"description\": \"The execution outcome of receipts.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ExecutionOutcomeWithIdView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"description\": \"Execution status defined by chain.rs:get_final_transaction_result\\nFinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\\nFinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution\\nFinalExecutionStatus::Failure - the result of the first leaf receipt_id\\nFinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/FinalExecutionStatus\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"transaction\": {"]
#[doc = "      \"description\": \"Signed Transaction\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/SignedTransactionView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"transaction_outcome\": {"]
#[doc = "      \"description\": \"The execution outcome of the signed transaction.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/ExecutionOutcomeWithIdView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct FinalExecutionOutcomeWithReceiptView {
    #[doc = "Receipts generated from the transaction"]
    pub receipts: ::std::vec::Vec<ReceiptView>,
    #[doc = "The execution outcome of receipts."]
    pub receipts_outcome: ::std::vec::Vec<ExecutionOutcomeWithIdView>,
    #[doc = "Execution status defined by chain.rs:get_final_transaction_result\nFinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\nFinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution\nFinalExecutionStatus::Failure - the result of the first leaf receipt_id\nFinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id"]
    pub status: FinalExecutionStatus,
    #[doc = "Signed Transaction"]
    pub transaction: SignedTransactionView,
    #[doc = "The execution outcome of the signed transaction."]
    pub transaction_outcome: ExecutionOutcomeWithIdView,
}
impl ::std::convert::From<&FinalExecutionOutcomeWithReceiptView>
    for FinalExecutionOutcomeWithReceiptView
{
    fn from(value: &FinalExecutionOutcomeWithReceiptView) -> Self {
        value.clone()
    }
}
#[doc = "`FinalExecutionStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"The execution has not yet started.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"NotStarted\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The execution has started and still going.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Started\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The execution has failed with the given error.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Failure\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Failure\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/TxExecutionError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The execution has succeeded and returned some value or an empty vec encoded in base64.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"SuccessValue\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"SuccessValue\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum FinalExecutionStatus {
    #[doc = "The execution has not yet started."]
    NotStarted,
    #[doc = "The execution has started and still going."]
    Started,
    #[doc = "The execution has failed with the given error."]
    Failure(TxExecutionError),
    #[doc = "The execution has succeeded and returned some value or an empty vec encoded in base64."]
    SuccessValue(::std::string::String),
}
impl ::std::convert::From<&Self> for FinalExecutionStatus {
    fn from(value: &FinalExecutionStatus) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<TxExecutionError> for FinalExecutionStatus {
    fn from(value: TxExecutionError) -> Self {
        Self::Failure(value)
    }
}
#[doc = "Different types of finality."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Different types of finality.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"optimistic\","]
#[doc = "    \"near-final\","]
#[doc = "    \"final\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum Finality {
    #[serde(rename = "optimistic")]
    Optimistic,
    #[serde(rename = "near-final")]
    NearFinal,
    #[serde(rename = "final")]
    Final,
}
impl ::std::convert::From<&Self> for Finality {
    fn from(value: &Finality) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for Finality {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Optimistic => write!(f, "optimistic"),
            Self::NearFinal => write!(f, "near-final"),
            Self::Final => write!(f, "final"),
        }
    }
}
impl ::std::str::FromStr for Finality {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "optimistic" => Ok(Self::Optimistic),
            "near-final" => Ok(Self::NearFinal),
            "final" => Ok(Self::Final),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for Finality {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Finality {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Finality {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "This type is used to mark function arguments.\n\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\ntransparently serialized and deserialized as a base64-encoded string when serde is used\n(serde_json)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"This type is used to mark function arguments.\\n\\nNOTE: The main reason for this to exist (except the type-safety) is that the value is\\ntransparently serialized and deserialized as a base64-encoded string when serde is used\\n(serde_json).\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"format\": \"bytes\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct FunctionArgs(pub ::std::string::String);
impl ::std::ops::Deref for FunctionArgs {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<FunctionArgs> for ::std::string::String {
    fn from(value: FunctionArgs) -> Self {
        value.0
    }
}
impl ::std::convert::From<&FunctionArgs> for FunctionArgs {
    fn from(value: &FunctionArgs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for FunctionArgs {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for FunctionArgs {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for FunctionArgs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`FunctionCallAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"args\","]
#[doc = "    \"deposit\","]
#[doc = "    \"gas\","]
#[doc = "    \"method_name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"args\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"deposit\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"gas\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"method_name\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct FunctionCallAction {
    pub args: ::std::string::String,
    pub deposit: ::std::string::String,
    pub gas: u64,
    pub method_name: ::std::string::String,
}
impl ::std::convert::From<&FunctionCallAction> for FunctionCallAction {
    fn from(value: &FunctionCallAction) -> Self {
        value.clone()
    }
}
#[doc = "Serializable version of `near-vm-runner::FunctionCallError`.\n\nMust never reorder/remove elements, can only add new variants at the end (but do that very\ncarefully). It describes stable serialization format, and only used by serialization logic."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Serializable version of `near-vm-runner::FunctionCallError`.\\n\\nMust never reorder/remove elements, can only add new variants at the end (but do that very\\ncarefully). It describes stable serialization format, and only used by serialization logic.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"WasmUnknownError\","]
#[doc = "        \"_EVMError\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Wasm compilation error\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"CompilationError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"CompilationError\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CompilationError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Wasm binary env link error\\n\\nNote: this is only to deserialize old data, use execution error for new data\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"LinkError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"LinkError\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"msg\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"msg\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Import/export resolve error\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"MethodResolveError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"MethodResolveError\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/MethodResolveError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"A trap happened during execution of a binary\\n\\nNote: this is only to deserialize old data, use execution error for new data\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"WasmTrap\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"WasmTrap\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/WasmTrap\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Note: this is only to deserialize old data, use execution error for new data\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"HostError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"HostError\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/HostError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ExecutionError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ExecutionError\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum FunctionCallError {
    WasmUnknownError,
    #[serde(rename = "_EVMError")]
    EvmError,
    #[doc = "Wasm compilation error"]
    CompilationError(CompilationError),
    #[doc = "Wasm binary env link error\n\nNote: this is only to deserialize old data, use execution error for new data"]
    LinkError {
        msg: ::std::string::String,
    },
    #[doc = "Import/export resolve error"]
    MethodResolveError(MethodResolveError),
    #[doc = "A trap happened during execution of a binary\n\nNote: this is only to deserialize old data, use execution error for new data"]
    WasmTrap(WasmTrap),
    #[doc = "Note: this is only to deserialize old data, use execution error for new data"]
    HostError(HostError),
    ExecutionError(::std::string::String),
}
impl ::std::convert::From<&Self> for FunctionCallError {
    fn from(value: &FunctionCallError) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<CompilationError> for FunctionCallError {
    fn from(value: CompilationError) -> Self {
        Self::CompilationError(value)
    }
}
impl ::std::convert::From<MethodResolveError> for FunctionCallError {
    fn from(value: MethodResolveError) -> Self {
        Self::MethodResolveError(value)
    }
}
impl ::std::convert::From<WasmTrap> for FunctionCallError {
    fn from(value: WasmTrap) -> Self {
        Self::WasmTrap(value)
    }
}
impl ::std::convert::From<HostError> for FunctionCallError {
    fn from(value: HostError) -> Self {
        Self::HostError(value)
    }
}
#[doc = "Grants limited permission to make transactions with FunctionCallActions\nThe permission can limit the allowed balance to be spent on the prepaid gas.\nIt also restrict the account ID of the receiver for this function call.\nIt also can restrict the method name for the allowed function calls."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Grants limited permission to make transactions with FunctionCallActions\\nThe permission can limit the allowed balance to be spent on the prepaid gas.\\nIt also restrict the account ID of the receiver for this function call.\\nIt also can restrict the method name for the allowed function calls.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"method_names\","]
#[doc = "    \"receiver_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"allowance\": {"]
#[doc = "      \"description\": \"Allowance is a balance limit to use by this access key to pay for function call gas and\\ntransaction fees. When this access key is used, both account balance and the allowance is\\ndecreased by the same value.\\n`None` means unlimited allowance.\\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\\naccess key should be created.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"method_names\": {"]
#[doc = "      \"description\": \"A list of method names that can be used. The access key only allows transactions with the\\nfunction call of one of the given method names.\\nEmpty list means any method name can be used.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"receiver_id\": {"]
#[doc = "      \"description\": \"The access key only allows transactions with the given receiver's account id.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct FunctionCallPermission {
    #[doc = "Allowance is a balance limit to use by this access key to pay for function call gas and\ntransaction fees. When this access key is used, both account balance and the allowance is\ndecreased by the same value.\n`None` means unlimited allowance.\nNOTE: To change or increase the allowance, the old access key needs to be deleted and a new\naccess key should be created."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub allowance: ::std::option::Option<::std::string::String>,
    #[doc = "A list of method names that can be used. The access key only allows transactions with the\nfunction call of one of the given method names.\nEmpty list means any method name can be used."]
    pub method_names: ::std::vec::Vec<::std::string::String>,
    #[doc = "The access key only allows transactions with the given receiver's account id."]
    pub receiver_id: ::std::string::String,
}
impl ::std::convert::From<&FunctionCallPermission> for FunctionCallPermission {
    fn from(value: &FunctionCallPermission) -> Self {
        value.clone()
    }
}
#[doc = "`GasKeyView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"balance\","]
#[doc = "    \"num_nonces\","]
#[doc = "    \"permission\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"balance\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint128\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_nonces\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"permission\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccessKeyPermissionView\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GasKeyView {
    pub balance: u64,
    pub num_nonces: u32,
    pub permission: AccessKeyPermissionView,
}
impl ::std::convert::From<&GasKeyView> for GasKeyView {
    fn from(value: &GasKeyView) -> Self {
        value.clone()
    }
}
#[doc = "Configuration for garbage collection."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Configuration for garbage collection.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"gc_blocks_limit\": {"]
#[doc = "      \"description\": \"Maximum number of blocks to garbage collect at every garbage collection\\ncall.\","]
#[doc = "      \"default\": 2,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"gc_fork_clean_step\": {"]
#[doc = "      \"description\": \"Maximum number of height to go through at each garbage collection step\\nwhen cleaning forks during garbage collection.\","]
#[doc = "      \"default\": 100,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"gc_num_epochs_to_keep\": {"]
#[doc = "      \"description\": \"Number of epochs for which we keep store data.\","]
#[doc = "      \"default\": 5,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"gc_step_period\": {"]
#[doc = "      \"description\": \"How often gc should be run\","]
#[doc = "      \"default\": {"]
#[doc = "        \"nanos\": 500000000,"]
#[doc = "        \"secs\": 0"]
#[doc = "      },"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/DurationAsStdSchemaProvider\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GcConfig {
    #[doc = "Maximum number of blocks to garbage collect at every garbage collection\ncall."]
    #[serde(default = "defaults::default_u64::<u64, 2>")]
    pub gc_blocks_limit: u64,
    #[doc = "Maximum number of height to go through at each garbage collection step\nwhen cleaning forks during garbage collection."]
    #[serde(default = "defaults::default_u64::<u64, 100>")]
    pub gc_fork_clean_step: u64,
    #[doc = "Number of epochs for which we keep store data."]
    #[serde(default = "defaults::default_u64::<u64, 5>")]
    pub gc_num_epochs_to_keep: u64,
    #[doc = "How often gc should be run"]
    #[serde(default = "defaults::gc_config_gc_step_period")]
    pub gc_step_period: DurationAsStdSchemaProvider,
}
impl ::std::convert::From<&GcConfig> for GcConfig {
    fn from(value: &GcConfig) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for GcConfig {
    fn default() -> Self {
        Self {
            gc_blocks_limit: defaults::default_u64::<u64, 2>(),
            gc_fork_clean_step: defaults::default_u64::<u64, 100>(),
            gc_num_epochs_to_keep: defaults::default_u64::<u64, 5>(),
            gc_step_period: defaults::gc_config_gc_step_period(),
        }
    }
}
#[doc = "`GenesisConfig`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"avg_hidden_validator_seats_per_shard\","]
#[doc = "    \"block_producer_kickout_threshold\","]
#[doc = "    \"chain_id\","]
#[doc = "    \"chunk_producer_kickout_threshold\","]
#[doc = "    \"dynamic_resharding\","]
#[doc = "    \"epoch_length\","]
#[doc = "    \"fishermen_threshold\","]
#[doc = "    \"gas_limit\","]
#[doc = "    \"gas_price_adjustment_rate\","]
#[doc = "    \"genesis_height\","]
#[doc = "    \"genesis_time\","]
#[doc = "    \"max_gas_price\","]
#[doc = "    \"max_inflation_rate\","]
#[doc = "    \"min_gas_price\","]
#[doc = "    \"num_block_producer_seats\","]
#[doc = "    \"num_block_producer_seats_per_shard\","]
#[doc = "    \"num_blocks_per_year\","]
#[doc = "    \"protocol_reward_rate\","]
#[doc = "    \"protocol_treasury_account\","]
#[doc = "    \"protocol_version\","]
#[doc = "    \"total_supply\","]
#[doc = "    \"transaction_validity_period\","]
#[doc = "    \"validators\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"avg_hidden_validator_seats_per_shard\": {"]
#[doc = "      \"description\": \"Expected number of hidden validators per shard.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"block_producer_kickout_threshold\": {"]
#[doc = "      \"description\": \"Threshold for kicking out block producers, between 0 and 100.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint8\","]
#[doc = "      \"maximum\": 255.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"chain_id\": {"]
#[doc = "      \"description\": \"ID of the blockchain. This must be unique for every blockchain.\\nIf your testnet blockchains do not have unique chain IDs, you will have a bad time.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"chunk_producer_assignment_changes_limit\": {"]
#[doc = "      \"description\": \"Limits the number of shard changes in chunk producer assignments,\\nif algorithm is able to choose assignment with better balance of\\nnumber of chunk producers for shards.\","]
#[doc = "      \"default\": 5,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"chunk_producer_kickout_threshold\": {"]
#[doc = "      \"description\": \"Threshold for kicking out chunk producers, between 0 and 100.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint8\","]
#[doc = "      \"maximum\": 255.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"chunk_validator_only_kickout_threshold\": {"]
#[doc = "      \"description\": \"Threshold for kicking out nodes which are only chunk validators, between 0 and 100.\","]
#[doc = "      \"default\": 80,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint8\","]
#[doc = "      \"maximum\": 255.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"dynamic_resharding\": {"]
#[doc = "      \"description\": \"Enable dynamic re-sharding.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"epoch_length\": {"]
#[doc = "      \"description\": \"Epoch length counted in block heights.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"fishermen_threshold\": {"]
#[doc = "      \"description\": \"Fishermen stake threshold.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"gas_limit\": {"]
#[doc = "      \"description\": \"Initial gas limit.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"gas_price_adjustment_rate\": {"]
#[doc = "      \"description\": \"Gas price adjustment rate\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"genesis_height\": {"]
#[doc = "      \"description\": \"Height of genesis block.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"genesis_time\": {"]
#[doc = "      \"description\": \"Official time of blockchain start.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"max_gas_price\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"max_inflation_rate\": {"]
#[doc = "      \"description\": \"Maximum inflation on the total supply every epoch.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"max_kickout_stake_perc\": {"]
#[doc = "      \"description\": \"Max stake percentage of the validators we will kick out.\","]
#[doc = "      \"default\": 100,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint8\","]
#[doc = "      \"maximum\": 255.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"min_gas_price\": {"]
#[doc = "      \"description\": \"Minimum gas price. It is also the initial gas price.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"minimum_stake_divisor\": {"]
#[doc = "      \"description\": \"The minimum stake required for staking is last seat price divided by this number.\","]
#[doc = "      \"default\": 10,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"minimum_stake_ratio\": {"]
#[doc = "      \"description\": \"The lowest ratio s/s_total any block producer can have.\\nSee <https://github.com/near/NEPs/pull/167> for details\","]
#[doc = "      \"default\": ["]
#[doc = "        1,"]
#[doc = "        6250"]
#[doc = "      ],"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"minimum_validators_per_shard\": {"]
#[doc = "      \"description\": \"The minimum number of validators each shard must have\","]
#[doc = "      \"default\": 1,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_block_producer_seats\": {"]
#[doc = "      \"description\": \"Number of block producer seats at genesis.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_block_producer_seats_per_shard\": {"]
#[doc = "      \"description\": \"Defines number of shards and number of block producer seats per each shard at genesis.\\nNote: not used with protocol_feature_chunk_only_producers -- replaced by minimum_validators_per_shard\\nNote: not used before as all block producers produce chunks for all shards\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"num_blocks_per_year\": {"]
#[doc = "      \"description\": \"Expected number of blocks per year\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_chunk_only_producer_seats\": {"]
#[doc = "      \"description\": \"Deprecated.\","]
#[doc = "      \"default\": 300,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_chunk_producer_seats\": {"]
#[doc = "      \"description\": \"Number of chunk producers.\\nDon't mess it up with chunk-only producers feature which is deprecated.\","]
#[doc = "      \"default\": 100,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_chunk_validator_seats\": {"]
#[doc = "      \"default\": 300,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"online_max_threshold\": {"]
#[doc = "      \"description\": \"Online maximum threshold above which validator gets full reward.\","]
#[doc = "      \"default\": ["]
#[doc = "        99,"]
#[doc = "        100"]
#[doc = "      ],"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"online_min_threshold\": {"]
#[doc = "      \"description\": \"Online minimum threshold below which validator doesn't receive reward.\","]
#[doc = "      \"default\": ["]
#[doc = "        9,"]
#[doc = "        10"]
#[doc = "      ],"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"protocol_reward_rate\": {"]
#[doc = "      \"description\": \"Protocol treasury rate\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"protocol_treasury_account\": {"]
#[doc = "      \"description\": \"Protocol treasury account\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"protocol_upgrade_stake_threshold\": {"]
#[doc = "      \"description\": \"Threshold of stake that needs to indicate that they ready for upgrade.\","]
#[doc = "      \"default\": ["]
#[doc = "        4,"]
#[doc = "        5"]
#[doc = "      ],"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"protocol_version\": {"]
#[doc = "      \"description\": \"Protocol version that this genesis works with.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"shard_layout\": {"]
#[doc = "      \"description\": \"Layout information regarding how to split accounts to shards\","]
#[doc = "      \"default\": {"]
#[doc = "        \"V2\": {"]
#[doc = "          \"boundary_accounts\": [],"]
#[doc = "          \"id_to_index_map\": {"]
#[doc = "            \"0\": 0"]
#[doc = "          },"]
#[doc = "          \"index_to_id_map\": {"]
#[doc = "            \"0\": 0"]
#[doc = "          },"]
#[doc = "          \"shard_ids\": ["]
#[doc = "            0"]
#[doc = "          ],"]
#[doc = "          \"shards_parent_map\": null,"]
#[doc = "          \"shards_split_map\": null,"]
#[doc = "          \"version\": 0"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/ShardLayout\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"shuffle_shard_assignment_for_chunk_producers\": {"]
#[doc = "      \"description\": \"If true, shuffle the chunk producers across shards. In other words, if\\nthe shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents\\nthe set of chunk producers for shard `i`, if this flag were true, the\\nshard assignments might become, for example, `[S_2, S_0, S_3, S_1]`.\","]
#[doc = "      \"default\": false,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"target_validator_mandates_per_shard\": {"]
#[doc = "      \"description\": \"Number of target chunk validator mandates for each shard.\","]
#[doc = "      \"default\": 68,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"total_supply\": {"]
#[doc = "      \"description\": \"Total supply of tokens at genesis.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"transaction_validity_period\": {"]
#[doc = "      \"description\": \"Number of blocks for which a given transaction is valid\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"use_production_config\": {"]
#[doc = "      \"description\": \"This is only for test purposes. We hard code some configs for mainnet and testnet\\nin AllEpochConfig, and we want to have a way to test that code path. This flag is for that.\\nIf set to true, the node will use the same config override path as mainnet and testnet.\","]
#[doc = "      \"default\": false,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"validators\": {"]
#[doc = "      \"description\": \"List of initial validators.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/AccountInfo\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GenesisConfig {
    #[doc = "Expected number of hidden validators per shard."]
    pub avg_hidden_validator_seats_per_shard: ::std::vec::Vec<u64>,
    #[doc = "Threshold for kicking out block producers, between 0 and 100."]
    pub block_producer_kickout_threshold: u8,
    #[doc = "ID of the blockchain. This must be unique for every blockchain.\nIf your testnet blockchains do not have unique chain IDs, you will have a bad time."]
    pub chain_id: ::std::string::String,
    #[doc = "Limits the number of shard changes in chunk producer assignments,\nif algorithm is able to choose assignment with better balance of\nnumber of chunk producers for shards."]
    #[serde(default = "defaults::default_u64::<u64, 5>")]
    pub chunk_producer_assignment_changes_limit: u64,
    #[doc = "Threshold for kicking out chunk producers, between 0 and 100."]
    pub chunk_producer_kickout_threshold: u8,
    #[doc = "Threshold for kicking out nodes which are only chunk validators, between 0 and 100."]
    #[serde(default = "defaults::default_u64::<u8, 80>")]
    pub chunk_validator_only_kickout_threshold: u8,
    #[doc = "Enable dynamic re-sharding."]
    pub dynamic_resharding: bool,
    #[doc = "Epoch length counted in block heights."]
    pub epoch_length: u64,
    #[doc = "Fishermen stake threshold."]
    pub fishermen_threshold: ::std::string::String,
    #[doc = "Initial gas limit."]
    pub gas_limit: u64,
    #[doc = "Gas price adjustment rate"]
    pub gas_price_adjustment_rate: [i32; 2usize],
    #[doc = "Height of genesis block."]
    pub genesis_height: u64,
    #[doc = "Official time of blockchain start."]
    pub genesis_time: ::chrono::DateTime<::chrono::offset::Utc>,
    pub max_gas_price: ::std::string::String,
    #[doc = "Maximum inflation on the total supply every epoch."]
    pub max_inflation_rate: [i32; 2usize],
    #[doc = "Max stake percentage of the validators we will kick out."]
    #[serde(default = "defaults::default_u64::<u8, 100>")]
    pub max_kickout_stake_perc: u8,
    #[doc = "Minimum gas price. It is also the initial gas price."]
    pub min_gas_price: ::std::string::String,
    #[doc = "The minimum stake required for staking is last seat price divided by this number."]
    #[serde(default = "defaults::default_u64::<u64, 10>")]
    pub minimum_stake_divisor: u64,
    #[doc = "The lowest ratio s/s_total any block producer can have.\nSee <https://github.com/near/NEPs/pull/167> for details"]
    #[serde(default = "defaults::genesis_config_minimum_stake_ratio")]
    pub minimum_stake_ratio: [i32; 2usize],
    #[doc = "The minimum number of validators each shard must have"]
    #[serde(default = "defaults::default_u64::<u64, 1>")]
    pub minimum_validators_per_shard: u64,
    #[doc = "Number of block producer seats at genesis."]
    pub num_block_producer_seats: u64,
    #[doc = "Defines number of shards and number of block producer seats per each shard at genesis.\nNote: not used with protocol_feature_chunk_only_producers -- replaced by minimum_validators_per_shard\nNote: not used before as all block producers produce chunks for all shards"]
    pub num_block_producer_seats_per_shard: ::std::vec::Vec<u64>,
    #[doc = "Expected number of blocks per year"]
    pub num_blocks_per_year: u64,
    #[doc = "Deprecated."]
    #[serde(default = "defaults::default_u64::<u64, 300>")]
    pub num_chunk_only_producer_seats: u64,
    #[doc = "Number of chunk producers.\nDon't mess it up with chunk-only producers feature which is deprecated."]
    #[serde(default = "defaults::default_u64::<u64, 100>")]
    pub num_chunk_producer_seats: u64,
    #[serde(default = "defaults::default_u64::<u64, 300>")]
    pub num_chunk_validator_seats: u64,
    #[doc = "Online maximum threshold above which validator gets full reward."]
    #[serde(default = "defaults::genesis_config_online_max_threshold")]
    pub online_max_threshold: [i32; 2usize],
    #[doc = "Online minimum threshold below which validator doesn't receive reward."]
    #[serde(default = "defaults::genesis_config_online_min_threshold")]
    pub online_min_threshold: [i32; 2usize],
    #[doc = "Protocol treasury rate"]
    pub protocol_reward_rate: [i32; 2usize],
    #[doc = "Protocol treasury account"]
    pub protocol_treasury_account: AccountId,
    #[doc = "Threshold of stake that needs to indicate that they ready for upgrade."]
    #[serde(default = "defaults::genesis_config_protocol_upgrade_stake_threshold")]
    pub protocol_upgrade_stake_threshold: [i32; 2usize],
    #[doc = "Protocol version that this genesis works with."]
    pub protocol_version: u32,
    #[doc = "Layout information regarding how to split accounts to shards"]
    #[serde(default = "defaults::genesis_config_shard_layout")]
    pub shard_layout: ShardLayout,
    #[doc = "If true, shuffle the chunk producers across shards. In other words, if\nthe shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents\nthe set of chunk producers for shard `i`, if this flag were true, the\nshard assignments might become, for example, `[S_2, S_0, S_3, S_1]`."]
    #[serde(default)]
    pub shuffle_shard_assignment_for_chunk_producers: bool,
    #[doc = "Number of target chunk validator mandates for each shard."]
    #[serde(default = "defaults::default_u64::<u64, 68>")]
    pub target_validator_mandates_per_shard: u64,
    #[doc = "Total supply of tokens at genesis."]
    pub total_supply: ::std::string::String,
    #[doc = "Number of blocks for which a given transaction is valid"]
    pub transaction_validity_period: u64,
    #[doc = "This is only for test purposes. We hard code some configs for mainnet and testnet\nin AllEpochConfig, and we want to have a way to test that code path. This flag is for that.\nIf set to true, the node will use the same config override path as mainnet and testnet."]
    #[serde(default)]
    pub use_production_config: bool,
    #[doc = "List of initial validators."]
    pub validators: ::std::vec::Vec<AccountInfo>,
}
impl ::std::convert::From<&GenesisConfig> for GenesisConfig {
    fn from(value: &GenesisConfig) -> Self {
        value.clone()
    }
}
#[doc = "`GenesisConfigRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"GenesisConfigRequest\","]
#[doc = "  \"type\": \"null\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct GenesisConfigRequest(pub ());
impl ::std::ops::Deref for GenesisConfigRequest {
    type Target = ();
    fn deref(&self) -> &() {
        &self.0
    }
}
impl ::std::convert::From<GenesisConfigRequest> for () {
    fn from(value: GenesisConfigRequest) -> Self {
        value.0
    }
}
impl ::std::convert::From<&GenesisConfigRequest> for GenesisConfigRequest {
    fn from(value: &GenesisConfigRequest) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<()> for GenesisConfigRequest {
    fn from(value: ()) -> Self {
        Self(value)
    }
}
#[doc = "`GlobalContractDeployMode`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"Contract is deployed under its code hash.\\nUsers will be able reference it by that hash.\\nThis effectively makes the contract immutable.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"CodeHash\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Contract is deployed under the owner account id.\\nUsers will be able reference it by that account id.\\nThis allows the owner to update the contract for all its users.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"AccountId\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum GlobalContractDeployMode {
    #[doc = "Contract is deployed under its code hash.\nUsers will be able reference it by that hash.\nThis effectively makes the contract immutable."]
    CodeHash,
    #[doc = "Contract is deployed under the owner account id.\nUsers will be able reference it by that account id.\nThis allows the owner to update the contract for all its users."]
    AccountId,
}
impl ::std::convert::From<&Self> for GlobalContractDeployMode {
    fn from(value: &GlobalContractDeployMode) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for GlobalContractDeployMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::CodeHash => write!(f, "CodeHash"),
            Self::AccountId => write!(f, "AccountId"),
        }
    }
}
impl ::std::str::FromStr for GlobalContractDeployMode {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "CodeHash" => Ok(Self::CodeHash),
            "AccountId" => Ok(Self::AccountId),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for GlobalContractDeployMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for GlobalContractDeployMode {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for GlobalContractDeployMode {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`GlobalContractIdentifier`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"CodeHash\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"CodeHash\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"AccountId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"AccountId\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum GlobalContractIdentifier {
    CodeHash(CryptoHash),
    AccountId(AccountId),
}
impl ::std::convert::From<&Self> for GlobalContractIdentifier {
    fn from(value: &GlobalContractIdentifier) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<CryptoHash> for GlobalContractIdentifier {
    fn from(value: CryptoHash) -> Self {
        Self::CodeHash(value)
    }
}
impl ::std::convert::From<AccountId> for GlobalContractIdentifier {
    fn from(value: AccountId) -> Self {
        Self::AccountId(value)
    }
}
#[doc = "`HostError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"String encoding is bad UTF-16 sequence\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"BadUTF16\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"String encoding is bad UTF-8 sequence\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"BadUTF8\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Exceeded the prepaid gas\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"GasExceeded\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Exceeded the maximum amount of gas allowed to burn per contract\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"GasLimitExceeded\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Exceeded the account balance\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"BalanceExceeded\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Tried to call an empty method name\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EmptyMethodName\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Smart contract panicked\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"GuestPanic\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"GuestPanic\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"panic_msg\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"panic_msg\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"IntegerOverflow happened during a contract execution\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"IntegerOverflow\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"`promise_idx` does not correspond to existing promises\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidPromiseIndex\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidPromiseIndex\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"promise_idx\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"promise_idx\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Actions can only be appended to non-joint promise.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"CannotAppendActionToJointPromise\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Returning joint promise is currently prohibited\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"CannotReturnJointPromise\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Accessed invalid promise result index\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidPromiseResultIndex\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidPromiseResultIndex\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"result_idx\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"result_idx\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Accessed invalid register id\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidRegisterId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidRegisterId\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"register_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"register_id\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"IteratorWasInvalidated\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"IteratorWasInvalidated\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"iterator_index\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"iterator_index\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Accessed memory outside the bounds\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"MemoryAccessViolation\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"VM Logic returned an invalid receipt index\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidReceiptIndex\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidReceiptIndex\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"receipt_index\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"receipt_index\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Iterator index `iterator_index` does not exist\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidIteratorIndex\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidIteratorIndex\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"iterator_index\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"iterator_index\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"VM Logic returned an invalid account id\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"InvalidAccountId\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"VM Logic returned an invalid method name\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"InvalidMethodName\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"VM Logic provided an invalid public key\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"InvalidPublicKey\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"`method_name` is not allowed in view calls\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ProhibitedInView\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ProhibitedInView\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"method_name\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"method_name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The total number of logs will exceed the limit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"NumberOfLogsExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"NumberOfLogsExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"limit\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The storage key length exceeded the limit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"KeyLengthExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"KeyLengthExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"length\","]
#[doc = "            \"limit\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"length\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The storage value length exceeded the limit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ValueLengthExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ValueLengthExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"length\","]
#[doc = "            \"limit\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"length\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The total log length exceeded the limit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"TotalLogLengthExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"TotalLogLengthExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"length\","]
#[doc = "            \"limit\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"length\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The maximum number of promises within a FunctionCall exceeded the limit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"NumberPromisesExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"NumberPromisesExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"limit\","]
#[doc = "            \"number_of_promises\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"number_of_promises\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The maximum number of input data dependencies exceeded the limit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"NumberInputDataDependenciesExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"NumberInputDataDependenciesExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"limit\","]
#[doc = "            \"number_of_input_data_dependencies\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"number_of_input_data_dependencies\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The returned value length exceeded the limit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ReturnedValueLengthExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ReturnedValueLengthExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"length\","]
#[doc = "            \"limit\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"length\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The contract size for DeployContract action exceeded the limit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ContractSizeExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ContractSizeExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"limit\","]
#[doc = "            \"size\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"size\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The host function was deprecated.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Deprecated\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Deprecated\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"method_name\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"method_name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"General errors for ECDSA recover.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ECRecoverError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ECRecoverError\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"msg\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"msg\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Invalid input to alt_bn128 family of functions (e.g., point which isn't\\non the curve).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"AltBn128InvalidInput\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"AltBn128InvalidInput\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"msg\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"msg\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Invalid input to ed25519 signature verification function (e.g. signature cannot be\\nderived from bytes).\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Ed25519VerifyInvalidInput\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Ed25519VerifyInvalidInput\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"msg\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"msg\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum HostError {
    #[doc = "String encoding is bad UTF-16 sequence"]
    #[serde(rename = "BadUTF16")]
    BadUtf16,
    #[doc = "String encoding is bad UTF-8 sequence"]
    #[serde(rename = "BadUTF8")]
    BadUtf8,
    #[doc = "Exceeded the prepaid gas"]
    GasExceeded,
    #[doc = "Exceeded the maximum amount of gas allowed to burn per contract"]
    GasLimitExceeded,
    #[doc = "Exceeded the account balance"]
    BalanceExceeded,
    #[doc = "Tried to call an empty method name"]
    EmptyMethodName,
    #[doc = "Smart contract panicked"]
    GuestPanic { panic_msg: ::std::string::String },
    #[doc = "IntegerOverflow happened during a contract execution"]
    IntegerOverflow,
    #[doc = "`promise_idx` does not correspond to existing promises"]
    InvalidPromiseIndex { promise_idx: u64 },
    #[doc = "Actions can only be appended to non-joint promise."]
    CannotAppendActionToJointPromise,
    #[doc = "Returning joint promise is currently prohibited"]
    CannotReturnJointPromise,
    #[doc = "Accessed invalid promise result index"]
    InvalidPromiseResultIndex { result_idx: u64 },
    #[doc = "Accessed invalid register id"]
    InvalidRegisterId { register_id: u64 },
    #[doc = "Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie"]
    IteratorWasInvalidated { iterator_index: u64 },
    #[doc = "Accessed memory outside the bounds"]
    MemoryAccessViolation,
    #[doc = "VM Logic returned an invalid receipt index"]
    InvalidReceiptIndex { receipt_index: u64 },
    #[doc = "Iterator index `iterator_index` does not exist"]
    InvalidIteratorIndex { iterator_index: u64 },
    #[doc = "VM Logic returned an invalid account id"]
    InvalidAccountId,
    #[doc = "VM Logic returned an invalid method name"]
    InvalidMethodName,
    #[doc = "VM Logic provided an invalid public key"]
    InvalidPublicKey,
    #[doc = "`method_name` is not allowed in view calls"]
    ProhibitedInView { method_name: ::std::string::String },
    #[doc = "The total number of logs will exceed the limit."]
    NumberOfLogsExceeded { limit: u64 },
    #[doc = "The storage key length exceeded the limit."]
    KeyLengthExceeded { length: u64, limit: u64 },
    #[doc = "The storage value length exceeded the limit."]
    ValueLengthExceeded { length: u64, limit: u64 },
    #[doc = "The total log length exceeded the limit."]
    TotalLogLengthExceeded { length: u64, limit: u64 },
    #[doc = "The maximum number of promises within a FunctionCall exceeded the limit."]
    NumberPromisesExceeded { limit: u64, number_of_promises: u64 },
    #[doc = "The maximum number of input data dependencies exceeded the limit."]
    NumberInputDataDependenciesExceeded {
        limit: u64,
        number_of_input_data_dependencies: u64,
    },
    #[doc = "The returned value length exceeded the limit."]
    ReturnedValueLengthExceeded { length: u64, limit: u64 },
    #[doc = "The contract size for DeployContract action exceeded the limit."]
    ContractSizeExceeded { limit: u64, size: u64 },
    #[doc = "The host function was deprecated."]
    Deprecated { method_name: ::std::string::String },
    #[doc = "General errors for ECDSA recover."]
    #[serde(rename = "ECRecoverError")]
    EcRecoverError { msg: ::std::string::String },
    #[doc = "Invalid input to alt_bn128 family of functions (e.g., point which isn't\non the curve)."]
    AltBn128InvalidInput { msg: ::std::string::String },
    #[doc = "Invalid input to ed25519 signature verification function (e.g. signature cannot be\nderived from bytes)."]
    Ed25519VerifyInvalidInput { msg: ::std::string::String },
}
impl ::std::convert::From<&Self> for HostError {
    fn from(value: &HostError) -> Self {
        value.clone()
    }
}
#[doc = "`InvalidAccessKeyError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"The access key identified by the `public_key` doesn't exist for the account\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"AccessKeyNotFound\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"AccessKeyNotFound\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"public_key\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction `receiver_id` doesn't match the access key receiver_id\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ReceiverMismatch\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ReceiverMismatch\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"ak_receiver\","]
#[doc = "            \"tx_receiver\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"ak_receiver\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"tx_receiver\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction method name isn't allowed by the access key\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"MethodNameMismatch\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"MethodNameMismatch\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"method_name\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"method_name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction requires a full permission access key.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"RequiresFullAccess\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Access Key does not have enough allowance to cover transaction cost\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"NotEnoughAllowance\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"NotEnoughAllowance\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"allowance\","]
#[doc = "            \"cost\","]
#[doc = "            \"public_key\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"allowance\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"cost\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Having a deposit with a function call action is not allowed with a function call access key.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"DepositWithFunctionCall\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum InvalidAccessKeyError {
    #[doc = "The access key identified by the `public_key` doesn't exist for the account"]
    AccessKeyNotFound {
        account_id: AccountId,
        public_key: PublicKey,
    },
    #[doc = "Transaction `receiver_id` doesn't match the access key receiver_id"]
    ReceiverMismatch {
        ak_receiver: ::std::string::String,
        tx_receiver: AccountId,
    },
    #[doc = "Transaction method name isn't allowed by the access key"]
    MethodNameMismatch { method_name: ::std::string::String },
    #[doc = "Transaction requires a full permission access key."]
    RequiresFullAccess,
    #[doc = "Access Key does not have enough allowance to cover transaction cost"]
    NotEnoughAllowance {
        account_id: AccountId,
        allowance: ::std::string::String,
        cost: ::std::string::String,
        public_key: PublicKey,
    },
    #[doc = "Having a deposit with a function call action is not allowed with a function call access key."]
    DepositWithFunctionCall,
}
impl ::std::convert::From<&Self> for InvalidAccessKeyError {
    fn from(value: &InvalidAccessKeyError) -> Self {
        value.clone()
    }
}
#[doc = "An error happened during TX execution"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An error happened during TX execution\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"Happens if a wrong AccessKey used or AccessKey has not enough permissions\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidAccessKeyError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidAccessKeyError\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/InvalidAccessKeyError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"TX signer_id is not a valid [`AccountId`]\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidSignerId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidSignerId\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"signer_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"signer_id\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"TX signer_id is not found in a storage\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"SignerDoesNotExist\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"SignerDoesNotExist\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"signer_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"signer_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction nonce must be strictly greater than `account[access_key].nonce`.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidNonce\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidNonce\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"ak_nonce\","]
#[doc = "            \"tx_nonce\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"ak_nonce\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"tx_nonce\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction nonce is larger than the upper bound given by the block height\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"NonceTooLarge\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"NonceTooLarge\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"tx_nonce\","]
#[doc = "            \"upper_bound\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"tx_nonce\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"upper_bound\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"TX receiver_id is not a valid AccountId\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidReceiverId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidReceiverId\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"receiver_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"receiver_id\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"TX signature is not valid\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"InvalidSignature\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Account does not have enough balance to cover TX cost\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"NotEnoughBalance\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"NotEnoughBalance\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"balance\","]
#[doc = "            \"cost\","]
#[doc = "            \"signer_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"balance\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"cost\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"signer_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Signer account doesn't have enough balance after transaction.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"LackBalanceForState\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"LackBalanceForState\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"amount\","]
#[doc = "            \"signer_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"amount\": {"]
#[doc = "              \"description\": \"Required balance to cover the state.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"signer_id\": {"]
#[doc = "              \"description\": \"An account which doesn't have enough balance to cover storage.\","]
#[doc = "              \"allOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"An integer overflow occurred during transaction cost estimation.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"CostOverflow\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction parent block hash doesn't belong to the current chain\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"InvalidChain\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction has expired\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Expired\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"An error occurred while validating actions of a Transaction.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ActionsValidation\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ActionsValidation\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/ActionsValidationError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The size of serialized transaction exceeded the limit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"TransactionSizeExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"TransactionSizeExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"limit\","]
#[doc = "            \"size\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"size\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction version is invalid.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"InvalidTransactionVersion\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"StorageError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"StorageError\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/StorageError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The receiver shard of the transaction is too congested to accept new\\ntransactions at the moment.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ShardCongested\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ShardCongested\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"congestion_level\","]
#[doc = "            \"shard_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"congestion_level\": {"]
#[doc = "              \"description\": \"A value between 0 (no congestion) and 1 (max congestion).\","]
#[doc = "              \"type\": \"number\","]
#[doc = "              \"format\": \"double\""]
#[doc = "            },"]
#[doc = "            \"shard_id\": {"]
#[doc = "              \"description\": \"The congested shard.\","]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint32\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The receiver shard of the transaction missed several chunks and rejects\\nnew transaction until it can make progress again.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ShardStuck\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ShardStuck\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"missed_chunks\","]
#[doc = "            \"shard_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"missed_chunks\": {"]
#[doc = "              \"description\": \"The number of blocks since the last included chunk of the shard.\","]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"shard_id\": {"]
#[doc = "              \"description\": \"The shard that fails making progress.\","]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint32\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum InvalidTxError {
    #[doc = "Happens if a wrong AccessKey used or AccessKey has not enough permissions"]
    InvalidAccessKeyError(InvalidAccessKeyError),
    #[doc = "TX signer_id is not a valid [`AccountId`]"]
    InvalidSignerId {
        signer_id: ::std::string::String,
    },
    #[doc = "TX signer_id is not found in a storage"]
    SignerDoesNotExist {
        signer_id: AccountId,
    },
    #[doc = "Transaction nonce must be strictly greater than `account[access_key].nonce`."]
    InvalidNonce {
        ak_nonce: u64,
        tx_nonce: u64,
    },
    #[doc = "Transaction nonce is larger than the upper bound given by the block height"]
    NonceTooLarge {
        tx_nonce: u64,
        upper_bound: u64,
    },
    #[doc = "TX receiver_id is not a valid AccountId"]
    InvalidReceiverId {
        receiver_id: ::std::string::String,
    },
    #[doc = "TX signature is not valid"]
    InvalidSignature,
    #[doc = "Account does not have enough balance to cover TX cost"]
    NotEnoughBalance {
        balance: ::std::string::String,
        cost: ::std::string::String,
        signer_id: AccountId,
    },
    #[doc = "Signer account doesn't have enough balance after transaction."]
    LackBalanceForState {
        #[doc = "Required balance to cover the state."]
        amount: ::std::string::String,
        #[doc = "An account which doesn't have enough balance to cover storage."]
        signer_id: AccountId,
    },
    #[doc = "An integer overflow occurred during transaction cost estimation."]
    CostOverflow,
    #[doc = "Transaction parent block hash doesn't belong to the current chain"]
    InvalidChain,
    #[doc = "Transaction has expired"]
    Expired,
    #[doc = "An error occurred while validating actions of a Transaction."]
    ActionsValidation(ActionsValidationError),
    #[doc = "The size of serialized transaction exceeded the limit."]
    TransactionSizeExceeded {
        limit: u64,
        size: u64,
    },
    #[doc = "Transaction version is invalid."]
    InvalidTransactionVersion,
    StorageError(StorageError),
    #[doc = "The receiver shard of the transaction is too congested to accept new\ntransactions at the moment."]
    ShardCongested {
        congestion_level: f64,
        #[doc = "The congested shard."]
        shard_id: u32,
    },
    #[doc = "The receiver shard of the transaction missed several chunks and rejects\nnew transaction until it can make progress again."]
    ShardStuck {
        #[doc = "The number of blocks since the last included chunk of the shard."]
        missed_chunks: u64,
        #[doc = "The shard that fails making progress."]
        shard_id: u32,
    },
}
impl ::std::convert::From<&Self> for InvalidTxError {
    fn from(value: &InvalidTxError) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<InvalidAccessKeyError> for InvalidTxError {
    fn from(value: InvalidAccessKeyError) -> Self {
        Self::InvalidAccessKeyError(value)
    }
}
impl ::std::convert::From<ActionsValidationError> for InvalidTxError {
    fn from(value: ActionsValidationError) -> Self {
        Self::ActionsValidation(value)
    }
}
impl ::std::convert::From<StorageError> for InvalidTxError {
    fn from(value: StorageError) -> Self {
        Self::StorageError(value)
    }
}
#[doc = "`JsonRpcRequestForBlock`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_block\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"block\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcBlockRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForBlock {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForBlockMethod,
    pub params: RpcBlockRequest,
}
impl ::std::convert::From<&JsonRpcRequestForBlock> for JsonRpcRequestForBlock {
    fn from(value: &JsonRpcRequestForBlock) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForBlockMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"block\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForBlockMethod {
    #[serde(rename = "block")]
    Block,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForBlockMethod {
    fn from(value: &JsonRpcRequestForBlockMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForBlockMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Block => write!(f, "block"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForBlockMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "block" => Ok(Self::Block),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForBlockMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForBlockMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForBlockMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForBroadcastTxAsync`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_broadcast_tx_async\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"broadcast_tx_async\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcSendTransactionRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForBroadcastTxAsync {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForBroadcastTxAsyncMethod,
    pub params: RpcSendTransactionRequest,
}
impl ::std::convert::From<&JsonRpcRequestForBroadcastTxAsync>
    for JsonRpcRequestForBroadcastTxAsync
{
    fn from(value: &JsonRpcRequestForBroadcastTxAsync) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForBroadcastTxAsyncMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"broadcast_tx_async\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForBroadcastTxAsyncMethod {
    #[serde(rename = "broadcast_tx_async")]
    BroadcastTxAsync,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForBroadcastTxAsyncMethod {
    fn from(value: &JsonRpcRequestForBroadcastTxAsyncMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForBroadcastTxAsyncMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::BroadcastTxAsync => write!(f, "broadcast_tx_async"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForBroadcastTxAsyncMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "broadcast_tx_async" => Ok(Self::BroadcastTxAsync),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForBroadcastTxAsyncMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForBroadcastTxAsyncMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForBroadcastTxAsyncMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForBroadcastTxCommit`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_broadcast_tx_commit\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"broadcast_tx_commit\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcSendTransactionRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForBroadcastTxCommit {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForBroadcastTxCommitMethod,
    pub params: RpcSendTransactionRequest,
}
impl ::std::convert::From<&JsonRpcRequestForBroadcastTxCommit>
    for JsonRpcRequestForBroadcastTxCommit
{
    fn from(value: &JsonRpcRequestForBroadcastTxCommit) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForBroadcastTxCommitMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"broadcast_tx_commit\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForBroadcastTxCommitMethod {
    #[serde(rename = "broadcast_tx_commit")]
    BroadcastTxCommit,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForBroadcastTxCommitMethod {
    fn from(value: &JsonRpcRequestForBroadcastTxCommitMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForBroadcastTxCommitMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::BroadcastTxCommit => write!(f, "broadcast_tx_commit"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForBroadcastTxCommitMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "broadcast_tx_commit" => Ok(Self::BroadcastTxCommit),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForBroadcastTxCommitMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForBroadcastTxCommitMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForBroadcastTxCommitMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_changes\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"changes\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcStateChangesInBlockByTypeRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForChanges {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForChangesMethod,
    pub params: RpcStateChangesInBlockByTypeRequest,
}
impl ::std::convert::From<&JsonRpcRequestForChanges> for JsonRpcRequestForChanges {
    fn from(value: &JsonRpcRequestForChanges) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForChangesMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForChangesMethod {
    #[serde(rename = "changes")]
    Changes,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForChangesMethod {
    fn from(value: &JsonRpcRequestForChangesMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForChangesMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Changes => write!(f, "changes"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForChangesMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "changes" => Ok(Self::Changes),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForChangesMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForChangesMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForChangesMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForChunk`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_chunk\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"chunk\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcChunkRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForChunk {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForChunkMethod,
    pub params: RpcChunkRequest,
}
impl ::std::convert::From<&JsonRpcRequestForChunk> for JsonRpcRequestForChunk {
    fn from(value: &JsonRpcRequestForChunk) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForChunkMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"chunk\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForChunkMethod {
    #[serde(rename = "chunk")]
    Chunk,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForChunkMethod {
    fn from(value: &JsonRpcRequestForChunkMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForChunkMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Chunk => write!(f, "chunk"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForChunkMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "chunk" => Ok(Self::Chunk),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForChunkMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForChunkMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForChunkMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForClientConfig`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_client_config\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"client_config\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcClientConfigRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForClientConfig {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForClientConfigMethod,
    pub params: RpcClientConfigRequest,
}
impl ::std::convert::From<&JsonRpcRequestForClientConfig> for JsonRpcRequestForClientConfig {
    fn from(value: &JsonRpcRequestForClientConfig) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForClientConfigMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"client_config\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForClientConfigMethod {
    #[serde(rename = "client_config")]
    ClientConfig,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForClientConfigMethod {
    fn from(value: &JsonRpcRequestForClientConfigMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForClientConfigMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ClientConfig => write!(f, "client_config"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForClientConfigMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "client_config" => Ok(Self::ClientConfig),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForClientConfigMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForClientConfigMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForClientConfigMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForExperimentalChanges`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_EXPERIMENTAL_changes\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXPERIMENTAL_changes\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcStateChangesInBlockByTypeRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForExperimentalChanges {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForExperimentalChangesMethod,
    pub params: RpcStateChangesInBlockByTypeRequest,
}
impl ::std::convert::From<&JsonRpcRequestForExperimentalChanges>
    for JsonRpcRequestForExperimentalChanges
{
    fn from(value: &JsonRpcRequestForExperimentalChanges) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForExperimentalChangesInBlock`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_EXPERIMENTAL_changes_in_block\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXPERIMENTAL_changes_in_block\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcStateChangesInBlockRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForExperimentalChangesInBlock {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForExperimentalChangesInBlockMethod,
    pub params: RpcStateChangesInBlockRequest,
}
impl ::std::convert::From<&JsonRpcRequestForExperimentalChangesInBlock>
    for JsonRpcRequestForExperimentalChangesInBlock
{
    fn from(value: &JsonRpcRequestForExperimentalChangesInBlock) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForExperimentalChangesInBlockMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"EXPERIMENTAL_changes_in_block\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForExperimentalChangesInBlockMethod {
    #[serde(rename = "EXPERIMENTAL_changes_in_block")]
    ExperimentalChangesInBlock,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForExperimentalChangesInBlockMethod {
    fn from(value: &JsonRpcRequestForExperimentalChangesInBlockMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForExperimentalChangesInBlockMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExperimentalChangesInBlock => write!(f, "EXPERIMENTAL_changes_in_block"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForExperimentalChangesInBlockMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "EXPERIMENTAL_changes_in_block" => Ok(Self::ExperimentalChangesInBlock),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForExperimentalChangesInBlockMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JsonRpcRequestForExperimentalChangesInBlockMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for JsonRpcRequestForExperimentalChangesInBlockMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForExperimentalChangesMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"EXPERIMENTAL_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForExperimentalChangesMethod {
    #[serde(rename = "EXPERIMENTAL_changes")]
    ExperimentalChanges,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForExperimentalChangesMethod {
    fn from(value: &JsonRpcRequestForExperimentalChangesMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForExperimentalChangesMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExperimentalChanges => write!(f, "EXPERIMENTAL_changes"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForExperimentalChangesMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "EXPERIMENTAL_changes" => Ok(Self::ExperimentalChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForExperimentalChangesMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JsonRpcRequestForExperimentalChangesMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForExperimentalChangesMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForExperimentalCongestionLevel`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_EXPERIMENTAL_congestion_level\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXPERIMENTAL_congestion_level\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcCongestionLevelRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForExperimentalCongestionLevel {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForExperimentalCongestionLevelMethod,
    pub params: RpcCongestionLevelRequest,
}
impl ::std::convert::From<&JsonRpcRequestForExperimentalCongestionLevel>
    for JsonRpcRequestForExperimentalCongestionLevel
{
    fn from(value: &JsonRpcRequestForExperimentalCongestionLevel) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForExperimentalCongestionLevelMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"EXPERIMENTAL_congestion_level\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForExperimentalCongestionLevelMethod {
    #[serde(rename = "EXPERIMENTAL_congestion_level")]
    ExperimentalCongestionLevel,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForExperimentalCongestionLevelMethod {
    fn from(value: &JsonRpcRequestForExperimentalCongestionLevelMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForExperimentalCongestionLevelMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExperimentalCongestionLevel => write!(f, "EXPERIMENTAL_congestion_level"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForExperimentalCongestionLevelMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "EXPERIMENTAL_congestion_level" => Ok(Self::ExperimentalCongestionLevel),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForExperimentalCongestionLevelMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JsonRpcRequestForExperimentalCongestionLevelMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for JsonRpcRequestForExperimentalCongestionLevelMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForExperimentalGenesisConfig`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_EXPERIMENTAL_genesis_config\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXPERIMENTAL_genesis_config\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/GenesisConfigRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForExperimentalGenesisConfig {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForExperimentalGenesisConfigMethod,
    pub params: GenesisConfigRequest,
}
impl ::std::convert::From<&JsonRpcRequestForExperimentalGenesisConfig>
    for JsonRpcRequestForExperimentalGenesisConfig
{
    fn from(value: &JsonRpcRequestForExperimentalGenesisConfig) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForExperimentalGenesisConfigMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"EXPERIMENTAL_genesis_config\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForExperimentalGenesisConfigMethod {
    #[serde(rename = "EXPERIMENTAL_genesis_config")]
    ExperimentalGenesisConfig,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForExperimentalGenesisConfigMethod {
    fn from(value: &JsonRpcRequestForExperimentalGenesisConfigMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForExperimentalGenesisConfigMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExperimentalGenesisConfig => write!(f, "EXPERIMENTAL_genesis_config"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForExperimentalGenesisConfigMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "EXPERIMENTAL_genesis_config" => Ok(Self::ExperimentalGenesisConfig),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForExperimentalGenesisConfigMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JsonRpcRequestForExperimentalGenesisConfigMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for JsonRpcRequestForExperimentalGenesisConfigMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForExperimentalLightClientBlockProof`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_EXPERIMENTAL_light_client_block_proof\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXPERIMENTAL_light_client_block_proof\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcLightClientBlockProofRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForExperimentalLightClientBlockProof {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForExperimentalLightClientBlockProofMethod,
    pub params: RpcLightClientBlockProofRequest,
}
impl ::std::convert::From<&JsonRpcRequestForExperimentalLightClientBlockProof>
    for JsonRpcRequestForExperimentalLightClientBlockProof
{
    fn from(value: &JsonRpcRequestForExperimentalLightClientBlockProof) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForExperimentalLightClientBlockProofMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"EXPERIMENTAL_light_client_block_proof\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForExperimentalLightClientBlockProofMethod {
    #[serde(rename = "EXPERIMENTAL_light_client_block_proof")]
    ExperimentalLightClientBlockProof,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForExperimentalLightClientBlockProofMethod {
    fn from(value: &JsonRpcRequestForExperimentalLightClientBlockProofMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForExperimentalLightClientBlockProofMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExperimentalLightClientBlockProof => {
                write!(f, "EXPERIMENTAL_light_client_block_proof")
            }
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForExperimentalLightClientBlockProofMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "EXPERIMENTAL_light_client_block_proof" => Ok(Self::ExperimentalLightClientBlockProof),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForExperimentalLightClientBlockProofMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JsonRpcRequestForExperimentalLightClientBlockProofMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for JsonRpcRequestForExperimentalLightClientBlockProofMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForExperimentalLightClientProof`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_EXPERIMENTAL_light_client_proof\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXPERIMENTAL_light_client_proof\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcLightClientExecutionProofRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForExperimentalLightClientProof {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForExperimentalLightClientProofMethod,
    pub params: RpcLightClientExecutionProofRequest,
}
impl ::std::convert::From<&JsonRpcRequestForExperimentalLightClientProof>
    for JsonRpcRequestForExperimentalLightClientProof
{
    fn from(value: &JsonRpcRequestForExperimentalLightClientProof) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForExperimentalLightClientProofMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"EXPERIMENTAL_light_client_proof\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForExperimentalLightClientProofMethod {
    #[serde(rename = "EXPERIMENTAL_light_client_proof")]
    ExperimentalLightClientProof,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForExperimentalLightClientProofMethod {
    fn from(value: &JsonRpcRequestForExperimentalLightClientProofMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForExperimentalLightClientProofMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExperimentalLightClientProof => write!(f, "EXPERIMENTAL_light_client_proof"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForExperimentalLightClientProofMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "EXPERIMENTAL_light_client_proof" => Ok(Self::ExperimentalLightClientProof),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForExperimentalLightClientProofMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JsonRpcRequestForExperimentalLightClientProofMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for JsonRpcRequestForExperimentalLightClientProofMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForExperimentalMaintenanceWindows`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_EXPERIMENTAL_maintenance_windows\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXPERIMENTAL_maintenance_windows\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcMaintenanceWindowsRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForExperimentalMaintenanceWindows {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForExperimentalMaintenanceWindowsMethod,
    pub params: RpcMaintenanceWindowsRequest,
}
impl ::std::convert::From<&JsonRpcRequestForExperimentalMaintenanceWindows>
    for JsonRpcRequestForExperimentalMaintenanceWindows
{
    fn from(value: &JsonRpcRequestForExperimentalMaintenanceWindows) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForExperimentalMaintenanceWindowsMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"EXPERIMENTAL_maintenance_windows\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForExperimentalMaintenanceWindowsMethod {
    #[serde(rename = "EXPERIMENTAL_maintenance_windows")]
    ExperimentalMaintenanceWindows,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForExperimentalMaintenanceWindowsMethod {
    fn from(value: &JsonRpcRequestForExperimentalMaintenanceWindowsMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForExperimentalMaintenanceWindowsMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExperimentalMaintenanceWindows => {
                write!(f, "EXPERIMENTAL_maintenance_windows")
            }
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForExperimentalMaintenanceWindowsMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "EXPERIMENTAL_maintenance_windows" => Ok(Self::ExperimentalMaintenanceWindows),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForExperimentalMaintenanceWindowsMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JsonRpcRequestForExperimentalMaintenanceWindowsMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for JsonRpcRequestForExperimentalMaintenanceWindowsMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForExperimentalProtocolConfig`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_EXPERIMENTAL_protocol_config\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXPERIMENTAL_protocol_config\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcProtocolConfigRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForExperimentalProtocolConfig {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForExperimentalProtocolConfigMethod,
    pub params: RpcProtocolConfigRequest,
}
impl ::std::convert::From<&JsonRpcRequestForExperimentalProtocolConfig>
    for JsonRpcRequestForExperimentalProtocolConfig
{
    fn from(value: &JsonRpcRequestForExperimentalProtocolConfig) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForExperimentalProtocolConfigMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"EXPERIMENTAL_protocol_config\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForExperimentalProtocolConfigMethod {
    #[serde(rename = "EXPERIMENTAL_protocol_config")]
    ExperimentalProtocolConfig,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForExperimentalProtocolConfigMethod {
    fn from(value: &JsonRpcRequestForExperimentalProtocolConfigMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForExperimentalProtocolConfigMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExperimentalProtocolConfig => write!(f, "EXPERIMENTAL_protocol_config"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForExperimentalProtocolConfigMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "EXPERIMENTAL_protocol_config" => Ok(Self::ExperimentalProtocolConfig),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForExperimentalProtocolConfigMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JsonRpcRequestForExperimentalProtocolConfigMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for JsonRpcRequestForExperimentalProtocolConfigMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForExperimentalReceipt`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_EXPERIMENTAL_receipt\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXPERIMENTAL_receipt\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcReceiptRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForExperimentalReceipt {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForExperimentalReceiptMethod,
    pub params: RpcReceiptRequest,
}
impl ::std::convert::From<&JsonRpcRequestForExperimentalReceipt>
    for JsonRpcRequestForExperimentalReceipt
{
    fn from(value: &JsonRpcRequestForExperimentalReceipt) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForExperimentalReceiptMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"EXPERIMENTAL_receipt\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForExperimentalReceiptMethod {
    #[serde(rename = "EXPERIMENTAL_receipt")]
    ExperimentalReceipt,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForExperimentalReceiptMethod {
    fn from(value: &JsonRpcRequestForExperimentalReceiptMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForExperimentalReceiptMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExperimentalReceipt => write!(f, "EXPERIMENTAL_receipt"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForExperimentalReceiptMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "EXPERIMENTAL_receipt" => Ok(Self::ExperimentalReceipt),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForExperimentalReceiptMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JsonRpcRequestForExperimentalReceiptMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForExperimentalReceiptMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForExperimentalSplitStorageInfo`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_EXPERIMENTAL_split_storage_info\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXPERIMENTAL_split_storage_info\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcSplitStorageInfoRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForExperimentalSplitStorageInfo {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForExperimentalSplitStorageInfoMethod,
    pub params: RpcSplitStorageInfoRequest,
}
impl ::std::convert::From<&JsonRpcRequestForExperimentalSplitStorageInfo>
    for JsonRpcRequestForExperimentalSplitStorageInfo
{
    fn from(value: &JsonRpcRequestForExperimentalSplitStorageInfo) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForExperimentalSplitStorageInfoMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"EXPERIMENTAL_split_storage_info\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForExperimentalSplitStorageInfoMethod {
    #[serde(rename = "EXPERIMENTAL_split_storage_info")]
    ExperimentalSplitStorageInfo,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForExperimentalSplitStorageInfoMethod {
    fn from(value: &JsonRpcRequestForExperimentalSplitStorageInfoMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForExperimentalSplitStorageInfoMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExperimentalSplitStorageInfo => write!(f, "EXPERIMENTAL_split_storage_info"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForExperimentalSplitStorageInfoMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "EXPERIMENTAL_split_storage_info" => Ok(Self::ExperimentalSplitStorageInfo),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForExperimentalSplitStorageInfoMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JsonRpcRequestForExperimentalSplitStorageInfoMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for JsonRpcRequestForExperimentalSplitStorageInfoMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForExperimentalTxStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_EXPERIMENTAL_tx_status\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXPERIMENTAL_tx_status\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcTransactionStatusRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForExperimentalTxStatus {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForExperimentalTxStatusMethod,
    pub params: RpcTransactionStatusRequest,
}
impl ::std::convert::From<&JsonRpcRequestForExperimentalTxStatus>
    for JsonRpcRequestForExperimentalTxStatus
{
    fn from(value: &JsonRpcRequestForExperimentalTxStatus) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForExperimentalTxStatusMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"EXPERIMENTAL_tx_status\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForExperimentalTxStatusMethod {
    #[serde(rename = "EXPERIMENTAL_tx_status")]
    ExperimentalTxStatus,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForExperimentalTxStatusMethod {
    fn from(value: &JsonRpcRequestForExperimentalTxStatusMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForExperimentalTxStatusMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExperimentalTxStatus => write!(f, "EXPERIMENTAL_tx_status"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForExperimentalTxStatusMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "EXPERIMENTAL_tx_status" => Ok(Self::ExperimentalTxStatus),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForExperimentalTxStatusMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JsonRpcRequestForExperimentalTxStatusMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for JsonRpcRequestForExperimentalTxStatusMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForExperimentalValidatorsOrdered`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_EXPERIMENTAL_validators_ordered\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXPERIMENTAL_validators_ordered\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcValidatorsOrderedRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForExperimentalValidatorsOrdered {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForExperimentalValidatorsOrderedMethod,
    pub params: RpcValidatorsOrderedRequest,
}
impl ::std::convert::From<&JsonRpcRequestForExperimentalValidatorsOrdered>
    for JsonRpcRequestForExperimentalValidatorsOrdered
{
    fn from(value: &JsonRpcRequestForExperimentalValidatorsOrdered) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForExperimentalValidatorsOrderedMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"EXPERIMENTAL_validators_ordered\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForExperimentalValidatorsOrderedMethod {
    #[serde(rename = "EXPERIMENTAL_validators_ordered")]
    ExperimentalValidatorsOrdered,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForExperimentalValidatorsOrderedMethod {
    fn from(value: &JsonRpcRequestForExperimentalValidatorsOrderedMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForExperimentalValidatorsOrderedMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ExperimentalValidatorsOrdered => write!(f, "EXPERIMENTAL_validators_ordered"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForExperimentalValidatorsOrderedMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "EXPERIMENTAL_validators_ordered" => Ok(Self::ExperimentalValidatorsOrdered),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForExperimentalValidatorsOrderedMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JsonRpcRequestForExperimentalValidatorsOrderedMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for JsonRpcRequestForExperimentalValidatorsOrderedMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForGasPrice`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_gas_price\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"gas_price\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcGasPriceRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForGasPrice {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForGasPriceMethod,
    pub params: RpcGasPriceRequest,
}
impl ::std::convert::From<&JsonRpcRequestForGasPrice> for JsonRpcRequestForGasPrice {
    fn from(value: &JsonRpcRequestForGasPrice) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForGasPriceMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"gas_price\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForGasPriceMethod {
    #[serde(rename = "gas_price")]
    GasPrice,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForGasPriceMethod {
    fn from(value: &JsonRpcRequestForGasPriceMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForGasPriceMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::GasPrice => write!(f, "gas_price"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForGasPriceMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "gas_price" => Ok(Self::GasPrice),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForGasPriceMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForGasPriceMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForGasPriceMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForHealth`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_health\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"health\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcHealthRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForHealth {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForHealthMethod,
    pub params: RpcHealthRequest,
}
impl ::std::convert::From<&JsonRpcRequestForHealth> for JsonRpcRequestForHealth {
    fn from(value: &JsonRpcRequestForHealth) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForHealthMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"health\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForHealthMethod {
    #[serde(rename = "health")]
    Health,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForHealthMethod {
    fn from(value: &JsonRpcRequestForHealthMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForHealthMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Health => write!(f, "health"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForHealthMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "health" => Ok(Self::Health),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForHealthMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForHealthMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForHealthMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForLightClientProof`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_light_client_proof\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"light_client_proof\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcLightClientExecutionProofRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForLightClientProof {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForLightClientProofMethod,
    pub params: RpcLightClientExecutionProofRequest,
}
impl ::std::convert::From<&JsonRpcRequestForLightClientProof>
    for JsonRpcRequestForLightClientProof
{
    fn from(value: &JsonRpcRequestForLightClientProof) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForLightClientProofMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"light_client_proof\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForLightClientProofMethod {
    #[serde(rename = "light_client_proof")]
    LightClientProof,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForLightClientProofMethod {
    fn from(value: &JsonRpcRequestForLightClientProofMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForLightClientProofMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::LightClientProof => write!(f, "light_client_proof"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForLightClientProofMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "light_client_proof" => Ok(Self::LightClientProof),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForLightClientProofMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForLightClientProofMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForLightClientProofMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForNetworkInfo`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_network_info\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"network_info\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcNetworkInfoRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForNetworkInfo {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForNetworkInfoMethod,
    pub params: RpcNetworkInfoRequest,
}
impl ::std::convert::From<&JsonRpcRequestForNetworkInfo> for JsonRpcRequestForNetworkInfo {
    fn from(value: &JsonRpcRequestForNetworkInfo) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForNetworkInfoMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"network_info\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForNetworkInfoMethod {
    #[serde(rename = "network_info")]
    NetworkInfo,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForNetworkInfoMethod {
    fn from(value: &JsonRpcRequestForNetworkInfoMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForNetworkInfoMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::NetworkInfo => write!(f, "network_info"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForNetworkInfoMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "network_info" => Ok(Self::NetworkInfo),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForNetworkInfoMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForNetworkInfoMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForNetworkInfoMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForNextLightClientBlock`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_next_light_client_block\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"next_light_client_block\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcLightClientNextBlockRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForNextLightClientBlock {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForNextLightClientBlockMethod,
    pub params: RpcLightClientNextBlockRequest,
}
impl ::std::convert::From<&JsonRpcRequestForNextLightClientBlock>
    for JsonRpcRequestForNextLightClientBlock
{
    fn from(value: &JsonRpcRequestForNextLightClientBlock) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForNextLightClientBlockMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"next_light_client_block\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForNextLightClientBlockMethod {
    #[serde(rename = "next_light_client_block")]
    NextLightClientBlock,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForNextLightClientBlockMethod {
    fn from(value: &JsonRpcRequestForNextLightClientBlockMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForNextLightClientBlockMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::NextLightClientBlock => write!(f, "next_light_client_block"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForNextLightClientBlockMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "next_light_client_block" => Ok(Self::NextLightClientBlock),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForNextLightClientBlockMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for JsonRpcRequestForNextLightClientBlockMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for JsonRpcRequestForNextLightClientBlockMethod
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForQuery`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_query\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"query\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcQueryRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForQuery {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForQueryMethod,
    pub params: RpcQueryRequest,
}
impl ::std::convert::From<&JsonRpcRequestForQuery> for JsonRpcRequestForQuery {
    fn from(value: &JsonRpcRequestForQuery) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForQueryMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"query\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForQueryMethod {
    #[serde(rename = "query")]
    Query,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForQueryMethod {
    fn from(value: &JsonRpcRequestForQueryMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForQueryMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Query => write!(f, "query"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForQueryMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "query" => Ok(Self::Query),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForQueryMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForQueryMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForQueryMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForSendTx`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_send_tx\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"send_tx\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcSendTransactionRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForSendTx {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForSendTxMethod,
    pub params: RpcSendTransactionRequest,
}
impl ::std::convert::From<&JsonRpcRequestForSendTx> for JsonRpcRequestForSendTx {
    fn from(value: &JsonRpcRequestForSendTx) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForSendTxMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"send_tx\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForSendTxMethod {
    #[serde(rename = "send_tx")]
    SendTx,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForSendTxMethod {
    fn from(value: &JsonRpcRequestForSendTxMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForSendTxMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SendTx => write!(f, "send_tx"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForSendTxMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "send_tx" => Ok(Self::SendTx),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForSendTxMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForSendTxMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForSendTxMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_status\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"status\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcStatusRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForStatus {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForStatusMethod,
    pub params: RpcStatusRequest,
}
impl ::std::convert::From<&JsonRpcRequestForStatus> for JsonRpcRequestForStatus {
    fn from(value: &JsonRpcRequestForStatus) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForStatusMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"status\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForStatusMethod {
    #[serde(rename = "status")]
    Status,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForStatusMethod {
    fn from(value: &JsonRpcRequestForStatusMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForStatusMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Status => write!(f, "status"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForStatusMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "status" => Ok(Self::Status),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForStatusMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForStatusMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForStatusMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForTx`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_tx\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"tx\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcTransactionStatusRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForTx {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForTxMethod,
    pub params: RpcTransactionStatusRequest,
}
impl ::std::convert::From<&JsonRpcRequestForTx> for JsonRpcRequestForTx {
    fn from(value: &JsonRpcRequestForTx) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForTxMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"tx\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForTxMethod {
    #[serde(rename = "tx")]
    Tx,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForTxMethod {
    fn from(value: &JsonRpcRequestForTxMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForTxMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Tx => write!(f, "tx"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForTxMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "tx" => Ok(Self::Tx),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForTxMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForTxMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForTxMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcRequestForValidators`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcRequest_for_validators\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\","]
#[doc = "    \"method\","]
#[doc = "    \"params\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"validators\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"params\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/RpcValidatorRequest\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct JsonRpcRequestForValidators {
    pub id: ::std::string::String,
    pub jsonrpc: ::std::string::String,
    pub method: JsonRpcRequestForValidatorsMethod,
    pub params: RpcValidatorRequest,
}
impl ::std::convert::From<&JsonRpcRequestForValidators> for JsonRpcRequestForValidators {
    fn from(value: &JsonRpcRequestForValidators) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcRequestForValidatorsMethod`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"validators\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum JsonRpcRequestForValidatorsMethod {
    #[serde(rename = "validators")]
    Validators,
}
impl ::std::convert::From<&Self> for JsonRpcRequestForValidatorsMethod {
    fn from(value: &JsonRpcRequestForValidatorsMethod) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for JsonRpcRequestForValidatorsMethod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Validators => write!(f, "validators"),
        }
    }
}
impl ::std::str::FromStr for JsonRpcRequestForValidatorsMethod {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "validators" => Ok(Self::Validators),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for JsonRpcRequestForValidatorsMethod {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for JsonRpcRequestForValidatorsMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for JsonRpcRequestForValidatorsMethod {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`JsonRpcResponseForArrayOfRangeOfUint64AndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_Array_of_Range_of_uint64_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/components/schemas/Range_of_uint64\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForArrayOfRangeOfUint64AndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: ::std::vec::Vec<RangeOfUint64>,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForArrayOfRangeOfUint64AndRpcError {
    fn from(value: &JsonRpcResponseForArrayOfRangeOfUint64AndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_Array_of_ValidatorStakeView_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/components/schemas/ValidatorStakeView\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: ::std::vec::Vec<ValidatorStakeView>,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError {
    fn from(value: &JsonRpcResponseForArrayOfValidatorStakeViewAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForCryptoHashAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_CryptoHash_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForCryptoHashAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: CryptoHash,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForCryptoHashAndRpcError {
    fn from(value: &JsonRpcResponseForCryptoHashAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForGenesisConfigAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_GenesisConfig_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/GenesisConfig\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForGenesisConfigAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: GenesisConfig,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForGenesisConfigAndRpcError {
    fn from(value: &JsonRpcResponseForGenesisConfigAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForNullableRpcHealthResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_Nullable_RpcHealthResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"anyOf\": ["]
#[doc = "            {"]
#[doc = "              \"$ref\": \"#/components/schemas/RpcHealthResponse\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"type\": \"null\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForNullableRpcHealthResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: ::std::option::Option<RpcHealthResponse>,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForNullableRpcHealthResponseAndRpcError {
    fn from(value: &JsonRpcResponseForNullableRpcHealthResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcBlockResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcBlockResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcBlockResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcBlockResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcBlockResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcBlockResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcBlockResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcChunkResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcChunkResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcChunkResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcChunkResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcChunkResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcChunkResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcChunkResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcClientConfigResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcClientConfigResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcClientConfigResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcClientConfigResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcClientConfigResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcClientConfigResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcClientConfigResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcCongestionLevelResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcCongestionLevelResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcCongestionLevelResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcCongestionLevelResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcCongestionLevelResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcCongestionLevelResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcCongestionLevelResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcGasPriceResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcGasPriceResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcGasPriceResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcGasPriceResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcGasPriceResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcGasPriceResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcGasPriceResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcLightClientBlockProofResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcLightClientBlockProofResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcLightClientBlockProofResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcLightClientBlockProofResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcLightClientExecutionProofResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcLightClientExecutionProofResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcLightClientExecutionProofResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self>
    for JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError
{
    fn from(value: &JsonRpcResponseForRpcLightClientExecutionProofResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcLightClientNextBlockResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcLightClientNextBlockResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcLightClientNextBlockResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcLightClientNextBlockResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcNetworkInfoResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcNetworkInfoResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcNetworkInfoResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcNetworkInfoResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcNetworkInfoResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcNetworkInfoResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcNetworkInfoResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcProtocolConfigResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcProtocolConfigResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcProtocolConfigResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcProtocolConfigResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcProtocolConfigResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcProtocolConfigResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcProtocolConfigResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcQueryResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcQueryResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcQueryResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcQueryResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcQueryResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcQueryResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcQueryResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcReceiptResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcReceiptResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcReceiptResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcReceiptResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcReceiptResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcReceiptResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcReceiptResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcSplitStorageInfoResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcSplitStorageInfoResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcSplitStorageInfoResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcSplitStorageInfoResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcStateChangesInBlockByTypeResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcStateChangesInBlockByTypeResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcStateChangesInBlockByTypeResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self>
    for JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError
{
    fn from(value: &JsonRpcResponseForRpcStateChangesInBlockByTypeResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcStateChangesInBlockResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcStateChangesInBlockResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcStateChangesInBlockResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcStateChangesInBlockResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcStatusResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcStatusResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcStatusResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcStatusResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcStatusResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcStatusResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcStatusResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcTransactionResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcTransactionResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcTransactionResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcTransactionResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcTransactionResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcTransactionResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcTransactionResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "`JsonRpcResponseForRpcValidatorResponseAndRpcError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"JsonRpcResponse_for_RpcValidatorResponse_and_RpcError\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"result\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"result\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcValidatorResponse\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcError\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"id\","]
#[doc = "    \"jsonrpc\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"id\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jsonrpc\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum JsonRpcResponseForRpcValidatorResponseAndRpcError {
    Variant0 {
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
        result: RpcValidatorResponse,
    },
    Variant1 {
        error: RpcError,
        id: ::std::string::String,
        jsonrpc: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for JsonRpcResponseForRpcValidatorResponseAndRpcError {
    fn from(value: &JsonRpcResponseForRpcValidatorResponseAndRpcError) -> Self {
        value.clone()
    }
}
#[doc = "Information about a Producer: its account name, peer_id and a list of connected peers that\nthe node can use to send message for this producer."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Information about a Producer: its account name, peer_id and a list of connected peers that\\nthe node can use to send message for this producer.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"peer_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"next_hops\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"array\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"peer_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct KnownProducerView {
    pub account_id: AccountId,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub next_hops: ::std::option::Option<::std::vec::Vec<PublicKey>>,
    pub peer_id: PublicKey,
}
impl ::std::convert::From<&KnownProducerView> for KnownProducerView {
    fn from(value: &KnownProducerView) -> Self {
        value.clone()
    }
}
#[doc = "`LightClientBlockLiteView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"inner_lite\","]
#[doc = "    \"inner_rest_hash\","]
#[doc = "    \"prev_block_hash\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"inner_lite\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/BlockHeaderInnerLiteView\""]
#[doc = "    },"]
#[doc = "    \"inner_rest_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"prev_block_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LightClientBlockLiteView {
    pub inner_lite: BlockHeaderInnerLiteView,
    pub inner_rest_hash: CryptoHash,
    pub prev_block_hash: CryptoHash,
}
impl ::std::convert::From<&LightClientBlockLiteView> for LightClientBlockLiteView {
    fn from(value: &LightClientBlockLiteView) -> Self {
        value.clone()
    }
}
#[doc = "Describes limits for VM and Runtime.\nTODO #4139: consider switching to strongly-typed wrappers instead of raw quantities"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes limits for VM and Runtime.\\nTODO #4139: consider switching to strongly-typed wrappers instead of raw quantities\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"initial_memory_pages\","]
#[doc = "    \"max_actions_per_receipt\","]
#[doc = "    \"max_arguments_length\","]
#[doc = "    \"max_contract_size\","]
#[doc = "    \"max_gas_burnt\","]
#[doc = "    \"max_length_method_name\","]
#[doc = "    \"max_length_returned_data\","]
#[doc = "    \"max_length_storage_key\","]
#[doc = "    \"max_length_storage_value\","]
#[doc = "    \"max_memory_pages\","]
#[doc = "    \"max_number_bytes_method_names\","]
#[doc = "    \"max_number_input_data_dependencies\","]
#[doc = "    \"max_number_logs\","]
#[doc = "    \"max_number_registers\","]
#[doc = "    \"max_promises_per_function_call_action\","]
#[doc = "    \"max_receipt_size\","]
#[doc = "    \"max_register_size\","]
#[doc = "    \"max_stack_height\","]
#[doc = "    \"max_total_log_length\","]
#[doc = "    \"max_total_prepaid_gas\","]
#[doc = "    \"max_transaction_size\","]
#[doc = "    \"max_yield_payload_size\","]
#[doc = "    \"per_receipt_storage_proof_size_limit\","]
#[doc = "    \"registers_memory_limit\","]
#[doc = "    \"yield_timeout_length_in_blocks\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id_validity_rules_version\": {"]
#[doc = "      \"description\": \"Whether to enforce account_id well-formed-ness where it wasn't enforced\\nhistorically.\","]
#[doc = "      \"default\": 0,"]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountIdValidityRulesVersion\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"initial_memory_pages\": {"]
#[doc = "      \"description\": \"The initial number of memory pages.\\nNOTE: It's not a limiter itself, but it's a value we use for initial_memory_pages.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_actions_per_receipt\": {"]
#[doc = "      \"description\": \"Max number of actions per receipt.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_arguments_length\": {"]
#[doc = "      \"description\": \"Max length of arguments in a function call action.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_contract_size\": {"]
#[doc = "      \"description\": \"Max contract size\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_functions_number_per_contract\": {"]
#[doc = "      \"description\": \"If present, stores max number of functions in one contract\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_gas_burnt\": {"]
#[doc = "      \"description\": \"Max amount of gas that can be used, excluding gas attached to promises.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_length_method_name\": {"]
#[doc = "      \"description\": \"Max length of any method name (without terminating character).\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_length_returned_data\": {"]
#[doc = "      \"description\": \"Max length of returned data\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_length_storage_key\": {"]
#[doc = "      \"description\": \"Max storage key size\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_length_storage_value\": {"]
#[doc = "      \"description\": \"Max storage value size\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_locals_per_contract\": {"]
#[doc = "      \"description\": \"If present, stores max number of locals declared globally in one contract\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_memory_pages\": {"]
#[doc = "      \"description\": \"What is the maximal memory pages amount is allowed to have for a contract.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_number_bytes_method_names\": {"]
#[doc = "      \"description\": \"Max total length of all method names (including terminating character) for a function call\\npermission access key.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_number_input_data_dependencies\": {"]
#[doc = "      \"description\": \"Max number of input data dependencies\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_number_logs\": {"]
#[doc = "      \"description\": \"Maximum number of log entries.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_number_registers\": {"]
#[doc = "      \"description\": \"Maximum number of registers that can be used simultaneously.\\n\\nNote that due to an implementation quirk [read: a bug] in VMLogic, if we\\nhave this number of registers, no subsequent writes to the registers\\nwill succeed even if they replace an existing register.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_promises_per_function_call_action\": {"]
#[doc = "      \"description\": \"Max number of promises that a function call can create\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_receipt_size\": {"]
#[doc = "      \"description\": \"Max receipt size\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_register_size\": {"]
#[doc = "      \"description\": \"Maximum number of bytes that can be stored in a single register.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_stack_height\": {"]
#[doc = "      \"description\": \"How tall the stack is allowed to grow?\\n\\nSee <https://wiki.parity.io/WebAssembly-StackHeight> to find out how the stack frame cost\\nis calculated.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_total_log_length\": {"]
#[doc = "      \"description\": \"Maximum total length in bytes of all log messages.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_total_prepaid_gas\": {"]
#[doc = "      \"description\": \"Max total prepaid gas for all function call actions per receipt.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_transaction_size\": {"]
#[doc = "      \"description\": \"Max transaction size\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"max_yield_payload_size\": {"]
#[doc = "      \"description\": \"Maximum number of bytes for payload passed over a yield resume.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"per_receipt_storage_proof_size_limit\": {"]
#[doc = "      \"description\": \"Hard limit on the size of storage proof generated while executing a single receipt.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"registers_memory_limit\": {"]
#[doc = "      \"description\": \"Limit of memory used by registers.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"yield_timeout_length_in_blocks\": {"]
#[doc = "      \"description\": \"Number of blocks after which a yielded promise times out.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct LimitConfig {
    #[doc = "Whether to enforce account_id well-formed-ness where it wasn't enforced\nhistorically."]
    #[serde(default = "defaults::limit_config_account_id_validity_rules_version")]
    pub account_id_validity_rules_version: AccountIdValidityRulesVersion,
    #[doc = "The initial number of memory pages.\nNOTE: It's not a limiter itself, but it's a value we use for initial_memory_pages."]
    pub initial_memory_pages: u32,
    #[doc = "Max number of actions per receipt."]
    pub max_actions_per_receipt: u64,
    #[doc = "Max length of arguments in a function call action."]
    pub max_arguments_length: u64,
    #[doc = "Max contract size"]
    pub max_contract_size: u64,
    #[doc = "If present, stores max number of functions in one contract"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub max_functions_number_per_contract: ::std::option::Option<u64>,
    #[doc = "Max amount of gas that can be used, excluding gas attached to promises."]
    pub max_gas_burnt: u64,
    #[doc = "Max length of any method name (without terminating character)."]
    pub max_length_method_name: u64,
    #[doc = "Max length of returned data"]
    pub max_length_returned_data: u64,
    #[doc = "Max storage key size"]
    pub max_length_storage_key: u64,
    #[doc = "Max storage value size"]
    pub max_length_storage_value: u64,
    #[doc = "If present, stores max number of locals declared globally in one contract"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub max_locals_per_contract: ::std::option::Option<u64>,
    #[doc = "What is the maximal memory pages amount is allowed to have for a contract."]
    pub max_memory_pages: u32,
    #[doc = "Max total length of all method names (including terminating character) for a function call\npermission access key."]
    pub max_number_bytes_method_names: u64,
    #[doc = "Max number of input data dependencies"]
    pub max_number_input_data_dependencies: u64,
    #[doc = "Maximum number of log entries."]
    pub max_number_logs: u64,
    #[doc = "Maximum number of registers that can be used simultaneously.\n\nNote that due to an implementation quirk [read: a bug] in VMLogic, if we\nhave this number of registers, no subsequent writes to the registers\nwill succeed even if they replace an existing register."]
    pub max_number_registers: u64,
    #[doc = "Max number of promises that a function call can create"]
    pub max_promises_per_function_call_action: u64,
    #[doc = "Max receipt size"]
    pub max_receipt_size: u64,
    #[doc = "Maximum number of bytes that can be stored in a single register."]
    pub max_register_size: u64,
    #[doc = "How tall the stack is allowed to grow?\n\nSee <https://wiki.parity.io/WebAssembly-StackHeight> to find out how the stack frame cost\nis calculated."]
    pub max_stack_height: u32,
    #[doc = "Maximum total length in bytes of all log messages."]
    pub max_total_log_length: u64,
    #[doc = "Max total prepaid gas for all function call actions per receipt."]
    pub max_total_prepaid_gas: u64,
    #[doc = "Max transaction size"]
    pub max_transaction_size: u64,
    #[doc = "Maximum number of bytes for payload passed over a yield resume."]
    pub max_yield_payload_size: u64,
    #[doc = "Hard limit on the size of storage proof generated while executing a single receipt."]
    pub per_receipt_storage_proof_size_limit: u32,
    #[doc = "Limit of memory used by registers."]
    pub registers_memory_limit: u64,
    #[doc = "Number of blocks after which a yielded promise times out."]
    pub yield_timeout_length_in_blocks: u64,
}
impl ::std::convert::From<&LimitConfig> for LimitConfig {
    fn from(value: &LimitConfig) -> Self {
        value.clone()
    }
}
#[doc = "`LogSummaryStyle`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"plain\","]
#[doc = "    \"colored\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum LogSummaryStyle {
    #[serde(rename = "plain")]
    Plain,
    #[serde(rename = "colored")]
    Colored,
}
impl ::std::convert::From<&Self> for LogSummaryStyle {
    fn from(value: &LogSummaryStyle) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for LogSummaryStyle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Plain => write!(f, "plain"),
            Self::Colored => write!(f, "colored"),
        }
    }
}
impl ::std::str::FromStr for LogSummaryStyle {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "plain" => Ok(Self::Plain),
            "colored" => Ok(Self::Colored),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for LogSummaryStyle {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for LogSummaryStyle {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for LogSummaryStyle {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MerklePathItem`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"direction\","]
#[doc = "    \"hash\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"direction\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/Direction\""]
#[doc = "    },"]
#[doc = "    \"hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct MerklePathItem {
    pub direction: Direction,
    pub hash: CryptoHash,
}
impl ::std::convert::From<&MerklePathItem> for MerklePathItem {
    fn from(value: &MerklePathItem) -> Self {
        value.clone()
    }
}
#[doc = "`MethodResolveError`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"MethodEmptyName\","]
#[doc = "    \"MethodNotFound\","]
#[doc = "    \"MethodInvalidSignature\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MethodResolveError {
    MethodEmptyName,
    MethodNotFound,
    MethodInvalidSignature,
}
impl ::std::convert::From<&Self> for MethodResolveError {
    fn from(value: &MethodResolveError) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MethodResolveError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::MethodEmptyName => write!(f, "MethodEmptyName"),
            Self::MethodNotFound => write!(f, "MethodNotFound"),
            Self::MethodInvalidSignature => write!(f, "MethodInvalidSignature"),
        }
    }
}
impl ::std::str::FromStr for MethodResolveError {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "MethodEmptyName" => Ok(Self::MethodEmptyName),
            "MethodNotFound" => Ok(Self::MethodNotFound),
            "MethodInvalidSignature" => Ok(Self::MethodInvalidSignature),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MethodResolveError {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MethodResolveError {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MethodResolveError {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MissingTrieValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"context\","]
#[doc = "    \"hash\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"context\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/MissingTrieValueContext\""]
#[doc = "    },"]
#[doc = "    \"hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct MissingTrieValue {
    pub context: MissingTrieValueContext,
    pub hash: CryptoHash,
}
impl ::std::convert::From<&MissingTrieValue> for MissingTrieValue {
    fn from(value: &MissingTrieValue) -> Self {
        value.clone()
    }
}
#[doc = "Contexts in which `StorageError::MissingTrieValue` error might occur."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Contexts in which `StorageError::MissingTrieValue` error might occur.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"Missing trie value when reading from TrieIterator.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"TrieIterator\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Missing trie value when reading from TriePrefetchingStorage.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"TriePrefetchingStorage\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Missing trie value when reading from TrieMemoryPartialStorage.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"TrieMemoryPartialStorage\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Missing trie value when reading from TrieStorage.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"TrieStorage\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum MissingTrieValueContext {
    #[doc = "Missing trie value when reading from TrieIterator."]
    TrieIterator,
    #[doc = "Missing trie value when reading from TriePrefetchingStorage."]
    TriePrefetchingStorage,
    #[doc = "Missing trie value when reading from TrieMemoryPartialStorage."]
    TrieMemoryPartialStorage,
    #[doc = "Missing trie value when reading from TrieStorage."]
    TrieStorage,
}
impl ::std::convert::From<&Self> for MissingTrieValueContext {
    fn from(value: &MissingTrieValueContext) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for MissingTrieValueContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::TrieIterator => write!(f, "TrieIterator"),
            Self::TriePrefetchingStorage => write!(f, "TriePrefetchingStorage"),
            Self::TrieMemoryPartialStorage => write!(f, "TrieMemoryPartialStorage"),
            Self::TrieStorage => write!(f, "TrieStorage"),
        }
    }
}
impl ::std::str::FromStr for MissingTrieValueContext {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "TrieIterator" => Ok(Self::TrieIterator),
            "TriePrefetchingStorage" => Ok(Self::TriePrefetchingStorage),
            "TrieMemoryPartialStorage" => Ok(Self::TrieMemoryPartialStorage),
            "TrieStorage" => Ok(Self::TrieStorage),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for MissingTrieValueContext {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for MissingTrieValueContext {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for MissingTrieValueContext {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`MutableConfigValue`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct MutableConfigValue(pub ::std::string::String);
impl ::std::ops::Deref for MutableConfigValue {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<MutableConfigValue> for ::std::string::String {
    fn from(value: MutableConfigValue) -> Self {
        value.0
    }
}
impl ::std::convert::From<&MutableConfigValue> for MutableConfigValue {
    fn from(value: &MutableConfigValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for MutableConfigValue {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for MutableConfigValue {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for MutableConfigValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`NetworkInfoView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"connected_peers\","]
#[doc = "    \"known_producers\","]
#[doc = "    \"num_connected_peers\","]
#[doc = "    \"peer_max_count\","]
#[doc = "    \"tier1_accounts_data\","]
#[doc = "    \"tier1_accounts_keys\","]
#[doc = "    \"tier1_connections\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"connected_peers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/PeerInfoView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"known_producers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/KnownProducerView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"num_connected_peers\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"peer_max_count\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"tier1_accounts_data\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/AccountDataView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"tier1_accounts_keys\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"tier1_connections\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/PeerInfoView\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct NetworkInfoView {
    pub connected_peers: ::std::vec::Vec<PeerInfoView>,
    pub known_producers: ::std::vec::Vec<KnownProducerView>,
    pub num_connected_peers: u32,
    pub peer_max_count: u32,
    pub tier1_accounts_data: ::std::vec::Vec<AccountDataView>,
    pub tier1_accounts_keys: ::std::vec::Vec<PublicKey>,
    pub tier1_connections: ::std::vec::Vec<PeerInfoView>,
}
impl ::std::convert::From<&NetworkInfoView> for NetworkInfoView {
    fn from(value: &NetworkInfoView) -> Self {
        value.clone()
    }
}
#[doc = "`NextEpochValidatorInfo`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"public_key\","]
#[doc = "    \"shards\","]
#[doc = "    \"stake\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    },"]
#[doc = "    \"shards\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"stake\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct NextEpochValidatorInfo {
    pub account_id: AccountId,
    pub public_key: PublicKey,
    pub shards: ::std::vec::Vec<ShardId>,
    pub stake: ::std::string::String,
}
impl ::std::convert::From<&NextEpochValidatorInfo> for NextEpochValidatorInfo {
    fn from(value: &NextEpochValidatorInfo) -> Self {
        value.clone()
    }
}
#[doc = "This is Action which mustn't contain DelegateAction.\n\nThis struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\n\nImportant: Don't make the inner Action public, this must only be constructed\nthrough the correct interface that ensures the inner Action is actually not\na delegate action. That would break an assumption of this type, which we use\nin several places. For example, borsh de-/serialization relies on it. If the\ninvariant is broken, we may end up with a `Transaction` or `Receipt` that we\ncan serialize but deserializing it back causes a parsing error."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"This is Action which mustn't contain DelegateAction.\\n\\nThis struct is needed to avoid the recursion when Action/DelegateAction is deserialized.\\n\\nImportant: Don't make the inner Action public, this must only be constructed\\nthrough the correct interface that ensures the inner Action is actually not\\na delegate action. That would break an assumption of this type, which we use\\nin several places. For example, borsh de-/serialization relies on it. If the\\ninvariant is broken, we may end up with a `Transaction` or `Receipt` that we\\ncan serialize but deserializing it back causes a parsing error.\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/components/schemas/Action\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct NonDelegateAction(pub Action);
impl ::std::ops::Deref for NonDelegateAction {
    type Target = Action;
    fn deref(&self) -> &Action {
        &self.0
    }
}
impl ::std::convert::From<NonDelegateAction> for Action {
    fn from(value: NonDelegateAction) -> Self {
        value.0
    }
}
impl ::std::convert::From<&NonDelegateAction> for NonDelegateAction {
    fn from(value: &NonDelegateAction) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Action> for NonDelegateAction {
    fn from(value: Action) -> Self {
        Self(value)
    }
}
#[doc = "Peer id is the public key."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Peer id is the public key.\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct PeerId(pub PublicKey);
impl ::std::ops::Deref for PeerId {
    type Target = PublicKey;
    fn deref(&self) -> &PublicKey {
        &self.0
    }
}
impl ::std::convert::From<PeerId> for PublicKey {
    fn from(value: PeerId) -> Self {
        value.0
    }
}
impl ::std::convert::From<&PeerId> for PeerId {
    fn from(value: &PeerId) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<PublicKey> for PeerId {
    fn from(value: PublicKey) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for PeerId {
    type Err = <PublicKey as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for PeerId {
    type Error = <PublicKey as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for PeerId {
    type Error = <PublicKey as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for PeerId {
    type Error = <PublicKey as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for PeerId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`PeerInfoView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"addr\","]
#[doc = "    \"archival\","]
#[doc = "    \"connection_established_time_millis\","]
#[doc = "    \"is_highest_block_invalid\","]
#[doc = "    \"is_outbound_peer\","]
#[doc = "    \"last_time_peer_requested_millis\","]
#[doc = "    \"last_time_received_message_millis\","]
#[doc = "    \"nonce\","]
#[doc = "    \"peer_id\","]
#[doc = "    \"received_bytes_per_sec\","]
#[doc = "    \"sent_bytes_per_sec\","]
#[doc = "    \"tracked_shards\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"addr\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"archival\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"block_hash\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"connection_established_time_millis\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"height\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"is_highest_block_invalid\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"is_outbound_peer\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"last_time_peer_requested_millis\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"last_time_received_message_millis\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"nonce\": {"]
#[doc = "      \"description\": \"Connection nonce.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"peer_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    },"]
#[doc = "    \"received_bytes_per_sec\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"sent_bytes_per_sec\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"tracked_shards\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct PeerInfoView {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub account_id: ::std::option::Option<AccountId>,
    pub addr: ::std::string::String,
    pub archival: bool,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub block_hash: ::std::option::Option<CryptoHash>,
    pub connection_established_time_millis: u64,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub height: ::std::option::Option<u64>,
    pub is_highest_block_invalid: bool,
    pub is_outbound_peer: bool,
    pub last_time_peer_requested_millis: u64,
    pub last_time_received_message_millis: u64,
    #[doc = "Connection nonce."]
    pub nonce: u64,
    pub peer_id: PublicKey,
    pub received_bytes_per_sec: u64,
    pub sent_bytes_per_sec: u64,
    pub tracked_shards: ::std::vec::Vec<ShardId>,
}
impl ::std::convert::From<&PeerInfoView> for PeerInfoView {
    fn from(value: &PeerInfoView) -> Self {
        value.clone()
    }
}
#[doc = "Error that can occur while preparing or executing Wasm smart-contract."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Error that can occur while preparing or executing Wasm smart-contract.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"Error happened while serializing the module.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Serialization\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Error happened while deserializing the module.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Deserialization\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Internal memory declaration has been found in the module.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"InternalMemoryDeclared\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Gas instrumentation failed.\\n\\nThis most likely indicates the module isn't valid.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"GasInstrumentation\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Stack instrumentation failed.\\n\\nThis  most likely indicates the module isn't valid.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"StackHeightInstrumentation\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Error happened during instantiation.\\n\\nThis might indicate that `start` function trapped, or module isn't\\ninstantiable and/or un-linkable.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Instantiate\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Error creating memory.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Memory\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Contract contains too many functions.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"TooManyFunctions\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Contract contains too many locals.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"TooManyLocals\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum PrepareError {
    #[doc = "Error happened while serializing the module."]
    Serialization,
    #[doc = "Error happened while deserializing the module."]
    Deserialization,
    #[doc = "Internal memory declaration has been found in the module."]
    InternalMemoryDeclared,
    #[doc = "Gas instrumentation failed.\n\nThis most likely indicates the module isn't valid."]
    GasInstrumentation,
    #[doc = "Stack instrumentation failed.\n\nThis  most likely indicates the module isn't valid."]
    StackHeightInstrumentation,
    #[doc = "Error happened during instantiation.\n\nThis might indicate that `start` function trapped, or module isn't\ninstantiable and/or un-linkable."]
    Instantiate,
    #[doc = "Error creating memory."]
    Memory,
    #[doc = "Contract contains too many functions."]
    TooManyFunctions,
    #[doc = "Contract contains too many locals."]
    TooManyLocals,
}
impl ::std::convert::From<&Self> for PrepareError {
    fn from(value: &PrepareError) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for PrepareError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Serialization => write!(f, "Serialization"),
            Self::Deserialization => write!(f, "Deserialization"),
            Self::InternalMemoryDeclared => write!(f, "InternalMemoryDeclared"),
            Self::GasInstrumentation => write!(f, "GasInstrumentation"),
            Self::StackHeightInstrumentation => write!(f, "StackHeightInstrumentation"),
            Self::Instantiate => write!(f, "Instantiate"),
            Self::Memory => write!(f, "Memory"),
            Self::TooManyFunctions => write!(f, "TooManyFunctions"),
            Self::TooManyLocals => write!(f, "TooManyLocals"),
        }
    }
}
impl ::std::str::FromStr for PrepareError {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Serialization" => Ok(Self::Serialization),
            "Deserialization" => Ok(Self::Deserialization),
            "InternalMemoryDeclared" => Ok(Self::InternalMemoryDeclared),
            "GasInstrumentation" => Ok(Self::GasInstrumentation),
            "StackHeightInstrumentation" => Ok(Self::StackHeightInstrumentation),
            "Instantiate" => Ok(Self::Instantiate),
            "Memory" => Ok(Self::Memory),
            "TooManyFunctions" => Ok(Self::TooManyFunctions),
            "TooManyLocals" => Ok(Self::TooManyLocals),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for PrepareError {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for PrepareError {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for PrepareError {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`PublicKey`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct PublicKey(pub ::std::string::String);
impl ::std::ops::Deref for PublicKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<PublicKey> for ::std::string::String {
    fn from(value: PublicKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&PublicKey> for PublicKey {
    fn from(value: &PublicKey) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for PublicKey {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for PublicKey {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for PublicKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`RangeOfUint64`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"end\","]
#[doc = "    \"start\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"end\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"start\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RangeOfUint64 {
    pub end: u64,
    pub start: u64,
}
impl ::std::convert::From<&RangeOfUint64> for RangeOfUint64 {
    fn from(value: &RangeOfUint64) -> Self {
        value.clone()
    }
}
#[doc = "`ReceiptEnumView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Action\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Action\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"actions\","]
#[doc = "            \"gas_price\","]
#[doc = "            \"input_data_ids\","]
#[doc = "            \"output_data_receivers\","]
#[doc = "            \"signer_id\","]
#[doc = "            \"signer_public_key\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"actions\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/ActionView\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"gas_price\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"input_data_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"is_promise_yield\": {"]
#[doc = "              \"default\": false,"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"output_data_receivers\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/DataReceiverView\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"signer_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"signer_public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Data\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Data\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"data_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"data\": {"]
#[doc = "              \"type\": ["]
#[doc = "                \"string\","]
#[doc = "                \"null\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"data_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "            },"]
#[doc = "            \"is_promise_resume\": {"]
#[doc = "              \"default\": false,"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"GlobalContractDistribution\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"GlobalContractDistribution\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"already_delivered_shards\","]
#[doc = "            \"code\","]
#[doc = "            \"id\","]
#[doc = "            \"target_shard\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"already_delivered_shards\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"code\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/GlobalContractIdentifier\""]
#[doc = "            },"]
#[doc = "            \"target_shard\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum ReceiptEnumView {
    Action {
        actions: ::std::vec::Vec<ActionView>,
        gas_price: ::std::string::String,
        input_data_ids: ::std::vec::Vec<CryptoHash>,
        #[serde(default)]
        is_promise_yield: bool,
        output_data_receivers: ::std::vec::Vec<DataReceiverView>,
        signer_id: AccountId,
        signer_public_key: PublicKey,
    },
    Data {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        data: ::std::option::Option<::std::string::String>,
        data_id: CryptoHash,
        #[serde(default)]
        is_promise_resume: bool,
    },
    GlobalContractDistribution {
        already_delivered_shards: ::std::vec::Vec<ShardId>,
        code: ::std::string::String,
        id: GlobalContractIdentifier,
        target_shard: ShardId,
    },
}
impl ::std::convert::From<&Self> for ReceiptEnumView {
    fn from(value: &ReceiptEnumView) -> Self {
        value.clone()
    }
}
#[doc = "Describes the error for validating a receipt."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes the error for validating a receipt.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"The `predecessor_id` of a Receipt is not valid.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidPredecessorId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidPredecessorId\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The `receiver_id` of a Receipt is not valid.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidReceiverId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidReceiverId\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The `signer_id` of an ActionReceipt is not valid.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidSignerId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidSignerId\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidDataReceiverId\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidDataReceiverId\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The length of the returned data exceeded the limit in a DataReceipt.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ReturnedValueLengthExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ReturnedValueLengthExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"length\","]
#[doc = "            \"limit\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"length\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"The number of input data dependencies exceeds the limit in an ActionReceipt.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"NumberInputDataDependenciesExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"NumberInputDataDependenciesExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"limit\","]
#[doc = "            \"number_of_input_data_dependencies\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"number_of_input_data_dependencies\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"An error occurred while validating actions of an ActionReceipt.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ActionsValidation\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ActionsValidation\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/ActionsValidationError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Receipt is bigger than the limit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ReceiptSizeExceeded\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ReceiptSizeExceeded\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"limit\","]
#[doc = "            \"size\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"limit\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"size\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum ReceiptValidationError {
    #[doc = "The `predecessor_id` of a Receipt is not valid."]
    InvalidPredecessorId { account_id: ::std::string::String },
    #[doc = "The `receiver_id` of a Receipt is not valid."]
    InvalidReceiverId { account_id: ::std::string::String },
    #[doc = "The `signer_id` of an ActionReceipt is not valid."]
    InvalidSignerId { account_id: ::std::string::String },
    #[doc = "The `receiver_id` of a DataReceiver within an ActionReceipt is not valid."]
    InvalidDataReceiverId { account_id: ::std::string::String },
    #[doc = "The length of the returned data exceeded the limit in a DataReceipt."]
    ReturnedValueLengthExceeded { length: u64, limit: u64 },
    #[doc = "The number of input data dependencies exceeds the limit in an ActionReceipt."]
    NumberInputDataDependenciesExceeded {
        limit: u64,
        number_of_input_data_dependencies: u64,
    },
    #[doc = "An error occurred while validating actions of an ActionReceipt."]
    ActionsValidation(ActionsValidationError),
    #[doc = "Receipt is bigger than the limit."]
    ReceiptSizeExceeded { limit: u64, size: u64 },
}
impl ::std::convert::From<&Self> for ReceiptValidationError {
    fn from(value: &ReceiptValidationError) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ActionsValidationError> for ReceiptValidationError {
    fn from(value: ActionsValidationError) -> Self {
        Self::ActionsValidation(value)
    }
}
#[doc = "`ReceiptView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"predecessor_id\","]
#[doc = "    \"receipt\","]
#[doc = "    \"receipt_id\","]
#[doc = "    \"receiver_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"predecessor_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"priority\": {"]
#[doc = "      \"default\": 0,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"receipt\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/ReceiptEnumView\""]
#[doc = "    },"]
#[doc = "    \"receipt_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"receiver_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ReceiptView {
    pub predecessor_id: AccountId,
    #[serde(default)]
    pub priority: u64,
    pub receipt: ReceiptEnumView,
    pub receipt_id: CryptoHash,
    pub receiver_id: AccountId,
}
impl ::std::convert::From<&ReceiptView> for ReceiptView {
    fn from(value: &ReceiptView) -> Self {
        value.clone()
    }
}
#[doc = "`RpcBlockRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcBlockRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"block_id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"block_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"finality\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"finality\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"sync_checkpoint\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"sync_checkpoint\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum RpcBlockRequest {
    #[serde(rename = "block_id")]
    BlockId(BlockId),
    #[serde(rename = "finality")]
    Finality(Finality),
    #[serde(rename = "sync_checkpoint")]
    SyncCheckpoint(SyncCheckpoint),
}
impl ::std::convert::From<&Self> for RpcBlockRequest {
    fn from(value: &RpcBlockRequest) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BlockId> for RpcBlockRequest {
    fn from(value: BlockId) -> Self {
        Self::BlockId(value)
    }
}
impl ::std::convert::From<Finality> for RpcBlockRequest {
    fn from(value: Finality) -> Self {
        Self::Finality(value)
    }
}
impl ::std::convert::From<SyncCheckpoint> for RpcBlockRequest {
    fn from(value: SyncCheckpoint) -> Self {
        Self::SyncCheckpoint(value)
    }
}
#[doc = "`RpcBlockResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author\","]
#[doc = "    \"chunks\","]
#[doc = "    \"header\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author\": {"]
#[doc = "      \"description\": \"The AccountId of the author of the Block\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"chunks\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ChunkHeaderView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"header\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/BlockHeaderView\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcBlockResponse {
    #[doc = "The AccountId of the author of the Block"]
    pub author: AccountId,
    pub chunks: ::std::vec::Vec<ChunkHeaderView>,
    pub header: BlockHeaderView,
}
impl ::std::convert::From<&RpcBlockResponse> for RpcBlockResponse {
    fn from(value: &RpcBlockResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcChunkRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcChunkRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"block_shard_id\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"block_id\","]
#[doc = "        \"shard_id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"block_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "        },"]
#[doc = "        \"shard_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"chunk_hash\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"chunk_id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"chunk_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RpcChunkRequest {
    BlockShardId {
        block_id: BlockId,
        shard_id: ShardId,
    },
    ChunkHash {
        chunk_id: CryptoHash,
    },
}
impl ::std::convert::From<&Self> for RpcChunkRequest {
    fn from(value: &RpcChunkRequest) -> Self {
        value.clone()
    }
}
#[doc = "`RpcChunkResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"author\","]
#[doc = "    \"header\","]
#[doc = "    \"receipts\","]
#[doc = "    \"transactions\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"author\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"header\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/ChunkHeaderView\""]
#[doc = "    },"]
#[doc = "    \"receipts\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ReceiptView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"transactions\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/SignedTransactionView\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcChunkResponse {
    pub author: AccountId,
    pub header: ChunkHeaderView,
    pub receipts: ::std::vec::Vec<ReceiptView>,
    pub transactions: ::std::vec::Vec<SignedTransactionView>,
}
impl ::std::convert::From<&RpcChunkResponse> for RpcChunkResponse {
    fn from(value: &RpcChunkResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcClientConfigRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcClientConfigRequest\","]
#[doc = "  \"type\": \"null\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct RpcClientConfigRequest(pub ());
impl ::std::ops::Deref for RpcClientConfigRequest {
    type Target = ();
    fn deref(&self) -> &() {
        &self.0
    }
}
impl ::std::convert::From<RpcClientConfigRequest> for () {
    fn from(value: RpcClientConfigRequest) -> Self {
        value.0
    }
}
impl ::std::convert::From<&RpcClientConfigRequest> for RpcClientConfigRequest {
    fn from(value: &RpcClientConfigRequest) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<()> for RpcClientConfigRequest {
    fn from(value: ()) -> Self {
        Self(value)
    }
}
#[doc = "ClientConfig where some fields can be updated at runtime."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"ClientConfig where some fields can be updated at runtime.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"archive\","]
#[doc = "    \"block_fetch_horizon\","]
#[doc = "    \"block_header_fetch_horizon\","]
#[doc = "    \"block_production_tracking_delay\","]
#[doc = "    \"catchup_step_period\","]
#[doc = "    \"chain_id\","]
#[doc = "    \"chunk_request_retry_period\","]
#[doc = "    \"chunk_wait_mult\","]
#[doc = "    \"client_background_migration_threads\","]
#[doc = "    \"doomslug_step_period\","]
#[doc = "    \"enable_multiline_logging\","]
#[doc = "    \"enable_statistics_export\","]
#[doc = "    \"epoch_length\","]
#[doc = "    \"epoch_sync\","]
#[doc = "    \"expected_shutdown\","]
#[doc = "    \"gc\","]
#[doc = "    \"header_sync_expected_height_per_second\","]
#[doc = "    \"header_sync_initial_timeout\","]
#[doc = "    \"header_sync_progress_timeout\","]
#[doc = "    \"header_sync_stall_ban_timeout\","]
#[doc = "    \"log_summary_period\","]
#[doc = "    \"log_summary_style\","]
#[doc = "    \"max_block_production_delay\","]
#[doc = "    \"max_block_wait_delay\","]
#[doc = "    \"min_block_production_delay\","]
#[doc = "    \"min_num_peers\","]
#[doc = "    \"num_block_producer_seats\","]
#[doc = "    \"orphan_state_witness_max_size\","]
#[doc = "    \"orphan_state_witness_pool_size\","]
#[doc = "    \"produce_chunk_add_transactions_time_limit\","]
#[doc = "    \"produce_empty_blocks\","]
#[doc = "    \"resharding_config\","]
#[doc = "    \"save_invalid_witnesses\","]
#[doc = "    \"save_latest_witnesses\","]
#[doc = "    \"save_trie_changes\","]
#[doc = "    \"save_tx_outcomes\","]
#[doc = "    \"skip_sync_wait\","]
#[doc = "    \"state_sync\","]
#[doc = "    \"state_sync_enabled\","]
#[doc = "    \"state_sync_external_backoff\","]
#[doc = "    \"state_sync_external_timeout\","]
#[doc = "    \"state_sync_p2p_timeout\","]
#[doc = "    \"state_sync_retry_backoff\","]
#[doc = "    \"sync_check_period\","]
#[doc = "    \"sync_height_threshold\","]
#[doc = "    \"sync_max_block_requests\","]
#[doc = "    \"sync_step_period\","]
#[doc = "    \"tracked_shards_config\","]
#[doc = "    \"transaction_request_handler_threads\","]
#[doc = "    \"ttl_account_id_router\","]
#[doc = "    \"tx_routing_height_horizon\","]
#[doc = "    \"version\","]
#[doc = "    \"view_client_threads\","]
#[doc = "    \"view_client_throttle_period\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"archive\": {"]
#[doc = "      \"description\": \"Not clear old data, set `true` for archive nodes.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"block_fetch_horizon\": {"]
#[doc = "      \"description\": \"Horizon at which instead of fetching block, fetch full state.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"block_header_fetch_horizon\": {"]
#[doc = "      \"description\": \"Behind this horizon header fetch kicks in.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"block_production_tracking_delay\": {"]
#[doc = "      \"description\": \"Duration to check for producing / skipping block.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"catchup_step_period\": {"]
#[doc = "      \"description\": \"Time between check to perform catchup.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"chain_id\": {"]
#[doc = "      \"description\": \"Chain id for status.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"chunk_distribution_network\": {"]
#[doc = "      \"description\": \"Optional config for the Chunk Distribution Network feature.\\nIf set to `None` then this node does not participate in the Chunk Distribution Network.\\nNodes not participating will still function fine, but possibly with higher\\nlatency due to the need of requesting chunks over the peer-to-peer network.\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/ChunkDistributionNetworkConfig\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"chunk_request_retry_period\": {"]
#[doc = "      \"description\": \"Time between checking to re-request chunks.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"chunk_wait_mult\": {"]
#[doc = "      \"description\": \"Multiplier for the wait time for all chunks to be received.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"client_background_migration_threads\": {"]
#[doc = "      \"description\": \"Number of threads to execute background migration work in client.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"doomslug_step_period\": {"]
#[doc = "      \"description\": \"Time between running doomslug timer.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"enable_multiline_logging\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"enable_statistics_export\": {"]
#[doc = "      \"description\": \"Re-export storage layer statistics as prometheus metrics.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"epoch_length\": {"]
#[doc = "      \"description\": \"Epoch length.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"epoch_sync\": {"]
#[doc = "      \"description\": \"Options for epoch sync.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/EpochSyncConfig\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"expected_shutdown\": {"]
#[doc = "      \"description\": \"Graceful shutdown at expected block height.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/MutableConfigValue\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"gc\": {"]
#[doc = "      \"description\": \"Garbage collection configuration.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/GCConfig\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"header_sync_expected_height_per_second\": {"]
#[doc = "      \"description\": \"Expected increase of header head height per second during header sync\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"header_sync_initial_timeout\": {"]
#[doc = "      \"description\": \"How much time to wait after initial header sync\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"header_sync_progress_timeout\": {"]
#[doc = "      \"description\": \"How much time to wait after some progress is made in header sync\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"header_sync_stall_ban_timeout\": {"]
#[doc = "      \"description\": \"How much time to wait before banning a peer in header sync if sync is too slow\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"log_summary_period\": {"]
#[doc = "      \"description\": \"Period between logging summary information.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"log_summary_style\": {"]
#[doc = "      \"description\": \"Enable coloring of the logs\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/LogSummaryStyle\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"max_block_production_delay\": {"]
#[doc = "      \"description\": \"Maximum wait for approvals before producing block.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"max_block_wait_delay\": {"]
#[doc = "      \"description\": \"Maximum duration before skipping given height.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"max_gas_burnt_view\": {"]
#[doc = "      \"description\": \"Max burnt gas per view method.  If present, overrides value stored in\\ngenesis file.  The value only affects the RPCs without influencing the\\nprotocol thus changing it per-node doesn’t affect the blockchain.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"min_block_production_delay\": {"]
#[doc = "      \"description\": \"Minimum duration before producing block.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"min_num_peers\": {"]
#[doc = "      \"description\": \"Minimum number of peers to start syncing.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_block_producer_seats\": {"]
#[doc = "      \"description\": \"Number of block producer seats\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"orphan_state_witness_max_size\": {"]
#[doc = "      \"description\": \"Maximum size of state witnesses in the OrphanStateWitnessPool.\\n\\nWe keep only orphan witnesses which are smaller than this size.\\nThis limits the maximum memory usage of OrphanStateWitnessPool.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"orphan_state_witness_pool_size\": {"]
#[doc = "      \"description\": \"OrphanStateWitnessPool keeps instances of ChunkStateWitness which can't be processed\\nbecause the previous block isn't available. The witnesses wait in the pool until the\\nrequired block appears. This variable controls how many witnesses can be stored in the pool.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"produce_chunk_add_transactions_time_limit\": {"]
#[doc = "      \"description\": \"Limit the time of adding transactions to a chunk.\\nA node produces a chunk by adding transactions from the transaction pool until\\nsome limit is reached. This time limit ensures that adding transactions won't take\\nlonger than the specified duration, which helps to produce the chunk quickly.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"produce_empty_blocks\": {"]
#[doc = "      \"description\": \"Produce empty blocks, use `false` for testing.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"resharding_config\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/MutableConfigValue\""]
#[doc = "    },"]
#[doc = "    \"rpc_addr\": {"]
#[doc = "      \"description\": \"Listening rpc port for status.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"save_invalid_witnesses\": {"]
#[doc = "      \"description\": \"Save observed instances of invalid ChunkStateWitness to the database in DBCol::InvalidChunkStateWitnesses.\\nSaving invalid witnesses is useful for analysis and debugging.\\nThis option can cause extra load on the database and is not recommended for production use.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"save_latest_witnesses\": {"]
#[doc = "      \"description\": \"Save observed instances of ChunkStateWitness to the database in DBCol::LatestChunkStateWitnesses.\\nSaving the latest witnesses is useful for analysis and debugging.\\nThis option can cause extra load on the database and is not recommended for production use.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"save_trie_changes\": {"]
#[doc = "      \"description\": \"save_trie_changes should be set to true iff\\n- archive if false - non-archival nodes need trie changes to perform garbage collection\\n- archive is true, cold_store is configured and migration to split_storage is finished - node\\nworking in split storage mode needs trie changes in order to do garbage collection on hot.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"save_tx_outcomes\": {"]
#[doc = "      \"description\": \"Whether to persist transaction outcomes to disk or not.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"skip_sync_wait\": {"]
#[doc = "      \"description\": \"Skip waiting for sync (for testing or single node testnet).\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"state_sync\": {"]
#[doc = "      \"description\": \"Options for syncing state.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/StateSyncConfig\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"state_sync_enabled\": {"]
#[doc = "      \"description\": \"Whether to use the State Sync mechanism.\\nIf disabled, the node will do Block Sync instead of State Sync.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"state_sync_external_backoff\": {"]
#[doc = "      \"description\": \"Additional waiting period after a failed request to external storage\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"state_sync_external_timeout\": {"]
#[doc = "      \"description\": \"How long to wait for a response from centralized state sync\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"state_sync_p2p_timeout\": {"]
#[doc = "      \"description\": \"How long to wait for a response from p2p state sync\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"state_sync_retry_backoff\": {"]
#[doc = "      \"description\": \"How long to wait after a failed state sync request\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"sync_check_period\": {"]
#[doc = "      \"description\": \"How often to check that we are not out of sync.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"sync_height_threshold\": {"]
#[doc = "      \"description\": \"Sync height threshold: below this difference in height don't start syncing.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"sync_max_block_requests\": {"]
#[doc = "      \"description\": \"Maximum number of block requests to send to peers to sync\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"sync_step_period\": {"]
#[doc = "      \"description\": \"While syncing, how long to check for each step.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"tracked_shards_config\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/TrackedShardsConfig\""]
#[doc = "    },"]
#[doc = "    \"transaction_pool_size_limit\": {"]
#[doc = "      \"description\": \"Limit of the size of per-shard transaction pool measured in bytes. If not set, the size\\nwill be unbounded.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"transaction_request_handler_threads\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"trie_viewer_state_size_limit\": {"]
#[doc = "      \"description\": \"Upper bound of the byte size of contract state that is still viewable. None is no limit\","]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"ttl_account_id_router\": {"]
#[doc = "      \"description\": \"Time to persist Accounts Id in the router without removing them.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"tx_routing_height_horizon\": {"]
#[doc = "      \"description\": \"If the node is not a chunk producer within that many blocks, then route\\nto upcoming chunk producers.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"description\": \"Version of the binary.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Version\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"view_client_threads\": {"]
#[doc = "      \"description\": \"Number of threads for ViewClientActor pool.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"view_client_throttle_period\": {"]
#[doc = "      \"description\": \"Number of seconds between state requests for view client.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcClientConfigResponse {
    #[doc = "Not clear old data, set `true` for archive nodes."]
    pub archive: bool,
    #[doc = "Horizon at which instead of fetching block, fetch full state."]
    pub block_fetch_horizon: u64,
    #[doc = "Behind this horizon header fetch kicks in."]
    pub block_header_fetch_horizon: u64,
    #[doc = "Duration to check for producing / skipping block."]
    pub block_production_tracking_delay: [u64; 2usize],
    #[doc = "Time between check to perform catchup."]
    pub catchup_step_period: [u64; 2usize],
    #[doc = "Chain id for status."]
    pub chain_id: ::std::string::String,
    #[doc = "Optional config for the Chunk Distribution Network feature.\nIf set to `None` then this node does not participate in the Chunk Distribution Network.\nNodes not participating will still function fine, but possibly with higher\nlatency due to the need of requesting chunks over the peer-to-peer network."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub chunk_distribution_network: ::std::option::Option<ChunkDistributionNetworkConfig>,
    #[doc = "Time between checking to re-request chunks."]
    pub chunk_request_retry_period: [u64; 2usize],
    #[doc = "Multiplier for the wait time for all chunks to be received."]
    pub chunk_wait_mult: [i32; 2usize],
    #[doc = "Number of threads to execute background migration work in client."]
    pub client_background_migration_threads: u32,
    #[doc = "Time between running doomslug timer."]
    pub doomslug_step_period: [u64; 2usize],
    pub enable_multiline_logging: bool,
    #[doc = "Re-export storage layer statistics as prometheus metrics."]
    pub enable_statistics_export: bool,
    #[doc = "Epoch length."]
    pub epoch_length: u64,
    #[doc = "Options for epoch sync."]
    pub epoch_sync: EpochSyncConfig,
    #[doc = "Graceful shutdown at expected block height."]
    pub expected_shutdown: MutableConfigValue,
    #[doc = "Garbage collection configuration."]
    pub gc: GcConfig,
    #[doc = "Expected increase of header head height per second during header sync"]
    pub header_sync_expected_height_per_second: u64,
    #[doc = "How much time to wait after initial header sync"]
    pub header_sync_initial_timeout: [u64; 2usize],
    #[doc = "How much time to wait after some progress is made in header sync"]
    pub header_sync_progress_timeout: [u64; 2usize],
    #[doc = "How much time to wait before banning a peer in header sync if sync is too slow"]
    pub header_sync_stall_ban_timeout: [u64; 2usize],
    #[doc = "Period between logging summary information."]
    pub log_summary_period: [u64; 2usize],
    #[doc = "Enable coloring of the logs"]
    pub log_summary_style: LogSummaryStyle,
    #[doc = "Maximum wait for approvals before producing block."]
    pub max_block_production_delay: [u64; 2usize],
    #[doc = "Maximum duration before skipping given height."]
    pub max_block_wait_delay: [u64; 2usize],
    #[doc = "Max burnt gas per view method.  If present, overrides value stored in\ngenesis file.  The value only affects the RPCs without influencing the\nprotocol thus changing it per-node doesn’t affect the blockchain."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub max_gas_burnt_view: ::std::option::Option<u64>,
    #[doc = "Minimum duration before producing block."]
    pub min_block_production_delay: [u64; 2usize],
    #[doc = "Minimum number of peers to start syncing."]
    pub min_num_peers: u32,
    #[doc = "Number of block producer seats"]
    pub num_block_producer_seats: u64,
    #[doc = "Maximum size of state witnesses in the OrphanStateWitnessPool.\n\nWe keep only orphan witnesses which are smaller than this size.\nThis limits the maximum memory usage of OrphanStateWitnessPool."]
    pub orphan_state_witness_max_size: u64,
    #[doc = "OrphanStateWitnessPool keeps instances of ChunkStateWitness which can't be processed\nbecause the previous block isn't available. The witnesses wait in the pool until the\nrequired block appears. This variable controls how many witnesses can be stored in the pool."]
    pub orphan_state_witness_pool_size: u32,
    #[doc = "Limit the time of adding transactions to a chunk.\nA node produces a chunk by adding transactions from the transaction pool until\nsome limit is reached. This time limit ensures that adding transactions won't take\nlonger than the specified duration, which helps to produce the chunk quickly."]
    pub produce_chunk_add_transactions_time_limit: ::std::string::String,
    #[doc = "Produce empty blocks, use `false` for testing."]
    pub produce_empty_blocks: bool,
    pub resharding_config: MutableConfigValue,
    #[doc = "Listening rpc port for status."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub rpc_addr: ::std::option::Option<::std::string::String>,
    #[doc = "Save observed instances of invalid ChunkStateWitness to the database in DBCol::InvalidChunkStateWitnesses.\nSaving invalid witnesses is useful for analysis and debugging.\nThis option can cause extra load on the database and is not recommended for production use."]
    pub save_invalid_witnesses: bool,
    #[doc = "Save observed instances of ChunkStateWitness to the database in DBCol::LatestChunkStateWitnesses.\nSaving the latest witnesses is useful for analysis and debugging.\nThis option can cause extra load on the database and is not recommended for production use."]
    pub save_latest_witnesses: bool,
    #[doc = "save_trie_changes should be set to true iff\n- archive if false - non-archival nodes need trie changes to perform garbage collection\n- archive is true, cold_store is configured and migration to split_storage is finished - node\nworking in split storage mode needs trie changes in order to do garbage collection on hot."]
    pub save_trie_changes: bool,
    #[doc = "Whether to persist transaction outcomes to disk or not."]
    pub save_tx_outcomes: bool,
    #[doc = "Skip waiting for sync (for testing or single node testnet)."]
    pub skip_sync_wait: bool,
    #[doc = "Options for syncing state."]
    pub state_sync: StateSyncConfig,
    #[doc = "Whether to use the State Sync mechanism.\nIf disabled, the node will do Block Sync instead of State Sync."]
    pub state_sync_enabled: bool,
    #[doc = "Additional waiting period after a failed request to external storage"]
    pub state_sync_external_backoff: [u64; 2usize],
    #[doc = "How long to wait for a response from centralized state sync"]
    pub state_sync_external_timeout: [u64; 2usize],
    #[doc = "How long to wait for a response from p2p state sync"]
    pub state_sync_p2p_timeout: [u64; 2usize],
    #[doc = "How long to wait after a failed state sync request"]
    pub state_sync_retry_backoff: [u64; 2usize],
    #[doc = "How often to check that we are not out of sync."]
    pub sync_check_period: [u64; 2usize],
    #[doc = "Sync height threshold: below this difference in height don't start syncing."]
    pub sync_height_threshold: u64,
    #[doc = "Maximum number of block requests to send to peers to sync"]
    pub sync_max_block_requests: u32,
    #[doc = "While syncing, how long to check for each step."]
    pub sync_step_period: [u64; 2usize],
    pub tracked_shards_config: TrackedShardsConfig,
    #[doc = "Limit of the size of per-shard transaction pool measured in bytes. If not set, the size\nwill be unbounded."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub transaction_pool_size_limit: ::std::option::Option<u64>,
    pub transaction_request_handler_threads: u32,
    #[doc = "Upper bound of the byte size of contract state that is still viewable. None is no limit"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub trie_viewer_state_size_limit: ::std::option::Option<u64>,
    #[doc = "Time to persist Accounts Id in the router without removing them."]
    pub ttl_account_id_router: [u64; 2usize],
    #[doc = "If the node is not a chunk producer within that many blocks, then route\nto upcoming chunk producers."]
    pub tx_routing_height_horizon: u64,
    #[doc = "Version of the binary."]
    pub version: Version,
    #[doc = "Number of threads for ViewClientActor pool."]
    pub view_client_threads: u32,
    #[doc = "Number of seconds between state requests for view client."]
    pub view_client_throttle_period: [u64; 2usize],
}
impl ::std::convert::From<&RpcClientConfigResponse> for RpcClientConfigResponse {
    fn from(value: &RpcClientConfigResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcCongestionLevelRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcCongestionLevelRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"block_shard_id\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"block_id\","]
#[doc = "        \"shard_id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"block_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "        },"]
#[doc = "        \"shard_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"chunk_hash\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"chunk_id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"chunk_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RpcCongestionLevelRequest {
    BlockShardId {
        block_id: BlockId,
        shard_id: ShardId,
    },
    ChunkHash {
        chunk_id: CryptoHash,
    },
}
impl ::std::convert::From<&Self> for RpcCongestionLevelRequest {
    fn from(value: &RpcCongestionLevelRequest) -> Self {
        value.clone()
    }
}
#[doc = "`RpcCongestionLevelResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"congestion_level\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"congestion_level\": {"]
#[doc = "      \"type\": \"number\","]
#[doc = "      \"format\": \"double\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcCongestionLevelResponse {
    pub congestion_level: f64,
}
impl ::std::convert::From<&RpcCongestionLevelResponse> for RpcCongestionLevelResponse {
    fn from(value: &RpcCongestionLevelResponse) -> Self {
        value.clone()
    }
}
#[doc = "This struct may be returned from JSON RPC server in case of error\nIt is expected that this struct has impl From<_> all other RPC errors\nlike [RpcBlockError](crate::types::blocks::RpcBlockError)"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"This struct may be returned from JSON RPC server in case of error\\nIt is expected that this struct has impl From<_> all other RPC errors\\nlike [RpcBlockError](crate::types::blocks::RpcBlockError)\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"cause\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"cause\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/RpcRequestValidationErrorKind\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"REQUEST_VALIDATION_ERROR\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"cause\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"cause\": {},"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"HANDLER_ERROR\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"cause\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"cause\": {},"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"INTERNAL_ERROR\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"code\","]
#[doc = "    \"message\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cause\": {},"]
#[doc = "    \"code\": {"]
#[doc = "      \"description\": \"Deprecated please use the `error_struct` instead\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"int64\""]
#[doc = "    },"]
#[doc = "    \"data\": {"]
#[doc = "      \"description\": \"Deprecated please use the `error_struct` instead\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"description\": \"Deprecated please use the `error_struct` instead\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"name\": {}"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged, deny_unknown_fields)]
pub enum RpcError {
    Variant0 {
        cause: RpcRequestValidationErrorKind,
        #[doc = "Deprecated please use the `error_struct` instead"]
        code: i64,
        #[doc = "Deprecated please use the `error_struct` instead"]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        data: ::std::option::Option<::serde_json::Value>,
        #[doc = "Deprecated please use the `error_struct` instead"]
        message: ::std::string::String,
        name: RpcErrorVariant0Name,
    },
    Variant1 {
        cause: ::serde_json::Value,
        #[doc = "Deprecated please use the `error_struct` instead"]
        code: i64,
        #[doc = "Deprecated please use the `error_struct` instead"]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        data: ::std::option::Option<::serde_json::Value>,
        #[doc = "Deprecated please use the `error_struct` instead"]
        message: ::std::string::String,
        name: RpcErrorVariant1Name,
    },
    Variant2 {
        cause: ::serde_json::Value,
        #[doc = "Deprecated please use the `error_struct` instead"]
        code: i64,
        #[doc = "Deprecated please use the `error_struct` instead"]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        data: ::std::option::Option<::serde_json::Value>,
        #[doc = "Deprecated please use the `error_struct` instead"]
        message: ::std::string::String,
        name: RpcErrorVariant2Name,
    },
}
impl ::std::convert::From<&Self> for RpcError {
    fn from(value: &RpcError) -> Self {
        value.clone()
    }
}
#[doc = "`RpcErrorVariant0Name`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"REQUEST_VALIDATION_ERROR\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RpcErrorVariant0Name {
    #[serde(rename = "REQUEST_VALIDATION_ERROR")]
    RequestValidationError,
}
impl ::std::convert::From<&Self> for RpcErrorVariant0Name {
    fn from(value: &RpcErrorVariant0Name) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RpcErrorVariant0Name {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::RequestValidationError => write!(f, "REQUEST_VALIDATION_ERROR"),
        }
    }
}
impl ::std::str::FromStr for RpcErrorVariant0Name {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "REQUEST_VALIDATION_ERROR" => Ok(Self::RequestValidationError),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RpcErrorVariant0Name {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RpcErrorVariant0Name {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RpcErrorVariant0Name {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RpcErrorVariant1Name`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"HANDLER_ERROR\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RpcErrorVariant1Name {
    #[serde(rename = "HANDLER_ERROR")]
    HandlerError,
}
impl ::std::convert::From<&Self> for RpcErrorVariant1Name {
    fn from(value: &RpcErrorVariant1Name) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RpcErrorVariant1Name {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::HandlerError => write!(f, "HANDLER_ERROR"),
        }
    }
}
impl ::std::str::FromStr for RpcErrorVariant1Name {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "HANDLER_ERROR" => Ok(Self::HandlerError),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RpcErrorVariant1Name {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RpcErrorVariant1Name {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RpcErrorVariant1Name {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RpcErrorVariant2Name`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"INTERNAL_ERROR\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RpcErrorVariant2Name {
    #[serde(rename = "INTERNAL_ERROR")]
    InternalError,
}
impl ::std::convert::From<&Self> for RpcErrorVariant2Name {
    fn from(value: &RpcErrorVariant2Name) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RpcErrorVariant2Name {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::InternalError => write!(f, "INTERNAL_ERROR"),
        }
    }
}
impl ::std::str::FromStr for RpcErrorVariant2Name {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "INTERNAL_ERROR" => Ok(Self::InternalError),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RpcErrorVariant2Name {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RpcErrorVariant2Name {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RpcErrorVariant2Name {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RpcGasPriceRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcGasPriceRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"block_id\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcGasPriceRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub block_id: ::std::option::Option<BlockId>,
}
impl ::std::convert::From<&RpcGasPriceRequest> for RpcGasPriceRequest {
    fn from(value: &RpcGasPriceRequest) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RpcGasPriceRequest {
    fn default() -> Self {
        Self {
            block_id: Default::default(),
        }
    }
}
#[doc = "`RpcGasPriceResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"gas_price\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"gas_price\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcGasPriceResponse {
    pub gas_price: ::std::string::String,
}
impl ::std::convert::From<&RpcGasPriceResponse> for RpcGasPriceResponse {
    fn from(value: &RpcGasPriceResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcHealthRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcHealthRequest\","]
#[doc = "  \"type\": \"null\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct RpcHealthRequest(pub ());
impl ::std::ops::Deref for RpcHealthRequest {
    type Target = ();
    fn deref(&self) -> &() {
        &self.0
    }
}
impl ::std::convert::From<RpcHealthRequest> for () {
    fn from(value: RpcHealthRequest) -> Self {
        value.0
    }
}
impl ::std::convert::From<&RpcHealthRequest> for RpcHealthRequest {
    fn from(value: &RpcHealthRequest) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<()> for RpcHealthRequest {
    fn from(value: ()) -> Self {
        Self(value)
    }
}
#[doc = "`RpcHealthResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"null\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct RpcHealthResponse(pub ());
impl ::std::ops::Deref for RpcHealthResponse {
    type Target = ();
    fn deref(&self) -> &() {
        &self.0
    }
}
impl ::std::convert::From<RpcHealthResponse> for () {
    fn from(value: RpcHealthResponse) -> Self {
        value.0
    }
}
impl ::std::convert::From<&RpcHealthResponse> for RpcHealthResponse {
    fn from(value: &RpcHealthResponse) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<()> for RpcHealthResponse {
    fn from(value: ()) -> Self {
        Self(value)
    }
}
#[doc = "`RpcKnownProducer`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"peer_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"addr\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"peer_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PeerId\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcKnownProducer {
    pub account_id: AccountId,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub addr: ::std::option::Option<::std::string::String>,
    pub peer_id: PeerId,
}
impl ::std::convert::From<&RpcKnownProducer> for RpcKnownProducer {
    fn from(value: &RpcKnownProducer) -> Self {
        value.clone()
    }
}
#[doc = "`RpcLightClientBlockProofRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcLightClientBlockProofRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"block_hash\","]
#[doc = "    \"light_client_head\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"block_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"light_client_head\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcLightClientBlockProofRequest {
    pub block_hash: CryptoHash,
    pub light_client_head: CryptoHash,
}
impl ::std::convert::From<&RpcLightClientBlockProofRequest> for RpcLightClientBlockProofRequest {
    fn from(value: &RpcLightClientBlockProofRequest) -> Self {
        value.clone()
    }
}
#[doc = "`RpcLightClientBlockProofResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"block_header_lite\","]
#[doc = "    \"block_proof\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"block_header_lite\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/LightClientBlockLiteView\""]
#[doc = "    },"]
#[doc = "    \"block_proof\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/MerklePathItem\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcLightClientBlockProofResponse {
    pub block_header_lite: LightClientBlockLiteView,
    pub block_proof: ::std::vec::Vec<MerklePathItem>,
}
impl ::std::convert::From<&RpcLightClientBlockProofResponse> for RpcLightClientBlockProofResponse {
    fn from(value: &RpcLightClientBlockProofResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcLightClientExecutionProofRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcLightClientExecutionProofRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"transaction\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"sender_id\","]
#[doc = "        \"transaction_hash\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"sender_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        },"]
#[doc = "        \"transaction_hash\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"transaction\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"receipt\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"receipt_id\","]
#[doc = "        \"receiver_id\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"receipt_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        },"]
#[doc = "        \"receiver_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"receipt\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"light_client_head\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"light_client_head\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RpcLightClientExecutionProofRequest {
    Variant0 {
        light_client_head: CryptoHash,
        sender_id: AccountId,
        transaction_hash: CryptoHash,
        #[serde(rename = "type")]
        type_: RpcLightClientExecutionProofRequestVariant0Type,
    },
    Variant1 {
        light_client_head: CryptoHash,
        receipt_id: CryptoHash,
        receiver_id: AccountId,
        #[serde(rename = "type")]
        type_: RpcLightClientExecutionProofRequestVariant1Type,
    },
}
impl ::std::convert::From<&Self> for RpcLightClientExecutionProofRequest {
    fn from(value: &RpcLightClientExecutionProofRequest) -> Self {
        value.clone()
    }
}
#[doc = "`RpcLightClientExecutionProofRequestVariant0Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"transaction\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RpcLightClientExecutionProofRequestVariant0Type {
    #[serde(rename = "transaction")]
    Transaction,
}
impl ::std::convert::From<&Self> for RpcLightClientExecutionProofRequestVariant0Type {
    fn from(value: &RpcLightClientExecutionProofRequestVariant0Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RpcLightClientExecutionProofRequestVariant0Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Transaction => write!(f, "transaction"),
        }
    }
}
impl ::std::str::FromStr for RpcLightClientExecutionProofRequestVariant0Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "transaction" => Ok(Self::Transaction),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RpcLightClientExecutionProofRequestVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for RpcLightClientExecutionProofRequestVariant0Type
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for RpcLightClientExecutionProofRequestVariant0Type
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RpcLightClientExecutionProofRequestVariant1Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"receipt\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum RpcLightClientExecutionProofRequestVariant1Type {
    #[serde(rename = "receipt")]
    Receipt,
}
impl ::std::convert::From<&Self> for RpcLightClientExecutionProofRequestVariant1Type {
    fn from(value: &RpcLightClientExecutionProofRequestVariant1Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for RpcLightClientExecutionProofRequestVariant1Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Receipt => write!(f, "receipt"),
        }
    }
}
impl ::std::str::FromStr for RpcLightClientExecutionProofRequestVariant1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "receipt" => Ok(Self::Receipt),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for RpcLightClientExecutionProofRequestVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for RpcLightClientExecutionProofRequestVariant1Type
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for RpcLightClientExecutionProofRequestVariant1Type
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`RpcLightClientExecutionProofResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"block_header_lite\","]
#[doc = "    \"block_proof\","]
#[doc = "    \"outcome_proof\","]
#[doc = "    \"outcome_root_proof\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"block_header_lite\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/LightClientBlockLiteView\""]
#[doc = "    },"]
#[doc = "    \"block_proof\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/MerklePathItem\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"outcome_proof\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/ExecutionOutcomeWithIdView\""]
#[doc = "    },"]
#[doc = "    \"outcome_root_proof\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/MerklePathItem\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcLightClientExecutionProofResponse {
    pub block_header_lite: LightClientBlockLiteView,
    pub block_proof: ::std::vec::Vec<MerklePathItem>,
    pub outcome_proof: ExecutionOutcomeWithIdView,
    pub outcome_root_proof: ::std::vec::Vec<MerklePathItem>,
}
impl ::std::convert::From<&RpcLightClientExecutionProofResponse>
    for RpcLightClientExecutionProofResponse
{
    fn from(value: &RpcLightClientExecutionProofResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcLightClientNextBlockRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcLightClientNextBlockRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"last_block_hash\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"last_block_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcLightClientNextBlockRequest {
    pub last_block_hash: CryptoHash,
}
impl ::std::convert::From<&RpcLightClientNextBlockRequest> for RpcLightClientNextBlockRequest {
    fn from(value: &RpcLightClientNextBlockRequest) -> Self {
        value.clone()
    }
}
#[doc = "A state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A state for the current head of a light client. More info [here](https://nomicon.io/ChainSpec/LightClient).\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"approvals_after_next\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"anyOf\": ["]
#[doc = "          {"]
#[doc = "            \"$ref\": \"#/components/schemas/Signature\""]
#[doc = "          },"]
#[doc = "          {"]
#[doc = "            \"type\": \"null\""]
#[doc = "          }"]
#[doc = "        ]"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"inner_lite\": {"]
#[doc = "      \"description\": \"Inner part of the block header that gets hashed, split into two parts, one that is sent\\n   to light clients, and the rest\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/BlockHeaderInnerLiteView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"inner_rest_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"next_block_inner_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"next_bps\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"array\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ValidatorStakeView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"prev_block_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcLightClientNextBlockResponse {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub approvals_after_next: ::std::vec::Vec<::std::option::Option<Signature>>,
    #[doc = "Inner part of the block header that gets hashed, split into two parts, one that is sent\n   to light clients, and the rest"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub inner_lite: ::std::option::Option<BlockHeaderInnerLiteView>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub inner_rest_hash: ::std::option::Option<CryptoHash>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub next_block_inner_hash: ::std::option::Option<CryptoHash>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub next_bps: ::std::option::Option<::std::vec::Vec<ValidatorStakeView>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub prev_block_hash: ::std::option::Option<CryptoHash>,
}
impl ::std::convert::From<&RpcLightClientNextBlockResponse> for RpcLightClientNextBlockResponse {
    fn from(value: &RpcLightClientNextBlockResponse) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RpcLightClientNextBlockResponse {
    fn default() -> Self {
        Self {
            approvals_after_next: Default::default(),
            inner_lite: Default::default(),
            inner_rest_hash: Default::default(),
            next_block_inner_hash: Default::default(),
            next_bps: Default::default(),
            prev_block_hash: Default::default(),
        }
    }
}
#[doc = "`RpcMaintenanceWindowsRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcMaintenanceWindowsRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcMaintenanceWindowsRequest {
    pub account_id: AccountId,
}
impl ::std::convert::From<&RpcMaintenanceWindowsRequest> for RpcMaintenanceWindowsRequest {
    fn from(value: &RpcMaintenanceWindowsRequest) -> Self {
        value.clone()
    }
}
#[doc = "`RpcNetworkInfoRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcNetworkInfoRequest\","]
#[doc = "  \"type\": \"null\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct RpcNetworkInfoRequest(pub ());
impl ::std::ops::Deref for RpcNetworkInfoRequest {
    type Target = ();
    fn deref(&self) -> &() {
        &self.0
    }
}
impl ::std::convert::From<RpcNetworkInfoRequest> for () {
    fn from(value: RpcNetworkInfoRequest) -> Self {
        value.0
    }
}
impl ::std::convert::From<&RpcNetworkInfoRequest> for RpcNetworkInfoRequest {
    fn from(value: &RpcNetworkInfoRequest) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<()> for RpcNetworkInfoRequest {
    fn from(value: ()) -> Self {
        Self(value)
    }
}
#[doc = "`RpcNetworkInfoResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"active_peers\","]
#[doc = "    \"known_producers\","]
#[doc = "    \"num_active_peers\","]
#[doc = "    \"peer_max_count\","]
#[doc = "    \"received_bytes_per_sec\","]
#[doc = "    \"sent_bytes_per_sec\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"active_peers\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/RpcPeerInfo\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"known_producers\": {"]
#[doc = "      \"description\": \"Accounts of known block and chunk producers from routing table.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/RpcKnownProducer\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"num_active_peers\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"peer_max_count\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"received_bytes_per_sec\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"sent_bytes_per_sec\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcNetworkInfoResponse {
    pub active_peers: ::std::vec::Vec<RpcPeerInfo>,
    #[doc = "Accounts of known block and chunk producers from routing table."]
    pub known_producers: ::std::vec::Vec<RpcKnownProducer>,
    pub num_active_peers: u32,
    pub peer_max_count: u32,
    pub received_bytes_per_sec: u64,
    pub sent_bytes_per_sec: u64,
}
impl ::std::convert::From<&RpcNetworkInfoResponse> for RpcNetworkInfoResponse {
    fn from(value: &RpcNetworkInfoResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcPeerInfo`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"addr\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PeerId\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcPeerInfo {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub account_id: ::std::option::Option<AccountId>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub addr: ::std::option::Option<::std::string::String>,
    pub id: PeerId,
}
impl ::std::convert::From<&RpcPeerInfo> for RpcPeerInfo {
    fn from(value: &RpcPeerInfo) -> Self {
        value.clone()
    }
}
#[doc = "`RpcProtocolConfigRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcProtocolConfigRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"block_id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"block_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"finality\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"finality\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"sync_checkpoint\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"sync_checkpoint\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum RpcProtocolConfigRequest {
    #[serde(rename = "block_id")]
    BlockId(BlockId),
    #[serde(rename = "finality")]
    Finality(Finality),
    #[serde(rename = "sync_checkpoint")]
    SyncCheckpoint(SyncCheckpoint),
}
impl ::std::convert::From<&Self> for RpcProtocolConfigRequest {
    fn from(value: &RpcProtocolConfigRequest) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BlockId> for RpcProtocolConfigRequest {
    fn from(value: BlockId) -> Self {
        Self::BlockId(value)
    }
}
impl ::std::convert::From<Finality> for RpcProtocolConfigRequest {
    fn from(value: Finality) -> Self {
        Self::Finality(value)
    }
}
impl ::std::convert::From<SyncCheckpoint> for RpcProtocolConfigRequest {
    fn from(value: SyncCheckpoint) -> Self {
        Self::SyncCheckpoint(value)
    }
}
#[doc = "`RpcProtocolConfigResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"avg_hidden_validator_seats_per_shard\","]
#[doc = "    \"block_producer_kickout_threshold\","]
#[doc = "    \"chain_id\","]
#[doc = "    \"chunk_producer_kickout_threshold\","]
#[doc = "    \"chunk_validator_only_kickout_threshold\","]
#[doc = "    \"dynamic_resharding\","]
#[doc = "    \"epoch_length\","]
#[doc = "    \"fishermen_threshold\","]
#[doc = "    \"gas_limit\","]
#[doc = "    \"gas_price_adjustment_rate\","]
#[doc = "    \"genesis_height\","]
#[doc = "    \"genesis_time\","]
#[doc = "    \"max_gas_price\","]
#[doc = "    \"max_inflation_rate\","]
#[doc = "    \"max_kickout_stake_perc\","]
#[doc = "    \"min_gas_price\","]
#[doc = "    \"minimum_stake_divisor\","]
#[doc = "    \"minimum_stake_ratio\","]
#[doc = "    \"minimum_validators_per_shard\","]
#[doc = "    \"num_block_producer_seats\","]
#[doc = "    \"num_block_producer_seats_per_shard\","]
#[doc = "    \"num_blocks_per_year\","]
#[doc = "    \"online_max_threshold\","]
#[doc = "    \"online_min_threshold\","]
#[doc = "    \"protocol_reward_rate\","]
#[doc = "    \"protocol_treasury_account\","]
#[doc = "    \"protocol_upgrade_stake_threshold\","]
#[doc = "    \"protocol_version\","]
#[doc = "    \"runtime_config\","]
#[doc = "    \"shard_layout\","]
#[doc = "    \"shuffle_shard_assignment_for_chunk_producers\","]
#[doc = "    \"target_validator_mandates_per_shard\","]
#[doc = "    \"transaction_validity_period\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"avg_hidden_validator_seats_per_shard\": {"]
#[doc = "      \"description\": \"Expected number of hidden validators per shard.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"block_producer_kickout_threshold\": {"]
#[doc = "      \"description\": \"Threshold for kicking out block producers, between 0 and 100.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint8\","]
#[doc = "      \"maximum\": 255.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"chain_id\": {"]
#[doc = "      \"description\": \"ID of the blockchain. This must be unique for every blockchain.\\nIf your testnet blockchains do not have unique chain IDs, you will have a bad time.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"chunk_producer_kickout_threshold\": {"]
#[doc = "      \"description\": \"Threshold for kicking out chunk producers, between 0 and 100.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint8\","]
#[doc = "      \"maximum\": 255.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"chunk_validator_only_kickout_threshold\": {"]
#[doc = "      \"description\": \"Threshold for kicking out nodes which are only chunk validators, between 0 and 100.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint8\","]
#[doc = "      \"maximum\": 255.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"dynamic_resharding\": {"]
#[doc = "      \"description\": \"Enable dynamic re-sharding.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"epoch_length\": {"]
#[doc = "      \"description\": \"Epoch length counted in block heights.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"fishermen_threshold\": {"]
#[doc = "      \"description\": \"Fishermen stake threshold.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"gas_limit\": {"]
#[doc = "      \"description\": \"Initial gas limit.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"gas_price_adjustment_rate\": {"]
#[doc = "      \"description\": \"Gas price adjustment rate\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"genesis_height\": {"]
#[doc = "      \"description\": \"Height of genesis block.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"genesis_time\": {"]
#[doc = "      \"description\": \"Official time of blockchain start.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    \"max_gas_price\": {"]
#[doc = "      \"description\": \"Maximum gas price.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"max_inflation_rate\": {"]
#[doc = "      \"description\": \"Maximum inflation on the total supply every epoch.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"max_kickout_stake_perc\": {"]
#[doc = "      \"description\": \"Max stake percentage of the validators we will kick out.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint8\","]
#[doc = "      \"maximum\": 255.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"min_gas_price\": {"]
#[doc = "      \"description\": \"Minimum gas price. It is also the initial gas price.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"minimum_stake_divisor\": {"]
#[doc = "      \"description\": \"The minimum stake required for staking is last seat price divided by this number.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"minimum_stake_ratio\": {"]
#[doc = "      \"description\": \"The lowest ratio s/s_total any block producer can have.\\nSee <https://github.com/near/NEPs/pull/167> for details\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"minimum_validators_per_shard\": {"]
#[doc = "      \"description\": \"The minimum number of validators each shard must have\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_block_producer_seats\": {"]
#[doc = "      \"description\": \"Number of block producer seats at genesis.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_block_producer_seats_per_shard\": {"]
#[doc = "      \"description\": \"Defines number of shards and number of block producer seats per each shard at genesis.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint64\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"num_blocks_per_year\": {"]
#[doc = "      \"description\": \"Expected number of blocks per year\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"online_max_threshold\": {"]
#[doc = "      \"description\": \"Online maximum threshold above which validator gets full reward.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"online_min_threshold\": {"]
#[doc = "      \"description\": \"Online minimum threshold below which validator doesn't receive reward.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"protocol_reward_rate\": {"]
#[doc = "      \"description\": \"Protocol treasury rate\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"protocol_treasury_account\": {"]
#[doc = "      \"description\": \"Protocol treasury account\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"protocol_upgrade_stake_threshold\": {"]
#[doc = "      \"description\": \"Threshold of stake that needs to indicate that they ready for upgrade.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"protocol_version\": {"]
#[doc = "      \"description\": \"Current Protocol Version\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"runtime_config\": {"]
#[doc = "      \"description\": \"Runtime configuration (mostly economics constants).\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/RuntimeConfigView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"shard_layout\": {"]
#[doc = "      \"description\": \"Layout information regarding how to split accounts to shards\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/ShardLayout\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"shuffle_shard_assignment_for_chunk_producers\": {"]
#[doc = "      \"description\": \"If true, shuffle the chunk producers across shards. In other words, if\\nthe shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents\\nthe set of chunk producers for shard `i`, if this flag were true, the\\nshard assignments might become, for example, `[S_2, S_0, S_3, S_1]`.\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"target_validator_mandates_per_shard\": {"]
#[doc = "      \"description\": \"Number of target chunk validator mandates for each shard.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"transaction_validity_period\": {"]
#[doc = "      \"description\": \"Number of blocks for which a given transaction is valid\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcProtocolConfigResponse {
    #[doc = "Expected number of hidden validators per shard."]
    pub avg_hidden_validator_seats_per_shard: ::std::vec::Vec<u64>,
    #[doc = "Threshold for kicking out block producers, between 0 and 100."]
    pub block_producer_kickout_threshold: u8,
    #[doc = "ID of the blockchain. This must be unique for every blockchain.\nIf your testnet blockchains do not have unique chain IDs, you will have a bad time."]
    pub chain_id: ::std::string::String,
    #[doc = "Threshold for kicking out chunk producers, between 0 and 100."]
    pub chunk_producer_kickout_threshold: u8,
    #[doc = "Threshold for kicking out nodes which are only chunk validators, between 0 and 100."]
    pub chunk_validator_only_kickout_threshold: u8,
    #[doc = "Enable dynamic re-sharding."]
    pub dynamic_resharding: bool,
    #[doc = "Epoch length counted in block heights."]
    pub epoch_length: u64,
    #[doc = "Fishermen stake threshold."]
    pub fishermen_threshold: ::std::string::String,
    #[doc = "Initial gas limit."]
    pub gas_limit: u64,
    #[doc = "Gas price adjustment rate"]
    pub gas_price_adjustment_rate: [i32; 2usize],
    #[doc = "Height of genesis block."]
    pub genesis_height: u64,
    #[doc = "Official time of blockchain start."]
    pub genesis_time: ::chrono::DateTime<::chrono::offset::Utc>,
    #[doc = "Maximum gas price."]
    pub max_gas_price: ::std::string::String,
    #[doc = "Maximum inflation on the total supply every epoch."]
    pub max_inflation_rate: [i32; 2usize],
    #[doc = "Max stake percentage of the validators we will kick out."]
    pub max_kickout_stake_perc: u8,
    #[doc = "Minimum gas price. It is also the initial gas price."]
    pub min_gas_price: ::std::string::String,
    #[doc = "The minimum stake required for staking is last seat price divided by this number."]
    pub minimum_stake_divisor: u64,
    #[doc = "The lowest ratio s/s_total any block producer can have.\nSee <https://github.com/near/NEPs/pull/167> for details"]
    pub minimum_stake_ratio: [i32; 2usize],
    #[doc = "The minimum number of validators each shard must have"]
    pub minimum_validators_per_shard: u64,
    #[doc = "Number of block producer seats at genesis."]
    pub num_block_producer_seats: u64,
    #[doc = "Defines number of shards and number of block producer seats per each shard at genesis."]
    pub num_block_producer_seats_per_shard: ::std::vec::Vec<u64>,
    #[doc = "Expected number of blocks per year"]
    pub num_blocks_per_year: u64,
    #[doc = "Online maximum threshold above which validator gets full reward."]
    pub online_max_threshold: [i32; 2usize],
    #[doc = "Online minimum threshold below which validator doesn't receive reward."]
    pub online_min_threshold: [i32; 2usize],
    #[doc = "Protocol treasury rate"]
    pub protocol_reward_rate: [i32; 2usize],
    #[doc = "Protocol treasury account"]
    pub protocol_treasury_account: AccountId,
    #[doc = "Threshold of stake that needs to indicate that they ready for upgrade."]
    pub protocol_upgrade_stake_threshold: [i32; 2usize],
    #[doc = "Current Protocol Version"]
    pub protocol_version: u32,
    #[doc = "Runtime configuration (mostly economics constants)."]
    pub runtime_config: RuntimeConfigView,
    #[doc = "Layout information regarding how to split accounts to shards"]
    pub shard_layout: ShardLayout,
    #[doc = "If true, shuffle the chunk producers across shards. In other words, if\nthe shard assignments were `[S_0, S_1, S_2, S_3]` where `S_i` represents\nthe set of chunk producers for shard `i`, if this flag were true, the\nshard assignments might become, for example, `[S_2, S_0, S_3, S_1]`."]
    pub shuffle_shard_assignment_for_chunk_producers: bool,
    #[doc = "Number of target chunk validator mandates for each shard."]
    pub target_validator_mandates_per_shard: u64,
    #[doc = "Number of blocks for which a given transaction is valid"]
    pub transaction_validity_period: u64,
}
impl ::std::convert::From<&RpcProtocolConfigResponse> for RpcProtocolConfigResponse {
    fn from(value: &RpcProtocolConfigResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcQueryRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcQueryRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"view_account_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_account\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_code_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_code\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_state_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"prefix_base64\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"include_proof\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"prefix_base64\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/StoreKey\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_state\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_access_key_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"public_key\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_access_key\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_access_key_list_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_access_key_list\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"call_function_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"args_base64\","]
#[doc = "            \"method_name\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"args_base64\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/FunctionArgs\""]
#[doc = "            },"]
#[doc = "            \"method_name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"call_function\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_global_contract_code_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"code_hash\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"code_hash\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_global_contract_code\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_global_contract_code_by_account_id_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_global_contract_code_by_account_id\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_account_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_account\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_code_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_code\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_state_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"prefix_base64\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"include_proof\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"prefix_base64\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/StoreKey\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_state\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_access_key_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"public_key\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_access_key\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_access_key_list_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_access_key_list\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"call_function_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"args_base64\","]
#[doc = "            \"method_name\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"args_base64\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/FunctionArgs\""]
#[doc = "            },"]
#[doc = "            \"method_name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"call_function\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_global_contract_code_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"code_hash\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"code_hash\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_global_contract_code\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_global_contract_code_by_account_id_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_global_contract_code_by_account_id\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_account_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_account\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_code_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_code\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_state_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"prefix_base64\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"include_proof\": {"]
#[doc = "              \"type\": \"boolean\""]
#[doc = "            },"]
#[doc = "            \"prefix_base64\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/StoreKey\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_state\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_access_key_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"public_key\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_access_key\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_access_key_list_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_access_key_list\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"call_function_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"args_base64\","]
#[doc = "            \"method_name\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"args_base64\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/FunctionArgs\""]
#[doc = "            },"]
#[doc = "            \"method_name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"call_function\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_global_contract_code_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"code_hash\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"code_hash\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_global_contract_code\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"view_global_contract_code_by_account_id_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"request_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"request_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"view_global_contract_code_by_account_id\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RpcQueryRequest {
    ViewAccountByBlockId {
        account_id: AccountId,
        block_id: BlockId,
        request_type: ViewAccountByBlockIdRequestType,
    },
    ViewCodeByBlockId {
        account_id: AccountId,
        block_id: BlockId,
        request_type: ViewCodeByBlockIdRequestType,
    },
    ViewStateByBlockId {
        account_id: AccountId,
        block_id: BlockId,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        include_proof: ::std::option::Option<bool>,
        prefix_base64: StoreKey,
        request_type: ViewStateByBlockIdRequestType,
    },
    ViewAccessKeyByBlockId {
        account_id: AccountId,
        block_id: BlockId,
        public_key: PublicKey,
        request_type: ViewAccessKeyByBlockIdRequestType,
    },
    ViewAccessKeyListByBlockId {
        account_id: AccountId,
        block_id: BlockId,
        request_type: ViewAccessKeyListByBlockIdRequestType,
    },
    CallFunctionByBlockId {
        account_id: AccountId,
        args_base64: FunctionArgs,
        block_id: BlockId,
        method_name: ::std::string::String,
        request_type: CallFunctionByBlockIdRequestType,
    },
    ViewGlobalContractCodeByBlockId {
        block_id: BlockId,
        code_hash: CryptoHash,
        request_type: ViewGlobalContractCodeByBlockIdRequestType,
    },
    ViewGlobalContractCodeByAccountIdByBlockId {
        account_id: AccountId,
        block_id: BlockId,
        request_type: ViewGlobalContractCodeByAccountIdByBlockIdRequestType,
    },
    ViewAccountByFinality {
        account_id: AccountId,
        finality: Finality,
        request_type: ViewAccountByFinalityRequestType,
    },
    ViewCodeByFinality {
        account_id: AccountId,
        finality: Finality,
        request_type: ViewCodeByFinalityRequestType,
    },
    ViewStateByFinality {
        account_id: AccountId,
        finality: Finality,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        include_proof: ::std::option::Option<bool>,
        prefix_base64: StoreKey,
        request_type: ViewStateByFinalityRequestType,
    },
    ViewAccessKeyByFinality {
        account_id: AccountId,
        finality: Finality,
        public_key: PublicKey,
        request_type: ViewAccessKeyByFinalityRequestType,
    },
    ViewAccessKeyListByFinality {
        account_id: AccountId,
        finality: Finality,
        request_type: ViewAccessKeyListByFinalityRequestType,
    },
    CallFunctionByFinality {
        account_id: AccountId,
        args_base64: FunctionArgs,
        finality: Finality,
        method_name: ::std::string::String,
        request_type: CallFunctionByFinalityRequestType,
    },
    ViewGlobalContractCodeByFinality {
        code_hash: CryptoHash,
        finality: Finality,
        request_type: ViewGlobalContractCodeByFinalityRequestType,
    },
    ViewGlobalContractCodeByAccountIdByFinality {
        account_id: AccountId,
        finality: Finality,
        request_type: ViewGlobalContractCodeByAccountIdByFinalityRequestType,
    },
    ViewAccountBySyncCheckpoint {
        account_id: AccountId,
        request_type: ViewAccountBySyncCheckpointRequestType,
        sync_checkpoint: SyncCheckpoint,
    },
    ViewCodeBySyncCheckpoint {
        account_id: AccountId,
        request_type: ViewCodeBySyncCheckpointRequestType,
        sync_checkpoint: SyncCheckpoint,
    },
    ViewStateBySyncCheckpoint {
        account_id: AccountId,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        include_proof: ::std::option::Option<bool>,
        prefix_base64: StoreKey,
        request_type: ViewStateBySyncCheckpointRequestType,
        sync_checkpoint: SyncCheckpoint,
    },
    ViewAccessKeyBySyncCheckpoint {
        account_id: AccountId,
        public_key: PublicKey,
        request_type: ViewAccessKeyBySyncCheckpointRequestType,
        sync_checkpoint: SyncCheckpoint,
    },
    ViewAccessKeyListBySyncCheckpoint {
        account_id: AccountId,
        request_type: ViewAccessKeyListBySyncCheckpointRequestType,
        sync_checkpoint: SyncCheckpoint,
    },
    CallFunctionBySyncCheckpoint {
        account_id: AccountId,
        args_base64: FunctionArgs,
        method_name: ::std::string::String,
        request_type: CallFunctionBySyncCheckpointRequestType,
        sync_checkpoint: SyncCheckpoint,
    },
    ViewGlobalContractCodeBySyncCheckpoint {
        code_hash: CryptoHash,
        request_type: ViewGlobalContractCodeBySyncCheckpointRequestType,
        sync_checkpoint: SyncCheckpoint,
    },
    ViewGlobalContractCodeByAccountIdBySyncCheckpoint {
        account_id: AccountId,
        request_type: ViewGlobalContractCodeByAccountIdBySyncCheckpointRequestType,
        sync_checkpoint: SyncCheckpoint,
    },
}
impl ::std::convert::From<&Self> for RpcQueryRequest {
    fn from(value: &RpcQueryRequest) -> Self {
        value.clone()
    }
}
#[doc = "`RpcQueryResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountView\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/components/schemas/ContractCodeView\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/components/schemas/ViewStateResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/components/schemas/CallResult\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccessKeyView\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccessKeyList\""]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"block_hash\","]
#[doc = "    \"block_height\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"block_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"block_height\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RpcQueryResponse {
    Variant0 {
        amount: ::std::string::String,
        block_hash: CryptoHash,
        block_height: u64,
        code_hash: CryptoHash,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        global_contract_account_id: ::std::option::Option<AccountId>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        global_contract_hash: ::std::option::Option<CryptoHash>,
        locked: ::std::string::String,
        #[doc = "TODO(2271): deprecated."]
        #[serde(default)]
        storage_paid_at: u64,
        storage_usage: u64,
    },
    Variant1 {
        block_hash: CryptoHash,
        block_height: u64,
        code_base64: ::std::string::String,
        hash: CryptoHash,
    },
    Variant2 {
        block_hash: CryptoHash,
        block_height: u64,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        proof: ::std::vec::Vec<::std::string::String>,
        values: ::std::vec::Vec<StateItem>,
    },
    Variant3 {
        block_hash: CryptoHash,
        block_height: u64,
        logs: ::std::vec::Vec<::std::string::String>,
        result: ::std::vec::Vec<u8>,
    },
    Variant4 {
        block_hash: CryptoHash,
        block_height: u64,
        nonce: u64,
        permission: AccessKeyPermissionView,
    },
    Variant5 {
        block_hash: CryptoHash,
        block_height: u64,
        keys: ::std::vec::Vec<AccessKeyInfoView>,
    },
}
impl ::std::convert::From<&Self> for RpcQueryResponse {
    fn from(value: &RpcQueryResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcReceiptRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcReceiptRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"receipt_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"receipt_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcReceiptRequest {
    pub receipt_id: CryptoHash,
}
impl ::std::convert::From<&RpcReceiptRequest> for RpcReceiptRequest {
    fn from(value: &RpcReceiptRequest) -> Self {
        value.clone()
    }
}
#[doc = "`RpcReceiptResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"predecessor_id\","]
#[doc = "    \"receipt\","]
#[doc = "    \"receipt_id\","]
#[doc = "    \"receiver_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"predecessor_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"priority\": {"]
#[doc = "      \"default\": 0,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"receipt\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/ReceiptEnumView\""]
#[doc = "    },"]
#[doc = "    \"receipt_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"receiver_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcReceiptResponse {
    pub predecessor_id: AccountId,
    #[serde(default)]
    pub priority: u64,
    pub receipt: ReceiptEnumView,
    pub receipt_id: CryptoHash,
    pub receiver_id: AccountId,
}
impl ::std::convert::From<&RpcReceiptResponse> for RpcReceiptResponse {
    fn from(value: &RpcReceiptResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcRequestValidationErrorKind`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"info\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"info\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"method_name\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"method_name\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"METHOD_NOT_FOUND\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"info\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"info\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"error_message\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"error_message\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"PARSE_ERROR\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "name", content = "info")]
pub enum RpcRequestValidationErrorKind {
    #[serde(rename = "METHOD_NOT_FOUND")]
    MethodNotFound { method_name: ::std::string::String },
    #[serde(rename = "PARSE_ERROR")]
    ParseError {
        error_message: ::std::string::String,
    },
}
impl ::std::convert::From<&Self> for RpcRequestValidationErrorKind {
    fn from(value: &RpcRequestValidationErrorKind) -> Self {
        value.clone()
    }
}
#[doc = "`RpcSendTransactionRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcSendTransactionRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"signed_tx_base64\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"signed_tx_base64\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/SignedTransaction\""]
#[doc = "    },"]
#[doc = "    \"wait_until\": {"]
#[doc = "      \"default\": \"EXECUTED_OPTIMISTIC\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/TxExecutionStatus\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcSendTransactionRequest {
    pub signed_tx_base64: SignedTransaction,
    #[serde(default = "defaults::rpc_send_transaction_request_wait_until")]
    pub wait_until: TxExecutionStatus,
}
impl ::std::convert::From<&RpcSendTransactionRequest> for RpcSendTransactionRequest {
    fn from(value: &RpcSendTransactionRequest) -> Self {
        value.clone()
    }
}
#[doc = "`RpcSplitStorageInfoRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcSplitStorageInfoRequest\","]
#[doc = "  \"type\": \"object\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct RpcSplitStorageInfoRequest(
    pub ::serde_json::Map<::std::string::String, ::serde_json::Value>,
);
impl ::std::ops::Deref for RpcSplitStorageInfoRequest {
    type Target = ::serde_json::Map<::std::string::String, ::serde_json::Value>;
    fn deref(&self) -> &::serde_json::Map<::std::string::String, ::serde_json::Value> {
        &self.0
    }
}
impl ::std::convert::From<RpcSplitStorageInfoRequest>
    for ::serde_json::Map<::std::string::String, ::serde_json::Value>
{
    fn from(value: RpcSplitStorageInfoRequest) -> Self {
        value.0
    }
}
impl ::std::convert::From<&RpcSplitStorageInfoRequest> for RpcSplitStorageInfoRequest {
    fn from(value: &RpcSplitStorageInfoRequest) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>>
    for RpcSplitStorageInfoRequest
{
    fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
        Self(value)
    }
}
#[doc = "Contains the split storage information."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Contains the split storage information.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"cold_head_height\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"final_head_height\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"head_height\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"hot_db_kind\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcSplitStorageInfoResponse {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub cold_head_height: ::std::option::Option<u64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub final_head_height: ::std::option::Option<u64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub head_height: ::std::option::Option<u64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub hot_db_kind: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&RpcSplitStorageInfoResponse> for RpcSplitStorageInfoResponse {
    fn from(value: &RpcSplitStorageInfoResponse) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RpcSplitStorageInfoResponse {
    fn default() -> Self {
        Self {
            cold_head_height: Default::default(),
            final_head_height: Default::default(),
            head_height: Default::default(),
            hot_db_kind: Default::default(),
        }
    }
}
#[doc = "It is a [serializable view] of [`StateChangesRequest`].\n\n[serializable view]: ./index.html\n[`StateChangesRequest`]: ../types/struct.StateChangesRequest.html"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcStateChangesInBlockByTypeRequest\","]
#[doc = "  \"description\": \"It is a [serializable view] of [`StateChangesRequest`].\\n\\n[serializable view]: ./index.html\\n[`StateChangesRequest`]: ../types/struct.StateChangesRequest.html\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"account_changes_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"account_changes\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"single_access_key_changes_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"changes_type\","]
#[doc = "            \"keys\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"single_access_key_changes\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"keys\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountWithPublicKey\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"single_gas_key_changes_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"changes_type\","]
#[doc = "            \"keys\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"single_gas_key_changes\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"keys\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountWithPublicKey\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"all_access_key_changes_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"all_access_key_changes\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"all_gas_key_changes_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"all_gas_key_changes\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"contract_code_changes_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"contract_code_changes\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"data_changes_by_block_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"block_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"block_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\","]
#[doc = "            \"key_prefix_base64\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"data_changes\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"key_prefix_base64\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/StoreKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"account_changes_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"account_changes\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"single_access_key_changes_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"changes_type\","]
#[doc = "            \"keys\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"single_access_key_changes\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"keys\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountWithPublicKey\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"single_gas_key_changes_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"changes_type\","]
#[doc = "            \"keys\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"single_gas_key_changes\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"keys\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountWithPublicKey\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"all_access_key_changes_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"all_access_key_changes\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"all_gas_key_changes_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"all_gas_key_changes\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"contract_code_changes_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"contract_code_changes\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"data_changes_by_finality\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"finality\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"finality\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\","]
#[doc = "            \"key_prefix_base64\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"data_changes\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"key_prefix_base64\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/StoreKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"account_changes_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"account_changes\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"single_access_key_changes_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"changes_type\","]
#[doc = "            \"keys\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"single_access_key_changes\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"keys\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountWithPublicKey\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"single_gas_key_changes_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"changes_type\","]
#[doc = "            \"keys\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"single_gas_key_changes\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"keys\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountWithPublicKey\""]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"all_access_key_changes_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"all_access_key_changes\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"all_gas_key_changes_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"all_gas_key_changes\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"contract_code_changes_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"contract_code_changes\""]
#[doc = "              ]"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"data_changes_by_sync_checkpoint\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"sync_checkpoint\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"sync_checkpoint\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_ids\","]
#[doc = "            \"changes_type\","]
#[doc = "            \"key_prefix_base64\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_ids\": {"]
#[doc = "              \"type\": \"array\","]
#[doc = "              \"items\": {"]
#[doc = "                \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            \"changes_type\": {"]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"data_changes\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"key_prefix_base64\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/StoreKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RpcStateChangesInBlockByTypeRequest {
    AccountChangesByBlockId {
        account_ids: ::std::vec::Vec<AccountId>,
        block_id: BlockId,
        changes_type: AccountChangesByBlockIdChangesType,
    },
    SingleAccessKeyChangesByBlockId {
        block_id: BlockId,
        changes_type: SingleAccessKeyChangesByBlockIdChangesType,
        keys: ::std::vec::Vec<AccountWithPublicKey>,
    },
    SingleGasKeyChangesByBlockId {
        block_id: BlockId,
        changes_type: SingleGasKeyChangesByBlockIdChangesType,
        keys: ::std::vec::Vec<AccountWithPublicKey>,
    },
    AllAccessKeyChangesByBlockId {
        account_ids: ::std::vec::Vec<AccountId>,
        block_id: BlockId,
        changes_type: AllAccessKeyChangesByBlockIdChangesType,
    },
    AllGasKeyChangesByBlockId {
        account_ids: ::std::vec::Vec<AccountId>,
        block_id: BlockId,
        changes_type: AllGasKeyChangesByBlockIdChangesType,
    },
    ContractCodeChangesByBlockId {
        account_ids: ::std::vec::Vec<AccountId>,
        block_id: BlockId,
        changes_type: ContractCodeChangesByBlockIdChangesType,
    },
    DataChangesByBlockId {
        account_ids: ::std::vec::Vec<AccountId>,
        block_id: BlockId,
        changes_type: DataChangesByBlockIdChangesType,
        key_prefix_base64: StoreKey,
    },
    AccountChangesByFinality {
        account_ids: ::std::vec::Vec<AccountId>,
        changes_type: AccountChangesByFinalityChangesType,
        finality: Finality,
    },
    SingleAccessKeyChangesByFinality {
        changes_type: SingleAccessKeyChangesByFinalityChangesType,
        finality: Finality,
        keys: ::std::vec::Vec<AccountWithPublicKey>,
    },
    SingleGasKeyChangesByFinality {
        changes_type: SingleGasKeyChangesByFinalityChangesType,
        finality: Finality,
        keys: ::std::vec::Vec<AccountWithPublicKey>,
    },
    AllAccessKeyChangesByFinality {
        account_ids: ::std::vec::Vec<AccountId>,
        changes_type: AllAccessKeyChangesByFinalityChangesType,
        finality: Finality,
    },
    AllGasKeyChangesByFinality {
        account_ids: ::std::vec::Vec<AccountId>,
        changes_type: AllGasKeyChangesByFinalityChangesType,
        finality: Finality,
    },
    ContractCodeChangesByFinality {
        account_ids: ::std::vec::Vec<AccountId>,
        changes_type: ContractCodeChangesByFinalityChangesType,
        finality: Finality,
    },
    DataChangesByFinality {
        account_ids: ::std::vec::Vec<AccountId>,
        changes_type: DataChangesByFinalityChangesType,
        finality: Finality,
        key_prefix_base64: StoreKey,
    },
    AccountChangesBySyncCheckpoint {
        account_ids: ::std::vec::Vec<AccountId>,
        changes_type: AccountChangesBySyncCheckpointChangesType,
        sync_checkpoint: SyncCheckpoint,
    },
    SingleAccessKeyChangesBySyncCheckpoint {
        changes_type: SingleAccessKeyChangesBySyncCheckpointChangesType,
        keys: ::std::vec::Vec<AccountWithPublicKey>,
        sync_checkpoint: SyncCheckpoint,
    },
    SingleGasKeyChangesBySyncCheckpoint {
        changes_type: SingleGasKeyChangesBySyncCheckpointChangesType,
        keys: ::std::vec::Vec<AccountWithPublicKey>,
        sync_checkpoint: SyncCheckpoint,
    },
    AllAccessKeyChangesBySyncCheckpoint {
        account_ids: ::std::vec::Vec<AccountId>,
        changes_type: AllAccessKeyChangesBySyncCheckpointChangesType,
        sync_checkpoint: SyncCheckpoint,
    },
    AllGasKeyChangesBySyncCheckpoint {
        account_ids: ::std::vec::Vec<AccountId>,
        changes_type: AllGasKeyChangesBySyncCheckpointChangesType,
        sync_checkpoint: SyncCheckpoint,
    },
    ContractCodeChangesBySyncCheckpoint {
        account_ids: ::std::vec::Vec<AccountId>,
        changes_type: ContractCodeChangesBySyncCheckpointChangesType,
        sync_checkpoint: SyncCheckpoint,
    },
    DataChangesBySyncCheckpoint {
        account_ids: ::std::vec::Vec<AccountId>,
        changes_type: DataChangesBySyncCheckpointChangesType,
        key_prefix_base64: StoreKey,
        sync_checkpoint: SyncCheckpoint,
    },
}
impl ::std::convert::From<&Self> for RpcStateChangesInBlockByTypeRequest {
    fn from(value: &RpcStateChangesInBlockByTypeRequest) -> Self {
        value.clone()
    }
}
#[doc = "`RpcStateChangesInBlockByTypeResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"block_hash\","]
#[doc = "    \"changes\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"block_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/StateChangeKindView\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcStateChangesInBlockByTypeResponse {
    pub block_hash: CryptoHash,
    pub changes: ::std::vec::Vec<StateChangeKindView>,
}
impl ::std::convert::From<&RpcStateChangesInBlockByTypeResponse>
    for RpcStateChangesInBlockByTypeResponse
{
    fn from(value: &RpcStateChangesInBlockByTypeResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcStateChangesInBlockRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcStateChangesInBlockRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"block_id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"block_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"finality\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"finality\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/Finality\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"sync_checkpoint\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"sync_checkpoint\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/SyncCheckpoint\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum RpcStateChangesInBlockRequest {
    #[serde(rename = "block_id")]
    BlockId(BlockId),
    #[serde(rename = "finality")]
    Finality(Finality),
    #[serde(rename = "sync_checkpoint")]
    SyncCheckpoint(SyncCheckpoint),
}
impl ::std::convert::From<&Self> for RpcStateChangesInBlockRequest {
    fn from(value: &RpcStateChangesInBlockRequest) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BlockId> for RpcStateChangesInBlockRequest {
    fn from(value: BlockId) -> Self {
        Self::BlockId(value)
    }
}
impl ::std::convert::From<Finality> for RpcStateChangesInBlockRequest {
    fn from(value: Finality) -> Self {
        Self::Finality(value)
    }
}
impl ::std::convert::From<SyncCheckpoint> for RpcStateChangesInBlockRequest {
    fn from(value: SyncCheckpoint) -> Self {
        Self::SyncCheckpoint(value)
    }
}
#[doc = "`RpcStateChangesInBlockResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"block_hash\","]
#[doc = "    \"changes\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"block_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"changes\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/StateChangeWithCauseView\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcStateChangesInBlockResponse {
    pub block_hash: CryptoHash,
    pub changes: ::std::vec::Vec<StateChangeWithCauseView>,
}
impl ::std::convert::From<&RpcStateChangesInBlockResponse> for RpcStateChangesInBlockResponse {
    fn from(value: &RpcStateChangesInBlockResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcStatusRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcStatusRequest\","]
#[doc = "  \"type\": \"null\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct RpcStatusRequest(pub ());
impl ::std::ops::Deref for RpcStatusRequest {
    type Target = ();
    fn deref(&self) -> &() {
        &self.0
    }
}
impl ::std::convert::From<RpcStatusRequest> for () {
    fn from(value: RpcStatusRequest) -> Self {
        value.0
    }
}
impl ::std::convert::From<&RpcStatusRequest> for RpcStatusRequest {
    fn from(value: &RpcStatusRequest) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<()> for RpcStatusRequest {
    fn from(value: ()) -> Self {
        Self(value)
    }
}
#[doc = "`RpcStatusResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"chain_id\","]
#[doc = "    \"genesis_hash\","]
#[doc = "    \"latest_protocol_version\","]
#[doc = "    \"node_public_key\","]
#[doc = "    \"protocol_version\","]
#[doc = "    \"sync_info\","]
#[doc = "    \"uptime_sec\","]
#[doc = "    \"validators\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"chain_id\": {"]
#[doc = "      \"description\": \"Unique chain id.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"detailed_debug_status\": {"]
#[doc = "      \"description\": \"Information about last blocks, network, epoch and chain & chunk info.\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/DetailedDebugStatus\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"genesis_hash\": {"]
#[doc = "      \"description\": \"Genesis hash of the chain.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"latest_protocol_version\": {"]
#[doc = "      \"description\": \"Latest protocol version that this client supports.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"node_key\": {"]
#[doc = "      \"description\": \"Deprecated; same as `validator_public_key` which you should use instead.\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"node_public_key\": {"]
#[doc = "      \"description\": \"Public key of the node.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"protocol_version\": {"]
#[doc = "      \"description\": \"Currently active protocol version.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"rpc_addr\": {"]
#[doc = "      \"description\": \"Address for RPC server.  None if node doesn't have RPC endpoint enabled.\","]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sync_info\": {"]
#[doc = "      \"description\": \"Sync status of the node.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/StatusSyncInfo\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"uptime_sec\": {"]
#[doc = "      \"description\": \"Uptime of the node.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"int64\""]
#[doc = "    },"]
#[doc = "    \"validator_account_id\": {"]
#[doc = "      \"description\": \"Validator id of the node\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"validator_public_key\": {"]
#[doc = "      \"description\": \"Public key of the validator.\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"validators\": {"]
#[doc = "      \"description\": \"Current epoch validators.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ValidatorInfo\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"description\": \"Binary version.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Version\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcStatusResponse {
    #[doc = "Unique chain id."]
    pub chain_id: ::std::string::String,
    #[doc = "Information about last blocks, network, epoch and chain & chunk info."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub detailed_debug_status: ::std::option::Option<DetailedDebugStatus>,
    #[doc = "Genesis hash of the chain."]
    pub genesis_hash: CryptoHash,
    #[doc = "Latest protocol version that this client supports."]
    pub latest_protocol_version: u32,
    #[doc = "Deprecated; same as `validator_public_key` which you should use instead."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub node_key: ::std::option::Option<PublicKey>,
    #[doc = "Public key of the node."]
    pub node_public_key: PublicKey,
    #[doc = "Currently active protocol version."]
    pub protocol_version: u32,
    #[doc = "Address for RPC server.  None if node doesn't have RPC endpoint enabled."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub rpc_addr: ::std::option::Option<::std::string::String>,
    #[doc = "Sync status of the node."]
    pub sync_info: StatusSyncInfo,
    #[doc = "Uptime of the node."]
    pub uptime_sec: i64,
    #[doc = "Validator id of the node"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub validator_account_id: ::std::option::Option<AccountId>,
    #[doc = "Public key of the validator."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub validator_public_key: ::std::option::Option<PublicKey>,
    #[doc = "Current epoch validators."]
    pub validators: ::std::vec::Vec<ValidatorInfo>,
    #[doc = "Binary version."]
    pub version: Version,
}
impl ::std::convert::From<&RpcStatusResponse> for RpcStatusResponse {
    fn from(value: &RpcStatusResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcTransactionResponse`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/components/schemas/FinalExecutionOutcomeWithReceiptView\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/components/schemas/FinalExecutionOutcomeView\""]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"final_execution_status\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"final_execution_status\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/TxExecutionStatus\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RpcTransactionResponse {
    Variant0 {
        final_execution_status: TxExecutionStatus,
        #[doc = "Receipts generated from the transaction"]
        receipts: ::std::vec::Vec<ReceiptView>,
        #[doc = "The execution outcome of receipts."]
        receipts_outcome: ::std::vec::Vec<ExecutionOutcomeWithIdView>,
        #[doc = "Execution status defined by chain.rs:get_final_transaction_result\nFinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\nFinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution\nFinalExecutionStatus::Failure - the result of the first leaf receipt_id\nFinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id"]
        status: FinalExecutionStatus,
        #[doc = "Signed Transaction"]
        transaction: SignedTransactionView,
        #[doc = "The execution outcome of the signed transaction."]
        transaction_outcome: ExecutionOutcomeWithIdView,
    },
    Variant1 {
        final_execution_status: TxExecutionStatus,
        #[doc = "The execution outcome of receipts."]
        receipts_outcome: ::std::vec::Vec<ExecutionOutcomeWithIdView>,
        #[doc = "Execution status defined by chain.rs:get_final_transaction_result\nFinalExecutionStatus::NotStarted - the tx is not converted to the receipt yet\nFinalExecutionStatus::Started - we have at least 1 receipt, but the first leaf receipt_id (using dfs) hasn't finished the execution\nFinalExecutionStatus::Failure - the result of the first leaf receipt_id\nFinalExecutionStatus::SuccessValue - the result of the first leaf receipt_id"]
        status: FinalExecutionStatus,
        #[doc = "Signed Transaction"]
        transaction: SignedTransactionView,
        #[doc = "The execution outcome of the signed transaction."]
        transaction_outcome: ExecutionOutcomeWithIdView,
    },
}
impl ::std::convert::From<&Self> for RpcTransactionResponse {
    fn from(value: &RpcTransactionResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcTransactionStatusRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcTransactionStatusRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"signed_tx_base64\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"signed_tx_base64\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/SignedTransaction\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"sender_account_id\","]
#[doc = "        \"tx_hash\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"sender_account_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        },"]
#[doc = "        \"tx_hash\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"wait_until\": {"]
#[doc = "      \"default\": \"EXECUTED_OPTIMISTIC\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/TxExecutionStatus\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RpcTransactionStatusRequest {
    Variant0 {
        signed_tx_base64: SignedTransaction,
        #[serde(default = "defaults::rpc_transaction_status_request_variant0_wait_until")]
        wait_until: TxExecutionStatus,
    },
    Variant1 {
        sender_account_id: AccountId,
        tx_hash: CryptoHash,
        #[serde(default = "defaults::rpc_transaction_status_request_variant1_wait_until")]
        wait_until: TxExecutionStatus,
    },
}
impl ::std::convert::From<&Self> for RpcTransactionStatusRequest {
    fn from(value: &RpcTransactionStatusRequest) -> Self {
        value.clone()
    }
}
#[doc = "`RpcValidatorRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcValidatorRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"latest\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"epoch_id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"epoch_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/EpochId\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"block_id\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"block_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum RpcValidatorRequest {
    #[serde(rename = "latest")]
    Latest,
    #[serde(rename = "epoch_id")]
    EpochId(EpochId),
    #[serde(rename = "block_id")]
    BlockId(BlockId),
}
impl ::std::convert::From<&Self> for RpcValidatorRequest {
    fn from(value: &RpcValidatorRequest) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<EpochId> for RpcValidatorRequest {
    fn from(value: EpochId) -> Self {
        Self::EpochId(value)
    }
}
impl ::std::convert::From<BlockId> for RpcValidatorRequest {
    fn from(value: BlockId) -> Self {
        Self::BlockId(value)
    }
}
#[doc = "Information about this epoch validators and next epoch validators"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Information about this epoch validators and next epoch validators\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"current_fishermen\","]
#[doc = "    \"current_proposals\","]
#[doc = "    \"current_validators\","]
#[doc = "    \"epoch_height\","]
#[doc = "    \"epoch_start_height\","]
#[doc = "    \"next_fishermen\","]
#[doc = "    \"next_validators\","]
#[doc = "    \"prev_epoch_kickout\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"current_fishermen\": {"]
#[doc = "      \"description\": \"Fishermen for the current epoch\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ValidatorStakeView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"current_proposals\": {"]
#[doc = "      \"description\": \"Proposals in the current epoch\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ValidatorStakeView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"current_validators\": {"]
#[doc = "      \"description\": \"Validators for the current epoch\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/CurrentEpochValidatorInfo\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"epoch_height\": {"]
#[doc = "      \"description\": \"Epoch height\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"epoch_start_height\": {"]
#[doc = "      \"description\": \"Epoch start block height\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"next_fishermen\": {"]
#[doc = "      \"description\": \"Fishermen for the next epoch\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ValidatorStakeView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"next_validators\": {"]
#[doc = "      \"description\": \"Validators for the next epoch\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/NextEpochValidatorInfo\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"prev_epoch_kickout\": {"]
#[doc = "      \"description\": \"Kickout in the previous epoch\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ValidatorKickoutView\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcValidatorResponse {
    #[doc = "Fishermen for the current epoch"]
    pub current_fishermen: ::std::vec::Vec<ValidatorStakeView>,
    #[doc = "Proposals in the current epoch"]
    pub current_proposals: ::std::vec::Vec<ValidatorStakeView>,
    #[doc = "Validators for the current epoch"]
    pub current_validators: ::std::vec::Vec<CurrentEpochValidatorInfo>,
    #[doc = "Epoch height"]
    pub epoch_height: u64,
    #[doc = "Epoch start block height"]
    pub epoch_start_height: u64,
    #[doc = "Fishermen for the next epoch"]
    pub next_fishermen: ::std::vec::Vec<ValidatorStakeView>,
    #[doc = "Validators for the next epoch"]
    pub next_validators: ::std::vec::Vec<NextEpochValidatorInfo>,
    #[doc = "Kickout in the previous epoch"]
    pub prev_epoch_kickout: ::std::vec::Vec<ValidatorKickoutView>,
}
impl ::std::convert::From<&RpcValidatorResponse> for RpcValidatorResponse {
    fn from(value: &RpcValidatorResponse) -> Self {
        value.clone()
    }
}
#[doc = "`RpcValidatorsOrderedRequest`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RpcValidatorsOrderedRequest\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"block_id\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/BlockId\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RpcValidatorsOrderedRequest {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub block_id: ::std::option::Option<BlockId>,
}
impl ::std::convert::From<&RpcValidatorsOrderedRequest> for RpcValidatorsOrderedRequest {
    fn from(value: &RpcValidatorsOrderedRequest) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RpcValidatorsOrderedRequest {
    fn default() -> Self {
        Self {
            block_id: Default::default(),
        }
    }
}
#[doc = "View that preserves JSON format of the runtime config."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"View that preserves JSON format of the runtime config.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_creation_config\","]
#[doc = "    \"congestion_control_config\","]
#[doc = "    \"storage_amount_per_byte\","]
#[doc = "    \"transaction_costs\","]
#[doc = "    \"wasm_config\","]
#[doc = "    \"witness_config\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_creation_config\": {"]
#[doc = "      \"description\": \"Config that defines rules for account creation.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountCreationConfigView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"congestion_control_config\": {"]
#[doc = "      \"description\": \"The configuration for congestion control.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CongestionControlConfigView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"storage_amount_per_byte\": {"]
#[doc = "      \"description\": \"Amount of yN per byte required to have on the account.  See\\n<https://nomicon.io/Economics/Economic#state-stake> for details.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"transaction_costs\": {"]
#[doc = "      \"description\": \"Costs of different actions that need to be performed when sending and\\nprocessing transaction and receipts.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/RuntimeFeesConfigView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"wasm_config\": {"]
#[doc = "      \"description\": \"Config of wasm operations.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/VMConfigView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"witness_config\": {"]
#[doc = "      \"description\": \"Configuration specific to ChunkStateWitness.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/WitnessConfigView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RuntimeConfigView {
    #[doc = "Config that defines rules for account creation."]
    pub account_creation_config: AccountCreationConfigView,
    #[doc = "The configuration for congestion control."]
    pub congestion_control_config: CongestionControlConfigView,
    #[doc = "Amount of yN per byte required to have on the account.  See\n<https://nomicon.io/Economics/Economic#state-stake> for details."]
    pub storage_amount_per_byte: ::std::string::String,
    #[doc = "Costs of different actions that need to be performed when sending and\nprocessing transaction and receipts."]
    pub transaction_costs: RuntimeFeesConfigView,
    #[doc = "Config of wasm operations."]
    pub wasm_config: VmConfigView,
    #[doc = "Configuration specific to ChunkStateWitness."]
    pub witness_config: WitnessConfigView,
}
impl ::std::convert::From<&RuntimeConfigView> for RuntimeConfigView {
    fn from(value: &RuntimeConfigView) -> Self {
        value.clone()
    }
}
#[doc = "Describes different costs for the runtime"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes different costs for the runtime\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"action_creation_config\","]
#[doc = "    \"action_receipt_creation_config\","]
#[doc = "    \"burnt_gas_reward\","]
#[doc = "    \"data_receipt_creation_config\","]
#[doc = "    \"pessimistic_gas_price_inflation_ratio\","]
#[doc = "    \"storage_usage_config\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"action_creation_config\": {"]
#[doc = "      \"description\": \"Describes the cost of creating a certain action, `Action`. Includes all variants.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/ActionCreationConfigView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"action_receipt_creation_config\": {"]
#[doc = "      \"description\": \"Describes the cost of creating an action receipt, `ActionReceipt`, excluding the actual cost\\nof actions.\\n- `send` cost is burned when a receipt is created using `promise_create` or\\n    `promise_batch_create`\\n- `exec` cost is burned when the receipt is being executed.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/Fee\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"burnt_gas_reward\": {"]
#[doc = "      \"description\": \"Fraction of the burnt gas to reward to the contract account for execution.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"data_receipt_creation_config\": {"]
#[doc = "      \"description\": \"Describes the cost of creating a data receipt, `DataReceipt`.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/DataReceiptCreationConfigView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"pessimistic_gas_price_inflation_ratio\": {"]
#[doc = "      \"description\": \"Pessimistic gas price inflation ratio.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"int32\""]
#[doc = "      },"]
#[doc = "      \"maxItems\": 2,"]
#[doc = "      \"minItems\": 2"]
#[doc = "    },"]
#[doc = "    \"storage_usage_config\": {"]
#[doc = "      \"description\": \"Describes fees for storage.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/StorageUsageConfigView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RuntimeFeesConfigView {
    #[doc = "Describes the cost of creating a certain action, `Action`. Includes all variants."]
    pub action_creation_config: ActionCreationConfigView,
    #[doc = "Describes the cost of creating an action receipt, `ActionReceipt`, excluding the actual cost\nof actions.\n- `send` cost is burned when a receipt is created using `promise_create` or\n    `promise_batch_create`\n- `exec` cost is burned when the receipt is being executed."]
    pub action_receipt_creation_config: Fee,
    #[doc = "Fraction of the burnt gas to reward to the contract account for execution."]
    pub burnt_gas_reward: [i32; 2usize],
    #[doc = "Describes the cost of creating a data receipt, `DataReceipt`."]
    pub data_receipt_creation_config: DataReceiptCreationConfigView,
    #[doc = "Pessimistic gas price inflation ratio."]
    pub pessimistic_gas_price_inflation_ratio: [i32; 2usize],
    #[doc = "Describes fees for storage."]
    pub storage_usage_config: StorageUsageConfigView,
}
impl ::std::convert::From<&RuntimeFeesConfigView> for RuntimeFeesConfigView {
    fn from(value: &RuntimeFeesConfigView) -> Self {
        value.clone()
    }
}
#[doc = "The shard identifier. It may be an arbitrary number - it does not need to be\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\nsequential or contiguous.\n\nThe shard id is wrapped in a new type to prevent the old pattern of using\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\nif fully complete it potentially may be simplified to a regular type alias."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The shard identifier. It may be an arbitrary number - it does not need to be\\na number in the range 0..NUM_SHARDS. The shard ids do not need to be\\nsequential or contiguous.\\n\\nThe shard id is wrapped in a new type to prevent the old pattern of using\\nindices in range 0..NUM_SHARDS and casting to ShardId. Once the transition\\nif fully complete it potentially may be simplified to a regular type alias.\","]
#[doc = "  \"type\": \"integer\","]
#[doc = "  \"format\": \"uint64\","]
#[doc = "  \"minimum\": 0.0"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct ShardId(pub u64);
impl ::std::ops::Deref for ShardId {
    type Target = u64;
    fn deref(&self) -> &u64 {
        &self.0
    }
}
impl ::std::convert::From<ShardId> for u64 {
    fn from(value: ShardId) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ShardId> for ShardId {
    fn from(value: &ShardId) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<u64> for ShardId {
    fn from(value: u64) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for ShardId {
    type Err = <u64 as ::std::str::FromStr>::Err;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.parse()?))
    }
}
impl ::std::convert::TryFrom<&str> for ShardId {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&String> for ShardId {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<String> for ShardId {
    type Error = <u64 as ::std::str::FromStr>::Err;
    fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
        value.parse()
    }
}
impl ::std::fmt::Display for ShardId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "A versioned struct that contains all information needed to assign accounts to shards.\n\nBecause of re-sharding, the chain may use different shard layout to split shards at different\ntimes. Currently, `ShardLayout` is stored as part of `EpochConfig`, which is generated each\nepoch given the epoch protocol version. In mainnet/testnet, we use two shard layouts since\nre-sharding has only happened once. It is stored as part of genesis config, see\ndefault_simple_nightshade_shard_layout() Below is an overview for some important\nfunctionalities of ShardLayout interface."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A versioned struct that contains all information needed to assign accounts to shards.\\n\\nBecause of re-sharding, the chain may use different shard layout to split shards at different\\ntimes. Currently, `ShardLayout` is stored as part of `EpochConfig`, which is generated each\\nepoch given the epoch protocol version. In mainnet/testnet, we use two shard layouts since\\nre-sharding has only happened once. It is stored as part of genesis config, see\\ndefault_simple_nightshade_shard_layout() Below is an overview for some important\\nfunctionalities of ShardLayout interface.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"V0\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"V0\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/ShardLayoutV0\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"V1\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"V1\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/ShardLayoutV1\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"V2\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"V2\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/ShardLayoutV2\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum ShardLayout {
    V0(ShardLayoutV0),
    V1(ShardLayoutV1),
    V2(ShardLayoutV2),
}
impl ::std::convert::From<&Self> for ShardLayout {
    fn from(value: &ShardLayout) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ShardLayoutV0> for ShardLayout {
    fn from(value: ShardLayoutV0) -> Self {
        Self::V0(value)
    }
}
impl ::std::convert::From<ShardLayoutV1> for ShardLayout {
    fn from(value: ShardLayoutV1) -> Self {
        Self::V1(value)
    }
}
impl ::std::convert::From<ShardLayoutV2> for ShardLayout {
    fn from(value: ShardLayoutV2) -> Self {
        Self::V2(value)
    }
}
#[doc = "A shard layout that maps accounts evenly across all shards -- by calculate the hash of account\nid and mod number of shards. This is added to capture the old `account_id_to_shard_id` algorithm,\nto keep backward compatibility for some existing tests.\n`parent_shards` for `ShardLayoutV1` is always `None`, meaning it can only be the first shard layout\na chain uses."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A shard layout that maps accounts evenly across all shards -- by calculate the hash of account\\nid and mod number of shards. This is added to capture the old `account_id_to_shard_id` algorithm,\\nto keep backward compatibility for some existing tests.\\n`parent_shards` for `ShardLayoutV1` is always `None`, meaning it can only be the first shard layout\\na chain uses.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"num_shards\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"num_shards\": {"]
#[doc = "      \"description\": \"Map accounts evenly across all shards\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"description\": \"Version of the shard layout, this is useful for uniquely identify the shard layout\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ShardLayoutV0 {
    #[doc = "Map accounts evenly across all shards"]
    pub num_shards: u64,
    #[doc = "Version of the shard layout, this is useful for uniquely identify the shard layout"]
    pub version: u32,
}
impl ::std::convert::From<&ShardLayoutV0> for ShardLayoutV0 {
    fn from(value: &ShardLayoutV0) -> Self {
        value.clone()
    }
}
#[doc = "`ShardLayoutV1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"boundary_accounts\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"boundary_accounts\": {"]
#[doc = "      \"description\": \"The boundary accounts are the accounts on boundaries between shards.\\nEach shard contains a range of accounts from one boundary account to\\nanother - or the smallest or largest account possible. The total\\nnumber of shards is equal to the number of boundary accounts plus 1.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"shards_split_map\": {"]
#[doc = "      \"description\": \"Maps shards from the last shard layout to shards that it splits to in this shard layout,\\nUseful for constructing states for the shards.\\nNone for the genesis shard layout\","]
#[doc = "      \"type\": ["]
#[doc = "        \"array\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"array\","]
#[doc = "        \"items\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"to_parent_shard_map\": {"]
#[doc = "      \"description\": \"Maps shard in this shard layout to their parent shard\\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap\","]
#[doc = "      \"type\": ["]
#[doc = "        \"array\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"description\": \"Version of the shard layout, this is useful for uniquely identify the shard layout\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ShardLayoutV1 {
    #[doc = "The boundary accounts are the accounts on boundaries between shards.\nEach shard contains a range of accounts from one boundary account to\nanother - or the smallest or largest account possible. The total\nnumber of shards is equal to the number of boundary accounts plus 1."]
    pub boundary_accounts: ::std::vec::Vec<AccountId>,
    #[doc = "Maps shards from the last shard layout to shards that it splits to in this shard layout,\nUseful for constructing states for the shards.\nNone for the genesis shard layout"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub shards_split_map: ::std::option::Option<::std::vec::Vec<::std::vec::Vec<ShardId>>>,
    #[doc = "Maps shard in this shard layout to their parent shard\nSince shard_ids always range from 0 to num_shards - 1, we use vec instead of a hashmap"]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub to_parent_shard_map: ::std::option::Option<::std::vec::Vec<ShardId>>,
    #[doc = "Version of the shard layout, this is useful for uniquely identify the shard layout"]
    pub version: u32,
}
impl ::std::convert::From<&ShardLayoutV1> for ShardLayoutV1 {
    fn from(value: &ShardLayoutV1) -> Self {
        value.clone()
    }
}
#[doc = "Counterpart to `ShardLayoutV2` composed of maps with string keys to aid\nserde serialization."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Counterpart to `ShardLayoutV2` composed of maps with string keys to aid\\nserde serialization.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"boundary_accounts\","]
#[doc = "    \"id_to_index_map\","]
#[doc = "    \"index_to_id_map\","]
#[doc = "    \"shard_ids\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"boundary_accounts\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"id_to_index_map\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"type\": \"integer\","]
#[doc = "        \"format\": \"uint\","]
#[doc = "        \"minimum\": 0.0"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"index_to_id_map\": {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"shard_ids\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"shards_parent_map\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"object\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"shards_split_map\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"object\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"type\": \"array\","]
#[doc = "        \"items\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ShardLayoutV2 {
    pub boundary_accounts: ::std::vec::Vec<AccountId>,
    pub id_to_index_map: ::std::collections::HashMap<::std::string::String, u32>,
    pub index_to_id_map: ::std::collections::HashMap<::std::string::String, ShardId>,
    pub shard_ids: ::std::vec::Vec<ShardId>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub shards_parent_map:
        ::std::option::Option<::std::collections::HashMap<::std::string::String, ShardId>>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub shards_split_map: ::std::option::Option<
        ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<ShardId>>,
    >,
    pub version: u32,
}
impl ::std::convert::From<&ShardLayoutV2> for ShardLayoutV2 {
    fn from(value: &ShardLayoutV2) -> Self {
        value.clone()
    }
}
#[doc = "`ShardUId` is a unique representation for shards from different shard layouts.\n\nComparing to `ShardId`, which is just an ordinal number ranging from 0 to NUM_SHARDS-1,\n`ShardUId` provides a way to unique identify shards when shard layouts may change across epochs.\nThis is important because we store states indexed by shards in our database, so we need a\nway to unique identify shard even when shards change across epochs.\nAnother difference between `ShardUId` and `ShardId` is that `ShardUId` should only exist in\na node's internal state while `ShardId` can be exposed to outside APIs and used in protocol\nlevel information (for example, `ShardChunkHeader` contains `ShardId` instead of `ShardUId`)"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"`ShardUId` is a unique representation for shards from different shard layouts.\\n\\nComparing to `ShardId`, which is just an ordinal number ranging from 0 to NUM_SHARDS-1,\\n`ShardUId` provides a way to unique identify shards when shard layouts may change across epochs.\\nThis is important because we store states indexed by shards in our database, so we need a\\nway to unique identify shard even when shards change across epochs.\\nAnother difference between `ShardUId` and `ShardId` is that `ShardUId` should only exist in\\na node's internal state while `ShardId` can be exposed to outside APIs and used in protocol\\nlevel information (for example, `ShardChunkHeader` contains `ShardId` instead of `ShardUId`)\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"shard_id\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"shard_id\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ShardUId {
    pub shard_id: u32,
    pub version: u32,
}
impl ::std::convert::From<&ShardUId> for ShardUId {
    fn from(value: &ShardUId) -> Self {
        value.clone()
    }
}
#[doc = "`Signature`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct Signature(pub ::std::string::String);
impl ::std::ops::Deref for Signature {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<Signature> for ::std::string::String {
    fn from(value: Signature) -> Self {
        value.0
    }
}
impl ::std::convert::From<&Signature> for Signature {
    fn from(value: &Signature) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for Signature {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for Signature {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for Signature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`SignedDelegateAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"delegate_action\","]
#[doc = "    \"signature\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"delegate_action\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/DelegateAction\""]
#[doc = "    },"]
#[doc = "    \"signature\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/Signature\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SignedDelegateAction {
    pub delegate_action: DelegateAction,
    pub signature: Signature,
}
impl ::std::convert::From<&SignedDelegateAction> for SignedDelegateAction {
    fn from(value: &SignedDelegateAction) -> Self {
        value.clone()
    }
}
#[doc = "`SignedTransaction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"format\": \"byte\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct SignedTransaction(pub ::std::string::String);
impl ::std::ops::Deref for SignedTransaction {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<SignedTransaction> for ::std::string::String {
    fn from(value: SignedTransaction) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SignedTransaction> for SignedTransaction {
    fn from(value: &SignedTransaction) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for SignedTransaction {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for SignedTransaction {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for SignedTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`SignedTransactionView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"actions\","]
#[doc = "    \"hash\","]
#[doc = "    \"nonce\","]
#[doc = "    \"public_key\","]
#[doc = "    \"receiver_id\","]
#[doc = "    \"signature\","]
#[doc = "    \"signer_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"actions\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/ActionView\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"nonce\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"priority_fee\": {"]
#[doc = "      \"default\": 0,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    },"]
#[doc = "    \"receiver_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"signature\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/Signature\""]
#[doc = "    },"]
#[doc = "    \"signer_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SignedTransactionView {
    pub actions: ::std::vec::Vec<ActionView>,
    pub hash: CryptoHash,
    pub nonce: u64,
    #[serde(default)]
    pub priority_fee: u64,
    pub public_key: PublicKey,
    pub receiver_id: AccountId,
    pub signature: Signature,
    pub signer_id: AccountId,
}
impl ::std::convert::From<&SignedTransactionView> for SignedTransactionView {
    fn from(value: &SignedTransactionView) -> Self {
        value.clone()
    }
}
#[doc = "`SingleAccessKeyChangesByBlockIdChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"single_access_key_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SingleAccessKeyChangesByBlockIdChangesType {
    #[serde(rename = "single_access_key_changes")]
    SingleAccessKeyChanges,
}
impl ::std::convert::From<&Self> for SingleAccessKeyChangesByBlockIdChangesType {
    fn from(value: &SingleAccessKeyChangesByBlockIdChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SingleAccessKeyChangesByBlockIdChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SingleAccessKeyChanges => write!(f, "single_access_key_changes"),
        }
    }
}
impl ::std::str::FromStr for SingleAccessKeyChangesByBlockIdChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "single_access_key_changes" => Ok(Self::SingleAccessKeyChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SingleAccessKeyChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for SingleAccessKeyChangesByBlockIdChangesType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SingleAccessKeyChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SingleAccessKeyChangesByFinalityChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"single_access_key_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SingleAccessKeyChangesByFinalityChangesType {
    #[serde(rename = "single_access_key_changes")]
    SingleAccessKeyChanges,
}
impl ::std::convert::From<&Self> for SingleAccessKeyChangesByFinalityChangesType {
    fn from(value: &SingleAccessKeyChangesByFinalityChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SingleAccessKeyChangesByFinalityChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SingleAccessKeyChanges => write!(f, "single_access_key_changes"),
        }
    }
}
impl ::std::str::FromStr for SingleAccessKeyChangesByFinalityChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "single_access_key_changes" => Ok(Self::SingleAccessKeyChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SingleAccessKeyChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for SingleAccessKeyChangesByFinalityChangesType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for SingleAccessKeyChangesByFinalityChangesType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SingleAccessKeyChangesBySyncCheckpointChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"single_access_key_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SingleAccessKeyChangesBySyncCheckpointChangesType {
    #[serde(rename = "single_access_key_changes")]
    SingleAccessKeyChanges,
}
impl ::std::convert::From<&Self> for SingleAccessKeyChangesBySyncCheckpointChangesType {
    fn from(value: &SingleAccessKeyChangesBySyncCheckpointChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SingleAccessKeyChangesBySyncCheckpointChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SingleAccessKeyChanges => write!(f, "single_access_key_changes"),
        }
    }
}
impl ::std::str::FromStr for SingleAccessKeyChangesBySyncCheckpointChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "single_access_key_changes" => Ok(Self::SingleAccessKeyChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SingleAccessKeyChangesBySyncCheckpointChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for SingleAccessKeyChangesBySyncCheckpointChangesType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for SingleAccessKeyChangesBySyncCheckpointChangesType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SingleGasKeyChangesByBlockIdChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"single_gas_key_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SingleGasKeyChangesByBlockIdChangesType {
    #[serde(rename = "single_gas_key_changes")]
    SingleGasKeyChanges,
}
impl ::std::convert::From<&Self> for SingleGasKeyChangesByBlockIdChangesType {
    fn from(value: &SingleGasKeyChangesByBlockIdChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SingleGasKeyChangesByBlockIdChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SingleGasKeyChanges => write!(f, "single_gas_key_changes"),
        }
    }
}
impl ::std::str::FromStr for SingleGasKeyChangesByBlockIdChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "single_gas_key_changes" => Ok(Self::SingleGasKeyChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SingleGasKeyChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SingleGasKeyChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SingleGasKeyChangesByBlockIdChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SingleGasKeyChangesByFinalityChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"single_gas_key_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SingleGasKeyChangesByFinalityChangesType {
    #[serde(rename = "single_gas_key_changes")]
    SingleGasKeyChanges,
}
impl ::std::convert::From<&Self> for SingleGasKeyChangesByFinalityChangesType {
    fn from(value: &SingleGasKeyChangesByFinalityChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SingleGasKeyChangesByFinalityChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SingleGasKeyChanges => write!(f, "single_gas_key_changes"),
        }
    }
}
impl ::std::str::FromStr for SingleGasKeyChangesByFinalityChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "single_gas_key_changes" => Ok(Self::SingleGasKeyChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SingleGasKeyChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SingleGasKeyChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SingleGasKeyChangesByFinalityChangesType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SingleGasKeyChangesBySyncCheckpointChangesType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"single_gas_key_changes\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SingleGasKeyChangesBySyncCheckpointChangesType {
    #[serde(rename = "single_gas_key_changes")]
    SingleGasKeyChanges,
}
impl ::std::convert::From<&Self> for SingleGasKeyChangesBySyncCheckpointChangesType {
    fn from(value: &SingleGasKeyChangesBySyncCheckpointChangesType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SingleGasKeyChangesBySyncCheckpointChangesType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::SingleGasKeyChanges => write!(f, "single_gas_key_changes"),
        }
    }
}
impl ::std::str::FromStr for SingleGasKeyChangesBySyncCheckpointChangesType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "single_gas_key_changes" => Ok(Self::SingleGasKeyChanges),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SingleGasKeyChangesBySyncCheckpointChangesType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for SingleGasKeyChangesBySyncCheckpointChangesType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for SingleGasKeyChangesBySyncCheckpointChangesType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`SlashedValidator`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"is_double_sign\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"is_double_sign\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SlashedValidator {
    pub account_id: AccountId,
    pub is_double_sign: bool,
}
impl ::std::convert::From<&SlashedValidator> for SlashedValidator {
    fn from(value: &SlashedValidator) -> Self {
        value.clone()
    }
}
#[doc = "An action which stakes signer_id tokens and setup's validator public key"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"An action which stakes signer_id tokens and setup's validator public key\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"public_key\","]
#[doc = "    \"stake\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"description\": \"Validator key which will be used to sign transactions on behalf of signer_id\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"stake\": {"]
#[doc = "      \"description\": \"Amount of tokens to stake.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StakeAction {
    #[doc = "Validator key which will be used to sign transactions on behalf of signer_id"]
    pub public_key: PublicKey,
    #[doc = "Amount of tokens to stake."]
    pub stake: ::std::string::String,
}
impl ::std::convert::From<&StakeAction> for StakeAction {
    fn from(value: &StakeAction) -> Self {
        value.clone()
    }
}
#[doc = "See crate::types::StateChangeCause for details."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"See crate::types::StateChangeCause for details.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"not_writable_to_disk\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"initial_state\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"tx_hash\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"tx_hash\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"transaction_processing\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"receipt_hash\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"receipt_hash\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"action_receipt_processing_started\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"receipt_hash\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"receipt_hash\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"action_receipt_gas_reward\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"receipt_hash\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"receipt_hash\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"receipt_processing\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"receipt_hash\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"receipt_hash\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"postponed_receipt\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"updated_delayed_receipts\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"validator_accounts_update\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"migration\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"bandwidth_scheduler_state_update\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "type")]
pub enum StateChangeCauseView {
    #[serde(rename = "not_writable_to_disk")]
    NotWritableToDisk,
    #[serde(rename = "initial_state")]
    InitialState,
    #[serde(rename = "transaction_processing")]
    TransactionProcessing { tx_hash: CryptoHash },
    #[serde(rename = "action_receipt_processing_started")]
    ActionReceiptProcessingStarted { receipt_hash: CryptoHash },
    #[serde(rename = "action_receipt_gas_reward")]
    ActionReceiptGasReward { receipt_hash: CryptoHash },
    #[serde(rename = "receipt_processing")]
    ReceiptProcessing { receipt_hash: CryptoHash },
    #[serde(rename = "postponed_receipt")]
    PostponedReceipt { receipt_hash: CryptoHash },
    #[serde(rename = "updated_delayed_receipts")]
    UpdatedDelayedReceipts,
    #[serde(rename = "validator_accounts_update")]
    ValidatorAccountsUpdate,
    #[serde(rename = "migration")]
    Migration,
    #[serde(rename = "bandwidth_scheduler_state_update")]
    BandwidthSchedulerStateUpdate,
}
impl ::std::convert::From<&Self> for StateChangeCauseView {
    fn from(value: &StateChangeCauseView) -> Self {
        value.clone()
    }
}
#[doc = "It is a [serializable view] of [`StateChangeKind`].\n\n[serializable view]: ./index.html\n[`StateChangeKind`]: ../types/struct.StateChangeKind.html"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"It is a [serializable view] of [`StateChangeKind`].\\n\\n[serializable view]: ./index.html\\n[`StateChangeKind`]: ../types/struct.StateChangeKind.html\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"account_id\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"account_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"account_touched\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"account_id\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"account_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"access_key_touched\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"account_id\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"account_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"data_touched\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"account_id\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"account_id\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"contract_code_touched\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(tag = "type", content = "account_id")]
pub enum StateChangeKindView {
    #[serde(rename = "account_touched")]
    AccountTouched(AccountId),
    #[serde(rename = "access_key_touched")]
    AccessKeyTouched(AccountId),
    #[serde(rename = "data_touched")]
    DataTouched(AccountId),
    #[serde(rename = "contract_code_touched")]
    ContractCodeTouched(AccountId),
}
impl ::std::convert::From<&Self> for StateChangeKindView {
    fn from(value: &StateChangeKindView) -> Self {
        value.clone()
    }
}
#[doc = "`StateChangeWithCauseView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"description\": \"A view of the account\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"amount\","]
#[doc = "            \"code_hash\","]
#[doc = "            \"locked\","]
#[doc = "            \"storage_usage\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"amount\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"code_hash\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "            },"]
#[doc = "            \"global_contract_account_id\": {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"null\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"global_contract_hash\": {"]
#[doc = "              \"anyOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"null\""]
#[doc = "                }"]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"locked\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"storage_paid_at\": {"]
#[doc = "              \"description\": \"TODO(2271): deprecated.\","]
#[doc = "              \"default\": 0,"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"storage_usage\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"account_update\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"account_deletion\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"access_key\","]
#[doc = "            \"account_id\","]
#[doc = "            \"public_key\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"access_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccessKeyView\""]
#[doc = "            },"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"access_key_update\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"public_key\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"access_key_deletion\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"gas_key\","]
#[doc = "            \"public_key\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"gas_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/GasKeyView\""]
#[doc = "            },"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"gas_key_update\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"index\","]
#[doc = "            \"nonce\","]
#[doc = "            \"public_key\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"index\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint32\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"nonce\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"gas_key_nonce_update\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"public_key\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"public_key\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"gas_key_deletion\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"key_base64\","]
#[doc = "            \"value_base64\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"key_base64\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/StoreKey\""]
#[doc = "            },"]
#[doc = "            \"value_base64\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/StoreValue\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"data_update\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"key_base64\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"key_base64\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/StoreKey\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"data_deletion\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\","]
#[doc = "            \"code_base64\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            },"]
#[doc = "            \"code_base64\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"contract_code_update\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"change\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"change\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"account_id\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"account_id\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"type\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"contract_code_deletion\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"cause\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"cause\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/StateChangeCauseView\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum StateChangeWithCauseView {
    Variant0 {
        cause: StateChangeCauseView,
        change: StateChangeWithCauseViewVariant0Change,
        #[serde(rename = "type")]
        type_: StateChangeWithCauseViewVariant0Type,
    },
    Variant1 {
        cause: StateChangeCauseView,
        change: StateChangeWithCauseViewVariant1Change,
        #[serde(rename = "type")]
        type_: StateChangeWithCauseViewVariant1Type,
    },
    Variant2 {
        cause: StateChangeCauseView,
        change: StateChangeWithCauseViewVariant2Change,
        #[serde(rename = "type")]
        type_: StateChangeWithCauseViewVariant2Type,
    },
    Variant3 {
        cause: StateChangeCauseView,
        change: StateChangeWithCauseViewVariant3Change,
        #[serde(rename = "type")]
        type_: StateChangeWithCauseViewVariant3Type,
    },
    Variant4 {
        cause: StateChangeCauseView,
        change: StateChangeWithCauseViewVariant4Change,
        #[serde(rename = "type")]
        type_: StateChangeWithCauseViewVariant4Type,
    },
    Variant5 {
        cause: StateChangeCauseView,
        change: StateChangeWithCauseViewVariant5Change,
        #[serde(rename = "type")]
        type_: StateChangeWithCauseViewVariant5Type,
    },
    Variant6 {
        cause: StateChangeCauseView,
        change: StateChangeWithCauseViewVariant6Change,
        #[serde(rename = "type")]
        type_: StateChangeWithCauseViewVariant6Type,
    },
    Variant7 {
        cause: StateChangeCauseView,
        change: StateChangeWithCauseViewVariant7Change,
        #[serde(rename = "type")]
        type_: StateChangeWithCauseViewVariant7Type,
    },
    Variant8 {
        cause: StateChangeCauseView,
        change: StateChangeWithCauseViewVariant8Change,
        #[serde(rename = "type")]
        type_: StateChangeWithCauseViewVariant8Type,
    },
    Variant9 {
        cause: StateChangeCauseView,
        change: StateChangeWithCauseViewVariant9Change,
        #[serde(rename = "type")]
        type_: StateChangeWithCauseViewVariant9Type,
    },
    Variant10 {
        cause: StateChangeCauseView,
        change: StateChangeWithCauseViewVariant10Change,
        #[serde(rename = "type")]
        type_: StateChangeWithCauseViewVariant10Type,
    },
}
impl ::std::convert::From<&Self> for StateChangeWithCauseView {
    fn from(value: &StateChangeWithCauseView) -> Self {
        value.clone()
    }
}
#[doc = "A view of the account"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A view of the account\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"amount\","]
#[doc = "    \"code_hash\","]
#[doc = "    \"locked\","]
#[doc = "    \"storage_usage\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_key\": false,"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"amount\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"code_base64\": false,"]
#[doc = "    \"code_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"gas_key\": false,"]
#[doc = "    \"global_contract_account_id\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"global_contract_hash\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"index\": false,"]
#[doc = "    \"key_base64\": false,"]
#[doc = "    \"locked\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"nonce\": false,"]
#[doc = "    \"public_key\": false,"]
#[doc = "    \"storage_paid_at\": {"]
#[doc = "      \"description\": \"TODO(2271): deprecated.\","]
#[doc = "      \"default\": 0,"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"storage_usage\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"value_base64\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StateChangeWithCauseViewVariant0Change {
    pub account_id: AccountId,
    pub amount: ::std::string::String,
    pub code_hash: CryptoHash,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub global_contract_account_id: ::std::option::Option<AccountId>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub global_contract_hash: ::std::option::Option<CryptoHash>,
    pub locked: ::std::string::String,
    #[doc = "TODO(2271): deprecated."]
    #[serde(default)]
    pub storage_paid_at: u64,
    pub storage_usage: u64,
}
impl ::std::convert::From<&StateChangeWithCauseViewVariant0Change>
    for StateChangeWithCauseViewVariant0Change
{
    fn from(value: &StateChangeWithCauseViewVariant0Change) -> Self {
        value.clone()
    }
}
#[doc = "`StateChangeWithCauseViewVariant0Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"account_update\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StateChangeWithCauseViewVariant0Type {
    #[serde(rename = "account_update")]
    AccountUpdate,
}
impl ::std::convert::From<&Self> for StateChangeWithCauseViewVariant0Type {
    fn from(value: &StateChangeWithCauseViewVariant0Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StateChangeWithCauseViewVariant0Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AccountUpdate => write!(f, "account_update"),
        }
    }
}
impl ::std::str::FromStr for StateChangeWithCauseViewVariant0Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "account_update" => Ok(Self::AccountUpdate),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StateChangeWithCauseViewVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StateChangeWithCauseViewVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StateChangeWithCauseViewVariant0Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StateChangeWithCauseViewVariant10Change`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_key\": false,"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"amount\": false,"]
#[doc = "    \"code_base64\": false,"]
#[doc = "    \"code_hash\": false,"]
#[doc = "    \"gas_key\": false,"]
#[doc = "    \"global_contract_account_id\": false,"]
#[doc = "    \"global_contract_hash\": false,"]
#[doc = "    \"index\": false,"]
#[doc = "    \"key_base64\": false,"]
#[doc = "    \"locked\": false,"]
#[doc = "    \"nonce\": false,"]
#[doc = "    \"public_key\": false,"]
#[doc = "    \"storage_paid_at\": false,"]
#[doc = "    \"storage_usage\": false,"]
#[doc = "    \"value_base64\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StateChangeWithCauseViewVariant10Change {
    pub account_id: AccountId,
}
impl ::std::convert::From<&StateChangeWithCauseViewVariant10Change>
    for StateChangeWithCauseViewVariant10Change
{
    fn from(value: &StateChangeWithCauseViewVariant10Change) -> Self {
        value.clone()
    }
}
#[doc = "`StateChangeWithCauseViewVariant10Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"contract_code_deletion\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StateChangeWithCauseViewVariant10Type {
    #[serde(rename = "contract_code_deletion")]
    ContractCodeDeletion,
}
impl ::std::convert::From<&Self> for StateChangeWithCauseViewVariant10Type {
    fn from(value: &StateChangeWithCauseViewVariant10Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StateChangeWithCauseViewVariant10Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ContractCodeDeletion => write!(f, "contract_code_deletion"),
        }
    }
}
impl ::std::str::FromStr for StateChangeWithCauseViewVariant10Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "contract_code_deletion" => Ok(Self::ContractCodeDeletion),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StateChangeWithCauseViewVariant10Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StateChangeWithCauseViewVariant10Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StateChangeWithCauseViewVariant10Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StateChangeWithCauseViewVariant1Change`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_key\": false,"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"amount\": false,"]
#[doc = "    \"code_base64\": false,"]
#[doc = "    \"code_hash\": false,"]
#[doc = "    \"gas_key\": false,"]
#[doc = "    \"global_contract_account_id\": false,"]
#[doc = "    \"global_contract_hash\": false,"]
#[doc = "    \"index\": false,"]
#[doc = "    \"key_base64\": false,"]
#[doc = "    \"locked\": false,"]
#[doc = "    \"nonce\": false,"]
#[doc = "    \"public_key\": false,"]
#[doc = "    \"storage_paid_at\": false,"]
#[doc = "    \"storage_usage\": false,"]
#[doc = "    \"value_base64\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StateChangeWithCauseViewVariant1Change {
    pub account_id: AccountId,
}
impl ::std::convert::From<&StateChangeWithCauseViewVariant1Change>
    for StateChangeWithCauseViewVariant1Change
{
    fn from(value: &StateChangeWithCauseViewVariant1Change) -> Self {
        value.clone()
    }
}
#[doc = "`StateChangeWithCauseViewVariant1Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"account_deletion\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StateChangeWithCauseViewVariant1Type {
    #[serde(rename = "account_deletion")]
    AccountDeletion,
}
impl ::std::convert::From<&Self> for StateChangeWithCauseViewVariant1Type {
    fn from(value: &StateChangeWithCauseViewVariant1Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StateChangeWithCauseViewVariant1Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AccountDeletion => write!(f, "account_deletion"),
        }
    }
}
impl ::std::str::FromStr for StateChangeWithCauseViewVariant1Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "account_deletion" => Ok(Self::AccountDeletion),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StateChangeWithCauseViewVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StateChangeWithCauseViewVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StateChangeWithCauseViewVariant1Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StateChangeWithCauseViewVariant2Change`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"access_key\","]
#[doc = "    \"account_id\","]
#[doc = "    \"public_key\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccessKeyView\""]
#[doc = "    },"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"amount\": false,"]
#[doc = "    \"code_base64\": false,"]
#[doc = "    \"code_hash\": false,"]
#[doc = "    \"gas_key\": false,"]
#[doc = "    \"global_contract_account_id\": false,"]
#[doc = "    \"global_contract_hash\": false,"]
#[doc = "    \"index\": false,"]
#[doc = "    \"key_base64\": false,"]
#[doc = "    \"locked\": false,"]
#[doc = "    \"nonce\": false,"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    },"]
#[doc = "    \"storage_paid_at\": false,"]
#[doc = "    \"storage_usage\": false,"]
#[doc = "    \"value_base64\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StateChangeWithCauseViewVariant2Change {
    pub access_key: AccessKeyView,
    pub account_id: AccountId,
    pub public_key: PublicKey,
}
impl ::std::convert::From<&StateChangeWithCauseViewVariant2Change>
    for StateChangeWithCauseViewVariant2Change
{
    fn from(value: &StateChangeWithCauseViewVariant2Change) -> Self {
        value.clone()
    }
}
#[doc = "`StateChangeWithCauseViewVariant2Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"access_key_update\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StateChangeWithCauseViewVariant2Type {
    #[serde(rename = "access_key_update")]
    AccessKeyUpdate,
}
impl ::std::convert::From<&Self> for StateChangeWithCauseViewVariant2Type {
    fn from(value: &StateChangeWithCauseViewVariant2Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StateChangeWithCauseViewVariant2Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AccessKeyUpdate => write!(f, "access_key_update"),
        }
    }
}
impl ::std::str::FromStr for StateChangeWithCauseViewVariant2Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "access_key_update" => Ok(Self::AccessKeyUpdate),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StateChangeWithCauseViewVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StateChangeWithCauseViewVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StateChangeWithCauseViewVariant2Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StateChangeWithCauseViewVariant3Change`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"public_key\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_key\": false,"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"amount\": false,"]
#[doc = "    \"code_base64\": false,"]
#[doc = "    \"code_hash\": false,"]
#[doc = "    \"gas_key\": false,"]
#[doc = "    \"global_contract_account_id\": false,"]
#[doc = "    \"global_contract_hash\": false,"]
#[doc = "    \"index\": false,"]
#[doc = "    \"key_base64\": false,"]
#[doc = "    \"locked\": false,"]
#[doc = "    \"nonce\": false,"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    },"]
#[doc = "    \"storage_paid_at\": false,"]
#[doc = "    \"storage_usage\": false,"]
#[doc = "    \"value_base64\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StateChangeWithCauseViewVariant3Change {
    pub account_id: AccountId,
    pub public_key: PublicKey,
}
impl ::std::convert::From<&StateChangeWithCauseViewVariant3Change>
    for StateChangeWithCauseViewVariant3Change
{
    fn from(value: &StateChangeWithCauseViewVariant3Change) -> Self {
        value.clone()
    }
}
#[doc = "`StateChangeWithCauseViewVariant3Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"access_key_deletion\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StateChangeWithCauseViewVariant3Type {
    #[serde(rename = "access_key_deletion")]
    AccessKeyDeletion,
}
impl ::std::convert::From<&Self> for StateChangeWithCauseViewVariant3Type {
    fn from(value: &StateChangeWithCauseViewVariant3Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StateChangeWithCauseViewVariant3Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AccessKeyDeletion => write!(f, "access_key_deletion"),
        }
    }
}
impl ::std::str::FromStr for StateChangeWithCauseViewVariant3Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "access_key_deletion" => Ok(Self::AccessKeyDeletion),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StateChangeWithCauseViewVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StateChangeWithCauseViewVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StateChangeWithCauseViewVariant3Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StateChangeWithCauseViewVariant4Change`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"gas_key\","]
#[doc = "    \"public_key\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_key\": false,"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"amount\": false,"]
#[doc = "    \"code_base64\": false,"]
#[doc = "    \"code_hash\": false,"]
#[doc = "    \"gas_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/GasKeyView\""]
#[doc = "    },"]
#[doc = "    \"global_contract_account_id\": false,"]
#[doc = "    \"global_contract_hash\": false,"]
#[doc = "    \"index\": false,"]
#[doc = "    \"key_base64\": false,"]
#[doc = "    \"locked\": false,"]
#[doc = "    \"nonce\": false,"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    },"]
#[doc = "    \"storage_paid_at\": false,"]
#[doc = "    \"storage_usage\": false,"]
#[doc = "    \"value_base64\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StateChangeWithCauseViewVariant4Change {
    pub account_id: AccountId,
    pub gas_key: GasKeyView,
    pub public_key: PublicKey,
}
impl ::std::convert::From<&StateChangeWithCauseViewVariant4Change>
    for StateChangeWithCauseViewVariant4Change
{
    fn from(value: &StateChangeWithCauseViewVariant4Change) -> Self {
        value.clone()
    }
}
#[doc = "`StateChangeWithCauseViewVariant4Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"gas_key_update\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StateChangeWithCauseViewVariant4Type {
    #[serde(rename = "gas_key_update")]
    GasKeyUpdate,
}
impl ::std::convert::From<&Self> for StateChangeWithCauseViewVariant4Type {
    fn from(value: &StateChangeWithCauseViewVariant4Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StateChangeWithCauseViewVariant4Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::GasKeyUpdate => write!(f, "gas_key_update"),
        }
    }
}
impl ::std::str::FromStr for StateChangeWithCauseViewVariant4Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "gas_key_update" => Ok(Self::GasKeyUpdate),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StateChangeWithCauseViewVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StateChangeWithCauseViewVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StateChangeWithCauseViewVariant4Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StateChangeWithCauseViewVariant5Change`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"index\","]
#[doc = "    \"nonce\","]
#[doc = "    \"public_key\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_key\": false,"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"amount\": false,"]
#[doc = "    \"code_base64\": false,"]
#[doc = "    \"code_hash\": false,"]
#[doc = "    \"gas_key\": false,"]
#[doc = "    \"global_contract_account_id\": false,"]
#[doc = "    \"global_contract_hash\": false,"]
#[doc = "    \"index\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"key_base64\": false,"]
#[doc = "    \"locked\": false,"]
#[doc = "    \"nonce\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    },"]
#[doc = "    \"storage_paid_at\": false,"]
#[doc = "    \"storage_usage\": false,"]
#[doc = "    \"value_base64\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StateChangeWithCauseViewVariant5Change {
    pub account_id: AccountId,
    pub index: u32,
    pub nonce: u64,
    pub public_key: PublicKey,
}
impl ::std::convert::From<&StateChangeWithCauseViewVariant5Change>
    for StateChangeWithCauseViewVariant5Change
{
    fn from(value: &StateChangeWithCauseViewVariant5Change) -> Self {
        value.clone()
    }
}
#[doc = "`StateChangeWithCauseViewVariant5Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"gas_key_nonce_update\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StateChangeWithCauseViewVariant5Type {
    #[serde(rename = "gas_key_nonce_update")]
    GasKeyNonceUpdate,
}
impl ::std::convert::From<&Self> for StateChangeWithCauseViewVariant5Type {
    fn from(value: &StateChangeWithCauseViewVariant5Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StateChangeWithCauseViewVariant5Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::GasKeyNonceUpdate => write!(f, "gas_key_nonce_update"),
        }
    }
}
impl ::std::str::FromStr for StateChangeWithCauseViewVariant5Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "gas_key_nonce_update" => Ok(Self::GasKeyNonceUpdate),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StateChangeWithCauseViewVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StateChangeWithCauseViewVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StateChangeWithCauseViewVariant5Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StateChangeWithCauseViewVariant6Change`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"public_key\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_key\": false,"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"amount\": false,"]
#[doc = "    \"code_base64\": false,"]
#[doc = "    \"code_hash\": false,"]
#[doc = "    \"gas_key\": false,"]
#[doc = "    \"global_contract_account_id\": false,"]
#[doc = "    \"global_contract_hash\": false,"]
#[doc = "    \"index\": false,"]
#[doc = "    \"key_base64\": false,"]
#[doc = "    \"locked\": false,"]
#[doc = "    \"nonce\": false,"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    },"]
#[doc = "    \"storage_paid_at\": false,"]
#[doc = "    \"storage_usage\": false,"]
#[doc = "    \"value_base64\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StateChangeWithCauseViewVariant6Change {
    pub account_id: AccountId,
    pub public_key: PublicKey,
}
impl ::std::convert::From<&StateChangeWithCauseViewVariant6Change>
    for StateChangeWithCauseViewVariant6Change
{
    fn from(value: &StateChangeWithCauseViewVariant6Change) -> Self {
        value.clone()
    }
}
#[doc = "`StateChangeWithCauseViewVariant6Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"gas_key_deletion\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StateChangeWithCauseViewVariant6Type {
    #[serde(rename = "gas_key_deletion")]
    GasKeyDeletion,
}
impl ::std::convert::From<&Self> for StateChangeWithCauseViewVariant6Type {
    fn from(value: &StateChangeWithCauseViewVariant6Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StateChangeWithCauseViewVariant6Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::GasKeyDeletion => write!(f, "gas_key_deletion"),
        }
    }
}
impl ::std::str::FromStr for StateChangeWithCauseViewVariant6Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "gas_key_deletion" => Ok(Self::GasKeyDeletion),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StateChangeWithCauseViewVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StateChangeWithCauseViewVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StateChangeWithCauseViewVariant6Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StateChangeWithCauseViewVariant7Change`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"key_base64\","]
#[doc = "    \"value_base64\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_key\": false,"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"amount\": false,"]
#[doc = "    \"code_base64\": false,"]
#[doc = "    \"code_hash\": false,"]
#[doc = "    \"gas_key\": false,"]
#[doc = "    \"global_contract_account_id\": false,"]
#[doc = "    \"global_contract_hash\": false,"]
#[doc = "    \"index\": false,"]
#[doc = "    \"key_base64\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/StoreKey\""]
#[doc = "    },"]
#[doc = "    \"locked\": false,"]
#[doc = "    \"nonce\": false,"]
#[doc = "    \"public_key\": false,"]
#[doc = "    \"storage_paid_at\": false,"]
#[doc = "    \"storage_usage\": false,"]
#[doc = "    \"value_base64\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/StoreValue\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StateChangeWithCauseViewVariant7Change {
    pub account_id: AccountId,
    pub key_base64: StoreKey,
    pub value_base64: StoreValue,
}
impl ::std::convert::From<&StateChangeWithCauseViewVariant7Change>
    for StateChangeWithCauseViewVariant7Change
{
    fn from(value: &StateChangeWithCauseViewVariant7Change) -> Self {
        value.clone()
    }
}
#[doc = "`StateChangeWithCauseViewVariant7Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"data_update\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StateChangeWithCauseViewVariant7Type {
    #[serde(rename = "data_update")]
    DataUpdate,
}
impl ::std::convert::From<&Self> for StateChangeWithCauseViewVariant7Type {
    fn from(value: &StateChangeWithCauseViewVariant7Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StateChangeWithCauseViewVariant7Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::DataUpdate => write!(f, "data_update"),
        }
    }
}
impl ::std::str::FromStr for StateChangeWithCauseViewVariant7Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "data_update" => Ok(Self::DataUpdate),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StateChangeWithCauseViewVariant7Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StateChangeWithCauseViewVariant7Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StateChangeWithCauseViewVariant7Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StateChangeWithCauseViewVariant8Change`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"key_base64\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_key\": false,"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"amount\": false,"]
#[doc = "    \"code_base64\": false,"]
#[doc = "    \"code_hash\": false,"]
#[doc = "    \"gas_key\": false,"]
#[doc = "    \"global_contract_account_id\": false,"]
#[doc = "    \"global_contract_hash\": false,"]
#[doc = "    \"index\": false,"]
#[doc = "    \"key_base64\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/StoreKey\""]
#[doc = "    },"]
#[doc = "    \"locked\": false,"]
#[doc = "    \"nonce\": false,"]
#[doc = "    \"public_key\": false,"]
#[doc = "    \"storage_paid_at\": false,"]
#[doc = "    \"storage_usage\": false,"]
#[doc = "    \"value_base64\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StateChangeWithCauseViewVariant8Change {
    pub account_id: AccountId,
    pub key_base64: StoreKey,
}
impl ::std::convert::From<&StateChangeWithCauseViewVariant8Change>
    for StateChangeWithCauseViewVariant8Change
{
    fn from(value: &StateChangeWithCauseViewVariant8Change) -> Self {
        value.clone()
    }
}
#[doc = "`StateChangeWithCauseViewVariant8Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"data_deletion\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StateChangeWithCauseViewVariant8Type {
    #[serde(rename = "data_deletion")]
    DataDeletion,
}
impl ::std::convert::From<&Self> for StateChangeWithCauseViewVariant8Type {
    fn from(value: &StateChangeWithCauseViewVariant8Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StateChangeWithCauseViewVariant8Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::DataDeletion => write!(f, "data_deletion"),
        }
    }
}
impl ::std::str::FromStr for StateChangeWithCauseViewVariant8Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "data_deletion" => Ok(Self::DataDeletion),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StateChangeWithCauseViewVariant8Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StateChangeWithCauseViewVariant8Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StateChangeWithCauseViewVariant8Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`StateChangeWithCauseViewVariant9Change`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"code_base64\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"access_key\": false,"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"amount\": false,"]
#[doc = "    \"code_base64\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"code_hash\": false,"]
#[doc = "    \"gas_key\": false,"]
#[doc = "    \"global_contract_account_id\": false,"]
#[doc = "    \"global_contract_hash\": false,"]
#[doc = "    \"index\": false,"]
#[doc = "    \"key_base64\": false,"]
#[doc = "    \"locked\": false,"]
#[doc = "    \"nonce\": false,"]
#[doc = "    \"public_key\": false,"]
#[doc = "    \"storage_paid_at\": false,"]
#[doc = "    \"storage_usage\": false,"]
#[doc = "    \"value_base64\": false"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StateChangeWithCauseViewVariant9Change {
    pub account_id: AccountId,
    pub code_base64: ::std::string::String,
}
impl ::std::convert::From<&StateChangeWithCauseViewVariant9Change>
    for StateChangeWithCauseViewVariant9Change
{
    fn from(value: &StateChangeWithCauseViewVariant9Change) -> Self {
        value.clone()
    }
}
#[doc = "`StateChangeWithCauseViewVariant9Type`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"contract_code_update\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StateChangeWithCauseViewVariant9Type {
    #[serde(rename = "contract_code_update")]
    ContractCodeUpdate,
}
impl ::std::convert::From<&Self> for StateChangeWithCauseViewVariant9Type {
    fn from(value: &StateChangeWithCauseViewVariant9Type) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StateChangeWithCauseViewVariant9Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ContractCodeUpdate => write!(f, "contract_code_update"),
        }
    }
}
impl ::std::str::FromStr for StateChangeWithCauseViewVariant9Type {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "contract_code_update" => Ok(Self::ContractCodeUpdate),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StateChangeWithCauseViewVariant9Type {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StateChangeWithCauseViewVariant9Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StateChangeWithCauseViewVariant9Type {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Item of the state, key and value are serialized in base64 and proof for inclusion of given state item."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Item of the state, key and value are serialized in base64 and proof for inclusion of given state item.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"key\","]
#[doc = "    \"value\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/StoreKey\""]
#[doc = "    },"]
#[doc = "    \"value\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/StoreValue\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StateItem {
    pub key: StoreKey,
    pub value: StoreValue,
}
impl ::std::convert::From<&StateItem> for StateItem {
    fn from(value: &StateItem) -> Self {
        value.clone()
    }
}
#[doc = "Options for dumping state to S3."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Options for dumping state to S3.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"dump\": {"]
#[doc = "      \"description\": \"`none` value disables state dump to external storage.\","]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/DumpConfig\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"sync\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/SyncConfig\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StateSyncConfig {
    #[doc = "`none` value disables state dump to external storage."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dump: ::std::option::Option<DumpConfig>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub sync: ::std::option::Option<SyncConfig>,
}
impl ::std::convert::From<&StateSyncConfig> for StateSyncConfig {
    fn from(value: &StateSyncConfig) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for StateSyncConfig {
    fn default() -> Self {
        Self {
            dump: Default::default(),
            sync: Default::default(),
        }
    }
}
#[doc = "`StatusSyncInfo`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"latest_block_hash\","]
#[doc = "    \"latest_block_height\","]
#[doc = "    \"latest_block_time\","]
#[doc = "    \"latest_state_root\","]
#[doc = "    \"syncing\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"earliest_block_hash\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"earliest_block_height\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"earliest_block_time\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"string\","]
#[doc = "        \"null\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"epoch_id\": {"]
#[doc = "      \"anyOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/EpochId\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"null\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"epoch_start_height\": {"]
#[doc = "      \"type\": ["]
#[doc = "        \"integer\","]
#[doc = "        \"null\""]
#[doc = "      ],"]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"latest_block_hash\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"latest_block_height\": {"]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"latest_block_time\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"latest_state_root\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/CryptoHash\""]
#[doc = "    },"]
#[doc = "    \"syncing\": {"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StatusSyncInfo {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub earliest_block_hash: ::std::option::Option<CryptoHash>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub earliest_block_height: ::std::option::Option<u64>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub earliest_block_time: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub epoch_id: ::std::option::Option<EpochId>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub epoch_start_height: ::std::option::Option<u64>,
    pub latest_block_hash: CryptoHash,
    pub latest_block_height: u64,
    pub latest_block_time: ::std::string::String,
    pub latest_state_root: CryptoHash,
    pub syncing: bool,
}
impl ::std::convert::From<&StatusSyncInfo> for StatusSyncInfo {
    fn from(value: &StatusSyncInfo) -> Self {
        value.clone()
    }
}
#[doc = "Errors which may occur during working with trie storages, storing\ntrie values (trie nodes and state values) by their hashes."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Errors which may occur during working with trie storages, storing\\ntrie values (trie nodes and state values) by their hashes.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"Key-value db internal failure\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"StorageInternalError\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Requested trie value by its hash which is missing in storage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"MissingTrieValue\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"MissingTrieValue\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/MissingTrieValue\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Found trie node which shouldn't be part of state. Raised during\\nvalidation of state sync parts where incorrect node was passed.\\nTODO (#8997): consider including hash of trie node.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"UnexpectedTrieValue\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Either invalid state or key-value db is corrupted.\\nFor PartialStorage it cannot be corrupted.\\nError message is unreliable and for debugging purposes only. It's also probably ok to\\npanic in every place that produces this error.\\nWe can check if db is corrupted by verifying everything in the state trie.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"StorageInconsistentState\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"StorageInconsistentState\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Flat storage error, meaning that it doesn't support some block anymore.\\nWe guarantee that such block cannot become final, thus block processing\\nmust resume normally.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"FlatStorageBlockNotSupported\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"FlatStorageBlockNotSupported\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"In-memory trie could not be loaded for some reason.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"MemTrieLoadingError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"MemTrieLoadingError\": {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum StorageError {
    #[doc = "Key-value db internal failure"]
    StorageInternalError,
    #[doc = "Requested trie value by its hash which is missing in storage."]
    MissingTrieValue(MissingTrieValue),
    #[doc = "Found trie node which shouldn't be part of state. Raised during\nvalidation of state sync parts where incorrect node was passed.\nTODO (#8997): consider including hash of trie node."]
    UnexpectedTrieValue,
    #[doc = "Either invalid state or key-value db is corrupted.\nFor PartialStorage it cannot be corrupted.\nError message is unreliable and for debugging purposes only. It's also probably ok to\npanic in every place that produces this error.\nWe can check if db is corrupted by verifying everything in the state trie."]
    StorageInconsistentState(::std::string::String),
    #[doc = "Flat storage error, meaning that it doesn't support some block anymore.\nWe guarantee that such block cannot become final, thus block processing\nmust resume normally."]
    FlatStorageBlockNotSupported(::std::string::String),
    #[doc = "In-memory trie could not be loaded for some reason."]
    MemTrieLoadingError(::std::string::String),
}
impl ::std::convert::From<&Self> for StorageError {
    fn from(value: &StorageError) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<MissingTrieValue> for StorageError {
    fn from(value: MissingTrieValue) -> Self {
        Self::MissingTrieValue(value)
    }
}
#[doc = "This enum represents if a storage_get call will be performed through flat storage or trie"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"This enum represents if a storage_get call will be performed through flat storage or trie\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"FlatStorage\","]
#[doc = "    \"Trie\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum StorageGetMode {
    FlatStorage,
    Trie,
}
impl ::std::convert::From<&Self> for StorageGetMode {
    fn from(value: &StorageGetMode) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for StorageGetMode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::FlatStorage => write!(f, "FlatStorage"),
            Self::Trie => write!(f, "Trie"),
        }
    }
}
impl ::std::str::FromStr for StorageGetMode {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "FlatStorage" => Ok(Self::FlatStorage),
            "Trie" => Ok(Self::Trie),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for StorageGetMode {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for StorageGetMode {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for StorageGetMode {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Describes cost of storage per block"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes cost of storage per block\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"num_bytes_account\","]
#[doc = "    \"num_extra_bytes_record\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"num_bytes_account\": {"]
#[doc = "      \"description\": \"Number of bytes for an account record, including rounding up for account id.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"num_extra_bytes_record\": {"]
#[doc = "      \"description\": \"Additional number of bytes for a k/v record\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct StorageUsageConfigView {
    #[doc = "Number of bytes for an account record, including rounding up for account id."]
    pub num_bytes_account: u64,
    #[doc = "Additional number of bytes for a k/v record"]
    pub num_extra_bytes_record: u64,
}
impl ::std::convert::From<&StorageUsageConfigView> for StorageUsageConfigView {
    fn from(value: &StorageUsageConfigView) -> Self {
        value.clone()
    }
}
#[doc = "This type is used to mark keys (arrays of bytes) that are queried from store.\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"This type is used to mark keys (arrays of bytes) that are queried from store.\\n\\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"format\": \"bytes\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct StoreKey(pub ::std::string::String);
impl ::std::ops::Deref for StoreKey {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<StoreKey> for ::std::string::String {
    fn from(value: StoreKey) -> Self {
        value.0
    }
}
impl ::std::convert::From<&StoreKey> for StoreKey {
    fn from(value: &StoreKey) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for StoreKey {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for StoreKey {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for StoreKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "This type is used to mark values returned from store (arrays of bytes).\n\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`)."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"This type is used to mark values returned from store (arrays of bytes).\\n\\nNOTE: Currently, this type is only used in the view_client and RPC to be able to transparently\\npretty-serialize the bytes arrays as base64-encoded strings (see `serialize.rs`).\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"format\": \"bytes\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
#[serde(transparent)]
pub struct StoreValue(pub ::std::string::String);
impl ::std::ops::Deref for StoreValue {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<StoreValue> for ::std::string::String {
    fn from(value: StoreValue) -> Self {
        value.0
    }
}
impl ::std::convert::From<&StoreValue> for StoreValue {
    fn from(value: &StoreValue) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::string::String> for StoreValue {
    fn from(value: ::std::string::String) -> Self {
        Self(value)
    }
}
impl ::std::str::FromStr for StoreValue {
    type Err = ::std::convert::Infallible;
    fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
        Ok(Self(value.to_string()))
    }
}
impl ::std::fmt::Display for StoreValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        self.0.fmt(f)
    }
}
#[doc = "`SyncCheckpoint`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"genesis\","]
#[doc = "    \"earliest_available\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum SyncCheckpoint {
    #[serde(rename = "genesis")]
    Genesis,
    #[serde(rename = "earliest_available")]
    EarliestAvailable,
}
impl ::std::convert::From<&Self> for SyncCheckpoint {
    fn from(value: &SyncCheckpoint) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for SyncCheckpoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Genesis => write!(f, "genesis"),
            Self::EarliestAvailable => write!(f, "earliest_available"),
        }
    }
}
impl ::std::str::FromStr for SyncCheckpoint {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "genesis" => Ok(Self::Genesis),
            "earliest_available" => Ok(Self::EarliestAvailable),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for SyncCheckpoint {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SyncCheckpoint {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SyncCheckpoint {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Configures how to fetch state parts during state sync."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Configures how to fetch state parts during state sync.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"Syncs state from the peers without reading anything from external storage.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Peers\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Expects parts to be available in external storage.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ExternalStorage\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ExternalStorage\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/ExternalStorageConfig\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum SyncConfig {
    #[doc = "Syncs state from the peers without reading anything from external storage."]
    Peers,
    #[doc = "Expects parts to be available in external storage."]
    ExternalStorage(ExternalStorageConfig),
}
impl ::std::convert::From<&Self> for SyncConfig {
    fn from(value: &SyncConfig) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ExternalStorageConfig> for SyncConfig {
    fn from(value: ExternalStorageConfig) -> Self {
        Self::ExternalStorage(value)
    }
}
#[doc = "`Tier1ProxyView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"addr\","]
#[doc = "    \"peer_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"addr\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"peer_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Tier1ProxyView {
    pub addr: ::std::string::String,
    pub peer_id: PublicKey,
}
impl ::std::convert::From<&Tier1ProxyView> for Tier1ProxyView {
    fn from(value: &Tier1ProxyView) -> Self {
        value.clone()
    }
}
#[doc = "Describes the expected behavior of the node regarding shard tracking.\nIf the node is an active validator, it will also track the shards it is responsible for as a validator."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Describes the expected behavior of the node regarding shard tracking.\\nIf the node is an active validator, it will also track the shards it is responsible for as a validator.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"Tracks no shards (light client).\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"NoShards\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Tracks arbitrary shards.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Shards\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Shards\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/components/schemas/ShardUId\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Tracks all shards.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"AllShards\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Tracks shards that are assigned to given validator account.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ShadowValidator\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ShadowValidator\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Rotate between these sets of tracked shards.\\nUsed to simulate the behavior of chunk only producers without staking tokens.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Schedule\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Schedule\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"type\": \"array\","]
#[doc = "            \"items\": {"]
#[doc = "              \"$ref\": \"#/components/schemas/ShardId\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Tracks shards that contain one of the given account.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"Accounts\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"Accounts\": {"]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum TrackedShardsConfig {
    #[doc = "Tracks no shards (light client)."]
    NoShards,
    #[doc = "Tracks arbitrary shards."]
    Shards(::std::vec::Vec<ShardUId>),
    #[doc = "Tracks all shards."]
    AllShards,
    #[doc = "Tracks shards that are assigned to given validator account."]
    ShadowValidator(AccountId),
    #[doc = "Rotate between these sets of tracked shards.\nUsed to simulate the behavior of chunk only producers without staking tokens."]
    Schedule(::std::vec::Vec<::std::vec::Vec<ShardId>>),
    #[doc = "Tracks shards that contain one of the given account."]
    Accounts(::std::vec::Vec<AccountId>),
}
impl ::std::convert::From<&Self> for TrackedShardsConfig {
    fn from(value: &TrackedShardsConfig) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<ShardUId>> for TrackedShardsConfig {
    fn from(value: ::std::vec::Vec<ShardUId>) -> Self {
        Self::Shards(value)
    }
}
impl ::std::convert::From<AccountId> for TrackedShardsConfig {
    fn from(value: AccountId) -> Self {
        Self::ShadowValidator(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<::std::vec::Vec<ShardId>>> for TrackedShardsConfig {
    fn from(value: ::std::vec::Vec<::std::vec::Vec<ShardId>>) -> Self {
        Self::Schedule(value)
    }
}
impl ::std::convert::From<::std::vec::Vec<AccountId>> for TrackedShardsConfig {
    fn from(value: ::std::vec::Vec<AccountId>) -> Self {
        Self::Accounts(value)
    }
}
#[doc = "`TransferAction`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"deposit\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"deposit\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TransferAction {
    pub deposit: ::std::string::String,
}
impl ::std::convert::From<&TransferAction> for TransferAction {
    fn from(value: &TransferAction) -> Self {
        value.clone()
    }
}
#[doc = "Error returned in the ExecutionOutcome in case of failure"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Error returned in the ExecutionOutcome in case of failure\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"An error happened during Action execution\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ActionError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ActionError\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/ActionError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"An error happened during Transaction execution\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"InvalidTxError\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"InvalidTxError\": {"]
#[doc = "          \"$ref\": \"#/components/schemas/InvalidTxError\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum TxExecutionError {
    #[doc = "An error happened during Action execution"]
    ActionError(ActionError),
    #[doc = "An error happened during Transaction execution"]
    InvalidTxError(InvalidTxError),
}
impl ::std::convert::From<&Self> for TxExecutionError {
    fn from(value: &TxExecutionError) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<ActionError> for TxExecutionError {
    fn from(value: ActionError) -> Self {
        Self::ActionError(value)
    }
}
impl ::std::convert::From<InvalidTxError> for TxExecutionError {
    fn from(value: InvalidTxError) -> Self {
        Self::InvalidTxError(value)
    }
}
#[doc = "`TxExecutionStatus`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction is waiting to be included into the block\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"NONE\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction is included into the block. The block may be not finalized yet\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"INCLUDED\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction is included into the block +\\nAll non-refund transaction receipts finished their execution.\\nThe corresponding blocks for tx and each receipt may be not finalized yet\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXECUTED_OPTIMISTIC\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction is included into finalized block\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"INCLUDED_FINAL\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction is included into finalized block +\\nAll non-refund transaction receipts finished their execution.\\nThe corresponding blocks for each receipt may be not finalized yet\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"EXECUTED\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Transaction is included into finalized block +\\nExecution of all transaction receipts is finalized, including refund receipts\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"FINAL\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum TxExecutionStatus {
    #[doc = "Transaction is waiting to be included into the block"]
    #[serde(rename = "NONE")]
    None,
    #[doc = "Transaction is included into the block. The block may be not finalized yet"]
    #[serde(rename = "INCLUDED")]
    Included,
    #[doc = "Transaction is included into the block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for tx and each receipt may be not finalized yet"]
    #[serde(rename = "EXECUTED_OPTIMISTIC")]
    ExecutedOptimistic,
    #[doc = "Transaction is included into finalized block"]
    #[serde(rename = "INCLUDED_FINAL")]
    IncludedFinal,
    #[doc = "Transaction is included into finalized block +\nAll non-refund transaction receipts finished their execution.\nThe corresponding blocks for each receipt may be not finalized yet"]
    #[serde(rename = "EXECUTED")]
    Executed,
    #[doc = "Transaction is included into finalized block +\nExecution of all transaction receipts is finalized, including refund receipts"]
    #[serde(rename = "FINAL")]
    Final,
}
impl ::std::convert::From<&Self> for TxExecutionStatus {
    fn from(value: &TxExecutionStatus) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for TxExecutionStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::None => write!(f, "NONE"),
            Self::Included => write!(f, "INCLUDED"),
            Self::ExecutedOptimistic => write!(f, "EXECUTED_OPTIMISTIC"),
            Self::IncludedFinal => write!(f, "INCLUDED_FINAL"),
            Self::Executed => write!(f, "EXECUTED"),
            Self::Final => write!(f, "FINAL"),
        }
    }
}
impl ::std::str::FromStr for TxExecutionStatus {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "NONE" => Ok(Self::None),
            "INCLUDED" => Ok(Self::Included),
            "EXECUTED_OPTIMISTIC" => Ok(Self::ExecutedOptimistic),
            "INCLUDED_FINAL" => Ok(Self::IncludedFinal),
            "EXECUTED" => Ok(Self::Executed),
            "FINAL" => Ok(Self::Final),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for TxExecutionStatus {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for TxExecutionStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for TxExecutionStatus {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Use global contract action"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Use global contract action\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"contract_identifier\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"contract_identifier\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/GlobalContractIdentifier\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct UseGlobalContractAction {
    pub contract_identifier: GlobalContractIdentifier,
}
impl ::std::convert::From<&UseGlobalContractAction> for UseGlobalContractAction {
    fn from(value: &UseGlobalContractAction) -> Self {
        value.clone()
    }
}
#[doc = "`ValidatorInfo`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ValidatorInfo {
    pub account_id: AccountId,
}
impl ::std::convert::From<&ValidatorInfo> for ValidatorInfo {
    fn from(value: &ValidatorInfo) -> Self {
        value.clone()
    }
}
#[doc = "Reasons for removing a validator from the validator set."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Reasons for removing a validator from the validator set.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"Deprecated\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"_UnusedSlashed\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Validator didn't produce enough blocks.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"NotEnoughBlocks\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"NotEnoughBlocks\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"expected\","]
#[doc = "            \"produced\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"expected\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"produced\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Validator didn't produce enough chunks.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"NotEnoughChunks\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"NotEnoughChunks\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"expected\","]
#[doc = "            \"produced\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"expected\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"produced\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Validator unstaked themselves.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Unstaked\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Validator stake is now below threshold\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"NotEnoughStake\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"NotEnoughStake\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"stake_u128\","]
#[doc = "            \"threshold_u128\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"stake_u128\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"threshold_u128\": {"]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Enough stake but is not chosen because of seat limits.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"DidNotGetASeat\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Validator didn't produce enough chunk endorsements.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"NotEnoughChunkEndorsements\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"NotEnoughChunkEndorsements\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"expected\","]
#[doc = "            \"produced\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"expected\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"produced\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint64\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Validator's last block proposal was for a protocol version older than\\nthe network's voted protocol version.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"ProtocolVersionTooOld\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"ProtocolVersionTooOld\": {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"network_version\","]
#[doc = "            \"version\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"network_version\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint32\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            },"]
#[doc = "            \"version\": {"]
#[doc = "              \"type\": \"integer\","]
#[doc = "              \"format\": \"uint32\","]
#[doc = "              \"minimum\": 0.0"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum ValidatorKickoutReason {
    #[doc = "Deprecated"]
    #[serde(rename = "_UnusedSlashed")]
    UnusedSlashed,
    #[doc = "Validator didn't produce enough blocks."]
    NotEnoughBlocks { expected: u64, produced: u64 },
    #[doc = "Validator didn't produce enough chunks."]
    NotEnoughChunks { expected: u64, produced: u64 },
    #[doc = "Validator unstaked themselves."]
    Unstaked,
    #[doc = "Validator stake is now below threshold"]
    NotEnoughStake {
        stake_u128: ::std::string::String,
        threshold_u128: ::std::string::String,
    },
    #[doc = "Enough stake but is not chosen because of seat limits."]
    DidNotGetASeat,
    #[doc = "Validator didn't produce enough chunk endorsements."]
    NotEnoughChunkEndorsements { expected: u64, produced: u64 },
    #[doc = "Validator's last block proposal was for a protocol version older than\nthe network's voted protocol version."]
    ProtocolVersionTooOld { network_version: u32, version: u32 },
}
impl ::std::convert::From<&Self> for ValidatorKickoutReason {
    fn from(value: &ValidatorKickoutReason) -> Self {
        value.clone()
    }
}
#[doc = "`ValidatorKickoutView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"reason\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"reason\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/ValidatorKickoutReason\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ValidatorKickoutView {
    pub account_id: AccountId,
    pub reason: ValidatorKickoutReason,
}
impl ::std::convert::From<&ValidatorKickoutView> for ValidatorKickoutView {
    fn from(value: &ValidatorKickoutView) -> Self {
        value.clone()
    }
}
#[doc = "`ValidatorStakeView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"allOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/components/schemas/ValidatorStakeViewV1\""]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"validator_stake_struct_version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"validator_stake_struct_version\": {"]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"V1\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ValidatorStakeView {
    pub account_id: AccountId,
    pub public_key: PublicKey,
    pub stake: ::std::string::String,
    pub validator_stake_struct_version: ValidatorStakeViewValidatorStakeStructVersion,
}
impl ::std::convert::From<&ValidatorStakeView> for ValidatorStakeView {
    fn from(value: &ValidatorStakeView) -> Self {
        value.clone()
    }
}
#[doc = "`ValidatorStakeViewV1`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"account_id\","]
#[doc = "    \"public_key\","]
#[doc = "    \"stake\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"account_id\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/AccountId\""]
#[doc = "    },"]
#[doc = "    \"public_key\": {"]
#[doc = "      \"$ref\": \"#/components/schemas/PublicKey\""]
#[doc = "    },"]
#[doc = "    \"stake\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ValidatorStakeViewV1 {
    pub account_id: AccountId,
    pub public_key: PublicKey,
    pub stake: ::std::string::String,
}
impl ::std::convert::From<&ValidatorStakeViewV1> for ValidatorStakeViewV1 {
    fn from(value: &ValidatorStakeViewV1) -> Self {
        value.clone()
    }
}
#[doc = "`ValidatorStakeViewValidatorStakeStructVersion`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"V1\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ValidatorStakeViewValidatorStakeStructVersion {
    V1,
}
impl ::std::convert::From<&Self> for ValidatorStakeViewValidatorStakeStructVersion {
    fn from(value: &ValidatorStakeViewValidatorStakeStructVersion) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ValidatorStakeViewValidatorStakeStructVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::V1 => write!(f, "V1"),
        }
    }
}
impl ::std::str::FromStr for ValidatorStakeViewValidatorStakeStructVersion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "V1" => Ok(Self::V1),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ValidatorStakeViewValidatorStakeStructVersion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ValidatorStakeViewValidatorStakeStructVersion
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ValidatorStakeViewValidatorStakeStructVersion
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Data structure for semver version and github tag or commit."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Data structure for semver version and github tag or commit.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"build\","]
#[doc = "    \"commit\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"build\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"commit\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"rustc_version\": {"]
#[doc = "      \"default\": \"\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Version {
    pub build: ::std::string::String,
    pub commit: ::std::string::String,
    #[serde(default)]
    pub rustc_version: ::std::string::String,
    pub version: ::std::string::String,
}
impl ::std::convert::From<&Version> for Version {
    fn from(value: &Version) -> Self {
        value.clone()
    }
}
#[doc = "`ViewAccessKeyByBlockIdRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_access_key\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewAccessKeyByBlockIdRequestType {
    #[serde(rename = "view_access_key")]
    ViewAccessKey,
}
impl ::std::convert::From<&Self> for ViewAccessKeyByBlockIdRequestType {
    fn from(value: &ViewAccessKeyByBlockIdRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewAccessKeyByBlockIdRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewAccessKey => write!(f, "view_access_key"),
        }
    }
}
impl ::std::str::FromStr for ViewAccessKeyByBlockIdRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_access_key" => Ok(Self::ViewAccessKey),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewAccessKeyByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewAccessKeyByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewAccessKeyByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewAccessKeyByFinalityRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_access_key\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewAccessKeyByFinalityRequestType {
    #[serde(rename = "view_access_key")]
    ViewAccessKey,
}
impl ::std::convert::From<&Self> for ViewAccessKeyByFinalityRequestType {
    fn from(value: &ViewAccessKeyByFinalityRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewAccessKeyByFinalityRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewAccessKey => write!(f, "view_access_key"),
        }
    }
}
impl ::std::str::FromStr for ViewAccessKeyByFinalityRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_access_key" => Ok(Self::ViewAccessKey),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewAccessKeyByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewAccessKeyByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewAccessKeyByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewAccessKeyBySyncCheckpointRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_access_key\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewAccessKeyBySyncCheckpointRequestType {
    #[serde(rename = "view_access_key")]
    ViewAccessKey,
}
impl ::std::convert::From<&Self> for ViewAccessKeyBySyncCheckpointRequestType {
    fn from(value: &ViewAccessKeyBySyncCheckpointRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewAccessKeyBySyncCheckpointRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewAccessKey => write!(f, "view_access_key"),
        }
    }
}
impl ::std::str::FromStr for ViewAccessKeyBySyncCheckpointRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_access_key" => Ok(Self::ViewAccessKey),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewAccessKeyBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewAccessKeyBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewAccessKeyBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewAccessKeyListByBlockIdRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_access_key_list\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewAccessKeyListByBlockIdRequestType {
    #[serde(rename = "view_access_key_list")]
    ViewAccessKeyList,
}
impl ::std::convert::From<&Self> for ViewAccessKeyListByBlockIdRequestType {
    fn from(value: &ViewAccessKeyListByBlockIdRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewAccessKeyListByBlockIdRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewAccessKeyList => write!(f, "view_access_key_list"),
        }
    }
}
impl ::std::str::FromStr for ViewAccessKeyListByBlockIdRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_access_key_list" => Ok(Self::ViewAccessKeyList),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewAccessKeyListByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewAccessKeyListByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewAccessKeyListByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewAccessKeyListByFinalityRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_access_key_list\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewAccessKeyListByFinalityRequestType {
    #[serde(rename = "view_access_key_list")]
    ViewAccessKeyList,
}
impl ::std::convert::From<&Self> for ViewAccessKeyListByFinalityRequestType {
    fn from(value: &ViewAccessKeyListByFinalityRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewAccessKeyListByFinalityRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewAccessKeyList => write!(f, "view_access_key_list"),
        }
    }
}
impl ::std::str::FromStr for ViewAccessKeyListByFinalityRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_access_key_list" => Ok(Self::ViewAccessKeyList),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewAccessKeyListByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewAccessKeyListByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewAccessKeyListByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewAccessKeyListBySyncCheckpointRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_access_key_list\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewAccessKeyListBySyncCheckpointRequestType {
    #[serde(rename = "view_access_key_list")]
    ViewAccessKeyList,
}
impl ::std::convert::From<&Self> for ViewAccessKeyListBySyncCheckpointRequestType {
    fn from(value: &ViewAccessKeyListBySyncCheckpointRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewAccessKeyListBySyncCheckpointRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewAccessKeyList => write!(f, "view_access_key_list"),
        }
    }
}
impl ::std::str::FromStr for ViewAccessKeyListBySyncCheckpointRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_access_key_list" => Ok(Self::ViewAccessKeyList),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewAccessKeyListBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ViewAccessKeyListBySyncCheckpointRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ViewAccessKeyListBySyncCheckpointRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewAccountByBlockIdRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_account\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewAccountByBlockIdRequestType {
    #[serde(rename = "view_account")]
    ViewAccount,
}
impl ::std::convert::From<&Self> for ViewAccountByBlockIdRequestType {
    fn from(value: &ViewAccountByBlockIdRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewAccountByBlockIdRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewAccount => write!(f, "view_account"),
        }
    }
}
impl ::std::str::FromStr for ViewAccountByBlockIdRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_account" => Ok(Self::ViewAccount),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewAccountByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewAccountByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewAccountByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewAccountByFinalityRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_account\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewAccountByFinalityRequestType {
    #[serde(rename = "view_account")]
    ViewAccount,
}
impl ::std::convert::From<&Self> for ViewAccountByFinalityRequestType {
    fn from(value: &ViewAccountByFinalityRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewAccountByFinalityRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewAccount => write!(f, "view_account"),
        }
    }
}
impl ::std::str::FromStr for ViewAccountByFinalityRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_account" => Ok(Self::ViewAccount),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewAccountByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewAccountByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewAccountByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewAccountBySyncCheckpointRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_account\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewAccountBySyncCheckpointRequestType {
    #[serde(rename = "view_account")]
    ViewAccount,
}
impl ::std::convert::From<&Self> for ViewAccountBySyncCheckpointRequestType {
    fn from(value: &ViewAccountBySyncCheckpointRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewAccountBySyncCheckpointRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewAccount => write!(f, "view_account"),
        }
    }
}
impl ::std::str::FromStr for ViewAccountBySyncCheckpointRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_account" => Ok(Self::ViewAccount),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewAccountBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewAccountBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewAccountBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewCodeByBlockIdRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_code\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewCodeByBlockIdRequestType {
    #[serde(rename = "view_code")]
    ViewCode,
}
impl ::std::convert::From<&Self> for ViewCodeByBlockIdRequestType {
    fn from(value: &ViewCodeByBlockIdRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewCodeByBlockIdRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewCode => write!(f, "view_code"),
        }
    }
}
impl ::std::str::FromStr for ViewCodeByBlockIdRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_code" => Ok(Self::ViewCode),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewCodeByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewCodeByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewCodeByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewCodeByFinalityRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_code\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewCodeByFinalityRequestType {
    #[serde(rename = "view_code")]
    ViewCode,
}
impl ::std::convert::From<&Self> for ViewCodeByFinalityRequestType {
    fn from(value: &ViewCodeByFinalityRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewCodeByFinalityRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewCode => write!(f, "view_code"),
        }
    }
}
impl ::std::str::FromStr for ViewCodeByFinalityRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_code" => Ok(Self::ViewCode),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewCodeByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewCodeByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewCodeByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewCodeBySyncCheckpointRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_code\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewCodeBySyncCheckpointRequestType {
    #[serde(rename = "view_code")]
    ViewCode,
}
impl ::std::convert::From<&Self> for ViewCodeBySyncCheckpointRequestType {
    fn from(value: &ViewCodeBySyncCheckpointRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewCodeBySyncCheckpointRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewCode => write!(f, "view_code"),
        }
    }
}
impl ::std::str::FromStr for ViewCodeBySyncCheckpointRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_code" => Ok(Self::ViewCode),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewCodeBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewCodeBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewCodeBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewGlobalContractCodeByAccountIdByBlockIdRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_global_contract_code_by_account_id\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewGlobalContractCodeByAccountIdByBlockIdRequestType {
    #[serde(rename = "view_global_contract_code_by_account_id")]
    ViewGlobalContractCodeByAccountId,
}
impl ::std::convert::From<&Self> for ViewGlobalContractCodeByAccountIdByBlockIdRequestType {
    fn from(value: &ViewGlobalContractCodeByAccountIdByBlockIdRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewGlobalContractCodeByAccountIdByBlockIdRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewGlobalContractCodeByAccountId => {
                write!(f, "view_global_contract_code_by_account_id")
            }
        }
    }
}
impl ::std::str::FromStr for ViewGlobalContractCodeByAccountIdByBlockIdRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_global_contract_code_by_account_id" => {
                Ok(Self::ViewGlobalContractCodeByAccountId)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewGlobalContractCodeByAccountIdByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ViewGlobalContractCodeByAccountIdByBlockIdRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ViewGlobalContractCodeByAccountIdByBlockIdRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewGlobalContractCodeByAccountIdByFinalityRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_global_contract_code_by_account_id\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewGlobalContractCodeByAccountIdByFinalityRequestType {
    #[serde(rename = "view_global_contract_code_by_account_id")]
    ViewGlobalContractCodeByAccountId,
}
impl ::std::convert::From<&Self> for ViewGlobalContractCodeByAccountIdByFinalityRequestType {
    fn from(value: &ViewGlobalContractCodeByAccountIdByFinalityRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewGlobalContractCodeByAccountIdByFinalityRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewGlobalContractCodeByAccountId => {
                write!(f, "view_global_contract_code_by_account_id")
            }
        }
    }
}
impl ::std::str::FromStr for ViewGlobalContractCodeByAccountIdByFinalityRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_global_contract_code_by_account_id" => {
                Ok(Self::ViewGlobalContractCodeByAccountId)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewGlobalContractCodeByAccountIdByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ViewGlobalContractCodeByAccountIdByFinalityRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ViewGlobalContractCodeByAccountIdByFinalityRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewGlobalContractCodeByAccountIdBySyncCheckpointRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_global_contract_code_by_account_id\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewGlobalContractCodeByAccountIdBySyncCheckpointRequestType {
    #[serde(rename = "view_global_contract_code_by_account_id")]
    ViewGlobalContractCodeByAccountId,
}
impl ::std::convert::From<&Self> for ViewGlobalContractCodeByAccountIdBySyncCheckpointRequestType {
    fn from(value: &ViewGlobalContractCodeByAccountIdBySyncCheckpointRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewGlobalContractCodeByAccountIdBySyncCheckpointRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewGlobalContractCodeByAccountId => {
                write!(f, "view_global_contract_code_by_account_id")
            }
        }
    }
}
impl ::std::str::FromStr for ViewGlobalContractCodeByAccountIdBySyncCheckpointRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_global_contract_code_by_account_id" => {
                Ok(Self::ViewGlobalContractCodeByAccountId)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str>
    for ViewGlobalContractCodeByAccountIdBySyncCheckpointRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ViewGlobalContractCodeByAccountIdBySyncCheckpointRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ViewGlobalContractCodeByAccountIdBySyncCheckpointRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewGlobalContractCodeByBlockIdRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_global_contract_code\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewGlobalContractCodeByBlockIdRequestType {
    #[serde(rename = "view_global_contract_code")]
    ViewGlobalContractCode,
}
impl ::std::convert::From<&Self> for ViewGlobalContractCodeByBlockIdRequestType {
    fn from(value: &ViewGlobalContractCodeByBlockIdRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewGlobalContractCodeByBlockIdRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewGlobalContractCode => write!(f, "view_global_contract_code"),
        }
    }
}
impl ::std::str::FromStr for ViewGlobalContractCodeByBlockIdRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_global_contract_code" => Ok(Self::ViewGlobalContractCode),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewGlobalContractCodeByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ViewGlobalContractCodeByBlockIdRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewGlobalContractCodeByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewGlobalContractCodeByFinalityRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_global_contract_code\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewGlobalContractCodeByFinalityRequestType {
    #[serde(rename = "view_global_contract_code")]
    ViewGlobalContractCode,
}
impl ::std::convert::From<&Self> for ViewGlobalContractCodeByFinalityRequestType {
    fn from(value: &ViewGlobalContractCodeByFinalityRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewGlobalContractCodeByFinalityRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewGlobalContractCode => write!(f, "view_global_contract_code"),
        }
    }
}
impl ::std::str::FromStr for ViewGlobalContractCodeByFinalityRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_global_contract_code" => Ok(Self::ViewGlobalContractCode),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewGlobalContractCodeByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ViewGlobalContractCodeByFinalityRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ViewGlobalContractCodeByFinalityRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewGlobalContractCodeBySyncCheckpointRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_global_contract_code\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewGlobalContractCodeBySyncCheckpointRequestType {
    #[serde(rename = "view_global_contract_code")]
    ViewGlobalContractCode,
}
impl ::std::convert::From<&Self> for ViewGlobalContractCodeBySyncCheckpointRequestType {
    fn from(value: &ViewGlobalContractCodeBySyncCheckpointRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewGlobalContractCodeBySyncCheckpointRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewGlobalContractCode => write!(f, "view_global_contract_code"),
        }
    }
}
impl ::std::str::FromStr for ViewGlobalContractCodeBySyncCheckpointRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_global_contract_code" => Ok(Self::ViewGlobalContractCode),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewGlobalContractCodeBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String>
    for ViewGlobalContractCodeBySyncCheckpointRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String>
    for ViewGlobalContractCodeBySyncCheckpointRequestType
{
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewStateByBlockIdRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_state\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewStateByBlockIdRequestType {
    #[serde(rename = "view_state")]
    ViewState,
}
impl ::std::convert::From<&Self> for ViewStateByBlockIdRequestType {
    fn from(value: &ViewStateByBlockIdRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewStateByBlockIdRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewState => write!(f, "view_state"),
        }
    }
}
impl ::std::str::FromStr for ViewStateByBlockIdRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_state" => Ok(Self::ViewState),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewStateByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewStateByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewStateByBlockIdRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewStateByFinalityRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_state\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewStateByFinalityRequestType {
    #[serde(rename = "view_state")]
    ViewState,
}
impl ::std::convert::From<&Self> for ViewStateByFinalityRequestType {
    fn from(value: &ViewStateByFinalityRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewStateByFinalityRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewState => write!(f, "view_state"),
        }
    }
}
impl ::std::str::FromStr for ViewStateByFinalityRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_state" => Ok(Self::ViewState),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewStateByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewStateByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewStateByFinalityRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewStateBySyncCheckpointRequestType`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"view_state\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ViewStateBySyncCheckpointRequestType {
    #[serde(rename = "view_state")]
    ViewState,
}
impl ::std::convert::From<&Self> for ViewStateBySyncCheckpointRequestType {
    fn from(value: &ViewStateBySyncCheckpointRequestType) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ViewStateBySyncCheckpointRequestType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ViewState => write!(f, "view_state"),
        }
    }
}
impl ::std::str::FromStr for ViewStateBySyncCheckpointRequestType {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "view_state" => Ok(Self::ViewState),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ViewStateBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ViewStateBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ViewStateBySyncCheckpointRequestType {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "`ViewStateResult`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"values\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"proof\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"values\": {"]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"$ref\": \"#/components/schemas/StateItem\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ViewStateResult {
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub proof: ::std::vec::Vec<::std::string::String>,
    pub values: ::std::vec::Vec<StateItem>,
}
impl ::std::convert::From<&ViewStateResult> for ViewStateResult {
    fn from(value: &ViewStateResult) -> Self {
        value.clone()
    }
}
#[doc = "`VmConfigView`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"discard_custom_sections\","]
#[doc = "    \"eth_implicit_accounts\","]
#[doc = "    \"ext_costs\","]
#[doc = "    \"fix_contract_loading_cost\","]
#[doc = "    \"global_contract_host_fns\","]
#[doc = "    \"grow_mem_cost\","]
#[doc = "    \"implicit_account_creation\","]
#[doc = "    \"limit_config\","]
#[doc = "    \"reftypes_bulk_memory\","]
#[doc = "    \"regular_op_cost\","]
#[doc = "    \"saturating_float_to_int\","]
#[doc = "    \"storage_get_mode\","]
#[doc = "    \"vm_kind\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"discard_custom_sections\": {"]
#[doc = "      \"description\": \"See [VMConfig::discard_custom_sections](crate::vm::Config::discard_custom_sections).\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"eth_implicit_accounts\": {"]
#[doc = "      \"description\": \"See [VMConfig::eth_implicit_accounts](crate::vm::Config::eth_implicit_accounts).\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"ext_costs\": {"]
#[doc = "      \"description\": \"Costs for runtime externals\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/ExtCostsConfigView\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"fix_contract_loading_cost\": {"]
#[doc = "      \"description\": \"See [VMConfig::fix_contract_loading_cost](crate::vm::Config::fix_contract_loading_cost).\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"global_contract_host_fns\": {"]
#[doc = "      \"description\": \"See [VMConfig::global_contract_host_fns](crate::vm::Config::global_contract_host_fns).\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"grow_mem_cost\": {"]
#[doc = "      \"description\": \"Gas cost of a growing memory by single page.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"implicit_account_creation\": {"]
#[doc = "      \"description\": \"See [VMConfig::implicit_account_creation](crate::vm::Config::implicit_account_creation).\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"limit_config\": {"]
#[doc = "      \"description\": \"Describes limits for VM and Runtime.\\n\\nTODO: Consider changing this to `VMLimitConfigView` to avoid dependency\\non runtime.\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/LimitConfig\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"reftypes_bulk_memory\": {"]
#[doc = "      \"description\": \"See [VMConfig::reftypes_bulk_memory](crate::vm::Config::reftypes_bulk_memory).\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"regular_op_cost\": {"]
#[doc = "      \"description\": \"Gas cost of a regular operation.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint32\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"saturating_float_to_int\": {"]
#[doc = "      \"description\": \"See [VMConfig::saturating_float_to_int](crate::vm::Config::saturating_float_to_int).\","]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    },"]
#[doc = "    \"storage_get_mode\": {"]
#[doc = "      \"description\": \"See [VMConfig::storage_get_mode](crate::vm::Config::storage_get_mode).\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/StorageGetMode\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"vm_kind\": {"]
#[doc = "      \"description\": \"See [VMConfig::vm_kind](crate::vm::Config::vm_kind).\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/components/schemas/VMKind\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct VmConfigView {
    #[doc = "See [VMConfig::discard_custom_sections](crate::vm::Config::discard_custom_sections)."]
    pub discard_custom_sections: bool,
    #[doc = "See [VMConfig::eth_implicit_accounts](crate::vm::Config::eth_implicit_accounts)."]
    pub eth_implicit_accounts: bool,
    #[doc = "Costs for runtime externals"]
    pub ext_costs: ExtCostsConfigView,
    #[doc = "See [VMConfig::fix_contract_loading_cost](crate::vm::Config::fix_contract_loading_cost)."]
    pub fix_contract_loading_cost: bool,
    #[doc = "See [VMConfig::global_contract_host_fns](crate::vm::Config::global_contract_host_fns)."]
    pub global_contract_host_fns: bool,
    #[doc = "Gas cost of a growing memory by single page."]
    pub grow_mem_cost: u32,
    #[doc = "See [VMConfig::implicit_account_creation](crate::vm::Config::implicit_account_creation)."]
    pub implicit_account_creation: bool,
    #[doc = "Describes limits for VM and Runtime.\n\nTODO: Consider changing this to `VMLimitConfigView` to avoid dependency\non runtime."]
    pub limit_config: LimitConfig,
    #[doc = "See [VMConfig::reftypes_bulk_memory](crate::vm::Config::reftypes_bulk_memory)."]
    pub reftypes_bulk_memory: bool,
    #[doc = "Gas cost of a regular operation."]
    pub regular_op_cost: u32,
    #[doc = "See [VMConfig::saturating_float_to_int](crate::vm::Config::saturating_float_to_int)."]
    pub saturating_float_to_int: bool,
    #[doc = "See [VMConfig::storage_get_mode](crate::vm::Config::storage_get_mode)."]
    pub storage_get_mode: StorageGetMode,
    #[doc = "See [VMConfig::vm_kind](crate::vm::Config::vm_kind)."]
    pub vm_kind: VmKind,
}
impl ::std::convert::From<&VmConfigView> for VmConfigView {
    fn from(value: &VmConfigView) -> Self {
        value.clone()
    }
}
#[doc = "`VmKind`"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"Wasmer 0.17.x VM. Gone now.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Wasmer0\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Wasmtime VM.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Wasmtime\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Wasmer 2.x VM.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Wasmer2\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"NearVM.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"NearVm\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"NearVM. Exists temporarily while bulk memory and reftypes are getting enabled.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"NearVm2\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum VmKind {
    #[doc = "Wasmer 0.17.x VM. Gone now."]
    Wasmer0,
    #[doc = "Wasmtime VM."]
    Wasmtime,
    #[doc = "Wasmer 2.x VM."]
    Wasmer2,
    #[doc = "NearVM."]
    NearVm,
    #[doc = "NearVM. Exists temporarily while bulk memory and reftypes are getting enabled."]
    NearVm2,
}
impl ::std::convert::From<&Self> for VmKind {
    fn from(value: &VmKind) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for VmKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Wasmer0 => write!(f, "Wasmer0"),
            Self::Wasmtime => write!(f, "Wasmtime"),
            Self::Wasmer2 => write!(f, "Wasmer2"),
            Self::NearVm => write!(f, "NearVm"),
            Self::NearVm2 => write!(f, "NearVm2"),
        }
    }
}
impl ::std::str::FromStr for VmKind {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Wasmer0" => Ok(Self::Wasmer0),
            "Wasmtime" => Ok(Self::Wasmtime),
            "Wasmer2" => Ok(Self::Wasmer2),
            "NearVm" => Ok(Self::NearVm),
            "NearVm2" => Ok(Self::NearVm2),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for VmKind {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for VmKind {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for VmKind {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "A kind of a trap happened during execution of a binary"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"A kind of a trap happened during execution of a binary\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"description\": \"An `unreachable` opcode was executed.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"Unreachable\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Call indirect incorrect signature trap.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"IncorrectCallIndirectSignature\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Memory out of bounds trap.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"MemoryOutOfBounds\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Call indirect out of bounds trap.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"CallIndirectOOB\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"An arithmetic exception, e.g. divided by zero.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"IllegalArithmetic\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Misaligned atomic access trap.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"MisalignedAtomicAccess\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Indirect call to null.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"IndirectCallToNull\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Stack overflow.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"StackOverflow\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"description\": \"Generic trap.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"GenericTrap\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WasmTrap {
    #[doc = "An `unreachable` opcode was executed."]
    Unreachable,
    #[doc = "Call indirect incorrect signature trap."]
    IncorrectCallIndirectSignature,
    #[doc = "Memory out of bounds trap."]
    MemoryOutOfBounds,
    #[doc = "Call indirect out of bounds trap."]
    #[serde(rename = "CallIndirectOOB")]
    CallIndirectOob,
    #[doc = "An arithmetic exception, e.g. divided by zero."]
    IllegalArithmetic,
    #[doc = "Misaligned atomic access trap."]
    MisalignedAtomicAccess,
    #[doc = "Indirect call to null."]
    IndirectCallToNull,
    #[doc = "Stack overflow."]
    StackOverflow,
    #[doc = "Generic trap."]
    GenericTrap,
}
impl ::std::convert::From<&Self> for WasmTrap {
    fn from(value: &WasmTrap) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WasmTrap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Unreachable => write!(f, "Unreachable"),
            Self::IncorrectCallIndirectSignature => write!(f, "IncorrectCallIndirectSignature"),
            Self::MemoryOutOfBounds => write!(f, "MemoryOutOfBounds"),
            Self::CallIndirectOob => write!(f, "CallIndirectOOB"),
            Self::IllegalArithmetic => write!(f, "IllegalArithmetic"),
            Self::MisalignedAtomicAccess => write!(f, "MisalignedAtomicAccess"),
            Self::IndirectCallToNull => write!(f, "IndirectCallToNull"),
            Self::StackOverflow => write!(f, "StackOverflow"),
            Self::GenericTrap => write!(f, "GenericTrap"),
        }
    }
}
impl ::std::str::FromStr for WasmTrap {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "Unreachable" => Ok(Self::Unreachable),
            "IncorrectCallIndirectSignature" => Ok(Self::IncorrectCallIndirectSignature),
            "MemoryOutOfBounds" => Ok(Self::MemoryOutOfBounds),
            "CallIndirectOOB" => Ok(Self::CallIndirectOob),
            "IllegalArithmetic" => Ok(Self::IllegalArithmetic),
            "MisalignedAtomicAccess" => Ok(Self::MisalignedAtomicAccess),
            "IndirectCallToNull" => Ok(Self::IndirectCallToNull),
            "StackOverflow" => Ok(Self::StackOverflow),
            "GenericTrap" => Ok(Self::GenericTrap),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WasmTrap {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WasmTrap {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WasmTrap {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Configuration specific to ChunkStateWitness."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"Configuration specific to ChunkStateWitness.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"combined_transactions_size_limit\","]
#[doc = "    \"main_storage_proof_size_soft_limit\","]
#[doc = "    \"new_transactions_validation_state_size_soft_limit\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"combined_transactions_size_limit\": {"]
#[doc = "      \"description\": \"Maximum size of transactions contained inside ChunkStateWitness.\\n\\nA witness contains transactions from both the previous chunk and the current one.\\nThis parameter limits the sum of sizes of transactions from both of those chunks.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"main_storage_proof_size_soft_limit\": {"]
#[doc = "      \"description\": \"Size limit for storage proof generated while executing receipts in a chunk.\\nAfter this limit is reached we defer execution of any new receipts.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    },"]
#[doc = "    \"new_transactions_validation_state_size_soft_limit\": {"]
#[doc = "      \"description\": \"Soft size limit of storage proof used to validate new transactions in ChunkStateWitness.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"format\": \"uint64\","]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct WitnessConfigView {
    #[doc = "Maximum size of transactions contained inside ChunkStateWitness.\n\nA witness contains transactions from both the previous chunk and the current one.\nThis parameter limits the sum of sizes of transactions from both of those chunks."]
    pub combined_transactions_size_limit: u32,
    #[doc = "Size limit for storage proof generated while executing receipts in a chunk.\nAfter this limit is reached we defer execution of any new receipts."]
    pub main_storage_proof_size_soft_limit: u64,
    #[doc = "Soft size limit of storage proof used to validate new transactions in ChunkStateWitness."]
    pub new_transactions_validation_state_size_soft_limit: u64,
}
impl ::std::convert::From<&WitnessConfigView> for WitnessConfigView {
    fn from(value: &WitnessConfigView) -> Self {
        value.clone()
    }
}
#[doc = r" Generation of default values for serde."]
pub mod defaults {
    pub(super) fn default_u64<T, const V: u64>() -> T
    where
        T: ::std::convert::TryFrom<u64>,
        <T as ::std::convert::TryFrom<u64>>::Error: ::std::fmt::Debug,
    {
        T::try_from(V).unwrap()
    }
    pub(super) fn execution_outcome_view_metadata() -> super::ExecutionMetadataView {
        super::ExecutionMetadataView {
            gas_profile: Default::default(),
            version: 1_u32,
        }
    }
    pub(super) fn gc_config_gc_step_period() -> super::DurationAsStdSchemaProvider {
        super::DurationAsStdSchemaProvider {
            nanos: 500000000_i32,
            secs: 0_i64,
        }
    }
    pub(super) fn genesis_config_minimum_stake_ratio() -> [i32; 2usize] {
        [1_i32, 6250_i32]
    }
    pub(super) fn genesis_config_online_max_threshold() -> [i32; 2usize] {
        [99_i32, 100_i32]
    }
    pub(super) fn genesis_config_online_min_threshold() -> [i32; 2usize] {
        [9_i32, 10_i32]
    }
    pub(super) fn genesis_config_protocol_upgrade_stake_threshold() -> [i32; 2usize] {
        [4_i32, 5_i32]
    }
    pub(super) fn genesis_config_shard_layout() -> super::ShardLayout {
        super::ShardLayout::V2(super::ShardLayoutV2 {
            boundary_accounts: vec![],
            id_to_index_map: [("0".to_string(), 0_u32)].into_iter().collect(),
            index_to_id_map: [("0".to_string(), super::ShardId(0_u64))]
                .into_iter()
                .collect(),
            shard_ids: vec![super::ShardId(0_u64)],
            shards_parent_map: ::std::option::Option::None,
            shards_split_map: ::std::option::Option::None,
            version: 0_u32,
        })
    }
    pub(super) fn limit_config_account_id_validity_rules_version(
    ) -> super::AccountIdValidityRulesVersion {
        super::AccountIdValidityRulesVersion(0_u8)
    }
    pub(super) fn rpc_send_transaction_request_wait_until() -> super::TxExecutionStatus {
        super::TxExecutionStatus::ExecutedOptimistic
    }
    pub(super) fn rpc_transaction_status_request_variant0_wait_until() -> super::TxExecutionStatus {
        super::TxExecutionStatus::ExecutedOptimistic
    }
    pub(super) fn rpc_transaction_status_request_variant1_wait_until() -> super::TxExecutionStatus {
        super::TxExecutionStatus::ExecutedOptimistic
    }
}
